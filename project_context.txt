ASBL Basketball Manager - 專案程式碼匯總
生成時間: N/A
============================================================

File: ASBL_Match_Engine_Specification.md
------------------------------------------------------------
# ASBL 比賽引擎規格書 (v2.3) ASBL_Match_Engine_Specification.md

**版本**：2.3
**狀態**：已確認 (Confirmed)
**最後更新**2026-01-07
**變更記錄**：
*   **v1.0 (2025-12-04)**：初始版本
*   **v1.2 (2025-12-07)**：體力消耗公式係數調整、基礎命中率調整 (Base Shooting Percentage)
*   **v1.3 (2025-12-07)**：再度調整體力消耗公式係數
*   **v1.4 (2025-12-07)**：新增數據歸屬判定機制 (Data Attribution)，定義球員個人數據分配邏輯。
*   **v1.5 (2025-12-13)**：新增犯規離場規則 (6犯)，定義犯滿後的上場時間重分配機制。
*   **v1.6 (2025-12-16)**：新增開場跳球機制、節次球權輪替規則 (Q2/Q3負方, Q4勝方)、首回合強制後場時間。
*   **v1.7 (2025-12-20)**：修正三分球基礎命中率。
*   **v1.8 (2025-12-20)**：重構投籃結算流程 (Section 5)，調整判定順序為：類型判定 -> 命中計算 -> 犯規判定；**新增輸出數據定義 (Section 7)**。
*   **v2.1 (2025-12-28)**：
    *   **新增**: 賽前身高修正機制 (Height Correction)。
    *   **調整**: 體力系統引入「年齡衰退」參數 (20歲/1%)；中場與節間休息改為時間恢復制。
    *   **調整**: 後場事件 (Backcourt) 引入身高懲罰。
    *   **調整**: 前場封蓋 (Block) 雙方皆受身高加成。
    *   **調整**: 前場抄截 (Steal) 雙方皆受身高懲罰，防守方新增「跑位」 `off_move`。
    *   **調整**: 投籃判定 (Shooting) 引入身高加成；三分球加權 `shot_accuracy` 與 `shot_range`；防守方移除 `def_rebound`。
    *   **調整**: 籃板判定 (Rebound) 雙方皆受身高加成。
    *   **優化**: 全文屬性名稱統一為 Config Key 格式。
*   **v2.2 (2026-01-07)**：
    *   **新增**: 投籃命中率公式加入 **技巧加成 (Skill Bonus)** 機制，公式為 `1 + (accuracy+range+off_move)/800`，強化高數值射手優勢，並且將三分加成同步加上 `off_move`。
*   **v2.3 (2026-01-07)**：
    *   **新增**: 抄截後的攻守轉換。

---

## 0. 全域規則 (General Rules)
*   **數值引用**: 引擎中所有涉及屬性的計算 (命中、對抗、判定)，皆必須使用經由 **體力衰退修正後** 的「當前能力值」。
*   **平手處理**: 若正規時間 (4節) 結束平手，進入延長賽 (OT)。
    *   OT 時間: 5 分鐘。
    *   體力: **不重置** (延續正規賽狀態)。

---

## 1. 賽前準備 (Pre-Game Setup)

### 1.1 位置能力評分 (Positional Scoring)
比賽開始前，系統需針對每位球員計算五個位置的適性分數，用於決定輪替順序。
*   **最強陣容 (Best 5)**: 系統需標記出該隊五個位置分數最高的組合，用於關鍵時刻。

| 位置                | 計算公式 (由高至低排序)                                        |
| :------------------ | :----------------------------------------------------------- |
| **中鋒 (C)**        | 身高 + 力量 + 籃板 + 卡位 + 干擾                               |
| **大前鋒 (PF)**     | 身高 + 力量 + 籃板 + 卡位 + 干擾 + 彈跳 + 速度                  |
| **小前鋒 (SF)**     | **全部 20 項屬性總和 + 身高**                                  |
| **得分後衛 (SG)**   | 手感 + 出手速度 + 進攻智商 + 防守智商 + 干擾 + 抄截 + 射程       |
| **控球後衛 (PG)**   | 速度 + 進攻智商 + 抄截 + 運球 + 控球 + 傳球 - **身高**          |

### 1.2 先發陣容決定邏輯 (Starting Lineup)
系統依據以下優先順序填入先發五人 (PG, SG, SF, PF, C)
填入順序按照**明星**->**先發**->其他(PG, C, SG, SF, PF)：

1.  **明星優先 (Star Priority)**
    *   隊伍中的 `Star` 球員擁有最高優先權。
    *   若有多位 `Star`，依據「位置評分」最高的順位優先鎖定位置。

2.  **先發填補 (Starter Fill)**
    *   `Star` 分配完畢後，由 `Starter` 球員填補剩餘空缺。

3.  **剩餘填補 (Fill Gaps)**
    *   若 5 個位置仍有空缺，由剩餘球員中「該位置評分最高者」填補。

### 1.3 輪替排序 (Rotation Order)
*   非先發球員依據各位置評分高低列入替補名單。
*   實際換人時機由體力系統控制。
*   若球員已達時間上限，非必要不上場

### 1.4 比賽時間分配規則補充 (Minutes Distribution)
系統需將 240 分鐘分配給登錄球員，作為換人參考。
*   **分配演算法**: `個人時間 = 保底時間 + (權重 * 單位時間價值)`。
*   **角色參數**:
    *   **Star**: 保底 30min, 權重 -1~5。
    *   **Starter**: 保底 20min, 權重 -2~7。
    *   **Rotation**: 保底 10min, 權重 5~15。
    *   **Role**: 保底 0min, 權重 5~12。
    *   **Bench**: 保底 0min, 權重 0~10。
*   **計算邏輯**:
    1.  扣除總保底時間，剩餘時間依權重比例分配。
    2.  計算結果無條件捨去至小數點第一位。
    3.  尾數誤差補給最後一位球員。

### 1.5 身高屬性修正 (Initial Height Correction) [New v2.1]
在比賽載入階段，針對特定屬性進行基於身高的物理修正。此修正為「永久性修正」(針對該場比賽)，先於體力修正計算。

*   **修正公式**:
    `修正屬性 = 修正屬性 * (1+(max(BONUS_H - hight,min(NERF_H - hight, 0))) * Coeff`

*   **參數設定 (Parameters)**:
    *   `BONUS_H` (矮個加成閾值): **190** (cm)
    *   `NERF_H` (高個減益閾值): **210** (cm)
    *   **受影響屬性與係數 (Coeff)**:
        *   `速度 (ath_speed)`, `運球 (off_dribble)`: **0.02**
        *   `控球 (off_handle)`, `抄截 (def_disrupt)`: **0.01**

### 1.6 開場跳球與球權輪替 (Jump Ball & Possession) [New v1.6]
決定比賽開始的球權歸屬以及各節次的開球方。

*   **跳球參與者 (Participants)**:
    *   兩隊分別選出 **(身高 + 彈跳 + 進攻智商)** 總和最高的球員代表跳球。
*   **獲勝判定 (Winning Logic)**:
    *   計算兩位參與者的數值總和 (Score_Home, Score_Away)。
    *   **獲勝機率**: `P(Home) = Score_Home / (Score_Home + Score_Away)`。
    *   系統依據此機率隨機決定跳球獲勝方 (Winner)。
*   **節次球權歸屬 (Quarter Possession)**:
    *   **第 1 節 (Q1)**: **跳球獲勝方** 獲得球權。
    *   **第 2 節 (Q2)**: **跳球失敗方** 獲得球權。
    *   **第 3 節 (Q3)**: **跳球失敗方** 獲得球權。
    *   **第 4 節 (Q4)**: **跳球獲勝方** 獲得球權。
    *   **延長賽 (OT)**: 重新跳球 (規則同 Q1)。

---

## 2. 體力系統 (Stamina System)

### 2.1 基礎參數
*   **初始體力**: 100 (每場比賽重置)。
*   **中場回復**: 移除固定增加，改由體力恢復章節回復。 **[New v2.1]**
*   **換人門檻**: 當場上球員體力 **< 80** 時，觸發換人檢查。

### 2.2 能力值動態修正 (Dynamic Nerf)
體力下降會直接削弱球員當下的能力值。

| 當前體力   | 修正係數 (Multiplier)        | 說明                                               |
| :--------- | :--------------------------- | :----------------------------------------------- |
| **80~100** | **1.0x** (100%)              | 狀態良好，無影響。                                 |
| **< 80**   | **1.0 - (80-體力)*0.01**     | 線性衰退 (例: 70體力=90%能力; 40體力=60%能力)。     |
| **1**      | **0.21x** (21%)              | 極限狀態，能力值僅剩 21%。                         |

### 2.3 體力消耗 (Drain) - *上場時*
*   **公式**: `消耗量/分 = (3.0 * (1 + (1 - 體能%) + (1 - 健康%))) * ((1 + (Age - AGE_THRESHOLD)) * AGE_DECAY_RATE)` 
        **(V1.2 從2.0增加至2.5，V1.3從2.5增加至3.0，v2.1增加年齡修正)**
*   **變數轉換**:
    *   `體能%`: 屬性 `ath_stamina` (1~99 轉為 0.01~0.99)。
    *   `健康%`: 屬性 `talent_health` (1~99 轉為 0.01~0.99)。
    *   `AGE_THRESHOLD` (衰退起始年齡): **20**        **[New v2.1]**
    *   `AGE_DECAY_RATE` (衰退係數): **0.01**         **[New v2.1]**
*   **模型驗證 (以健康 60 為例)**:
    *   **體能 10 (差)**: 每分鐘消耗約 **3.75** (上場約 5.3 分鐘開始衰退)。
    *   **體能 60 (中)**: 每分鐘消耗約 **3.20** (上場約 6.2 分鐘開始衰退)。
    *   **體能 99 (優)**: 每分鐘消耗約 **2.42** (上場約 8.2 分鐘開始衰退)。

### 2.4 體力恢復 (Recovery) - *板凳時*
*   **公式**: `恢復量/分 = (1.0 + (體能%) - (1 - 健康%)) * ((1 - (Age - AGE_THRESHOLD)) * AGE_DECAY_RATE)`
            **[New v2.1 增加年齡修正]**
*   **邏輯**: 體能越好、健康越好，體力回得越快。
*   **模型驗證 (以健康 60 為例)**:
    *   **體能 10**: 每分鐘恢復 **0.7**。
    *   **體能 60**: 每分鐘恢復 **1.2**。
    *   **體能 99**: 每分鐘恢復 **1.59**。
*   **休息事件恢復 [New v2.1]**:
    *   **節與節之間 (Quarter Break)**: 模擬休息 **2 分鐘**。
        *   `Recovery = 恢復率 * 2.0`
    *   **中場休息 (Halftime)**: 模擬休息 **20 分鐘**。
        *   `Recovery = 恢復率 * 20.0`
*   **限制**: 體力值最低為 1，上限為 100。

### 2.5 換人執行 (Substitution Execution)
比賽進行中，依據以下優先順序執行換人：

1.  **關鍵時刻強制調度 (Clutch Override)**
    *   **時機**: 第 4 節最後 2 分鐘 (剩餘時間 <= 2:00) 及 延長賽 (OT) 最後 2 分鐘 (剩餘時間 <= 2:00)。
                **[New v2.1 修正]**
    *   **執行**: **強制換上「最強陣容 (Best 5)」**。
    *   *例外*: 除非該球員犯滿離場或受傷，否則無視體力狀況與時間限制。

2.  **常規換人 (Regular Rotation)**
    *   **觸發條件**:
        *   場上球員體力 **< 80**。
        *   或 場上球員已超過「目標上場時間」。
    *   **替補選擇**:
        *   選擇同位置中「體力 > 場上球員」且「未達時間上限」能力最強者。

#### **2.6 犯規與離場 (Fouls & Disqualification)**
*   **個人犯規上限**: 每位球員單場比賽累計犯規次數達到 **6 次** 時，即判定為「犯滿離場 (Fouled Out)」。
*   **離場處置**:
    *   該球員必須立即被替換下場。
    *   該球員在剩餘比賽時間內（含延長賽）不得再次上場。
*   **時間重分配 (Time Redistribution)**:
    *   當球員離場後，其剩餘的「目標上場時間」需分配給其他隊友，以確保比賽能順利進行。
    *   **分配邏輯**:
        1.  系統依序檢查 C -> PF -> SF -> SG -> PG 五個位置。
        2.  每個位置選出「位置評分」最高的前 3 名球員 (排除已離場者)。
        3.  將離場球員的剩餘時間，平均分配給這 15 個名額 (若球員同時是多個位置的前 3 名，則獲得多份時間)。
        4.  *公式*: `每份時間 = 離場者剩餘時間 / 15`。

## 3. 比賽引擎：後場階段 (Backcourt Phase)

### 3.1 基礎設定
*   **參與者**:
    *   **進攻方**: PG + SG + 隨機 1 名球員 (共 3 人)。
    *   **防守方**: 對應的 3 名防守者。
*   **屬性池**: **[New v2.1 增加身高修正]**
    *   `進攻總值 (Off_Sum)` = 3 人的 (運球 + 傳球 + 進攻智商 - 身高) 總和。
    *   `防守總值 (Def_Sum)` = 3 人的 (抄截 + 干擾 + 防守智商 - 身高) 總和。

### 3.2 時間計算 (Time Calculation)
1.  **基礎時間**: 隨機骰 **1.0 ~ 8.0** 秒 (取至小數點第一位)。
2.  **時間修正**:
    *   **公式**: `修正秒數 = (Def_Sum - Off_Sum) * 0.008`
    *   *說明*: 原係數 0.01 的 80%。
    *   *範例*: 數值差 100 點 -> 影響 0.8 秒。
3.  **最終時間**: `基礎時間 + 修正秒數`。
    *   **上下限**: 鎖定在 **0.5 ~ 8.1** 秒之間。

### 3.3 事件判定
根據 `最終時間` 觸發對應事件：

| 最終時間     | 觸發事件     | 判定邏輯                |
| :----------- | :----------- | :---------------------- |
| **> 8.0 秒** | **8秒違例**  | 進攻方失誤，球權轉換。  |
| **> 3.0 秒** | **抄截判定** | 進入抄截檢定 (見 3.4)。 |
| **1.0 ~ 3.0**| **正常推進** | 安全過半場。            |
| **< 1.0 秒** | **快攻**     | 進入快攻檢定 (見 3.5)。 |

### 3.4 抄截判定 (Backcourt Steal)
*   **基礎機率**: **1%**。
*   **機率加成**: `(Def_Sum - Off_Sum) * 0.1%`。
*   **結算**: 骰 `1-100` <= 最終機率則失誤。

### 3.4.1 抄截後的攻守轉換 (Transition after Steal) [Update v2.3]

當後場抄截判定成功時，系統需判定是發動「轉換快攻」還是進入「前場陣地戰」。

*   **觸發條件**: `3.4` 抄截判定成功。
*   **轉換快攻判定公式**:
    *   **屬性定義**: 取雙方 **場上5人** 的 `速度 (ath_speed)` 總和。
    *   **機率**: `50% + (原守方速度總和 - 原攻方速度總和) / 原攻方速度總和`。
    *   *說明*: 若防守方整體速度快於進攻方，快攻機率提升；反之則傾向穩紮穩打。
*   **流程分支**:
    1.  **判定通過 (Fastbreak)**:
        *   立即執行 **3.5 快攻判定**。
        *   攻守角色互換 (原守方變進攻方)。
    2.  **判定失敗 (Set Play)**:
        *   **跳過後場階段**，直接進入 **4. 前場階段**。
        *   攻守角色互換 (原守方變進攻方)。
        *   *說明*: 模擬抄截後對方快速回防，雖未形成快攻，但已推進至前場。

### 3.5 快攻判定 (Fastbreak)
當推進極快時觸發，由雙方「跑最快」的球員進行 1v1 綜合能力對決。

#### A. 參與者屬性計算 **[New v2.1 增加投籃技巧修正]**
*   **進攻者 (Off)**: 取場上 `(速度 + 運球)` 最高者。
    *   `Off_Stat` = 力量 + 速度 + 彈跳 + 手感 + 出手速度 + 進攻智商 + 運氣 + 跑位 + 運球 + 投籃技巧
*   **防守者 (Def)**: 取場上 `(速度 + 防守智商)` 最高者。
    *   `Def_Stat` = 力量 + 速度 + 彈跳 + 手感 + 出手速度 + 防守智商 + 運氣 + 干擾 + 抄截 + 投籃技巧

#### B. 進球成功率 (Success Rate)
*   **基礎成功率 (Base)**: 隨機產生 **0.3 ~ 1.0** (30% ~ 100%)。
    *   *代表快攻當下的混亂程度與機會好壞。*
*   **屬性修正**: `(Off_Stat - Def_Stat) * 0.5%`。
*   **最終成功率**: `Base + 屬性修正` (上限 100%)。
*   **進球判定**: 骰 `1-100` <= 最終成功率 -> **進球**。

#### C. 犯規判定 (Foul Check)
無論是否進球，皆需進行犯規檢定。
*   **核心屬性**: `進攻智商 (Off_IQ)` vs `防守智商 (Def_IQ)`。
*   **犯規機率**: `1% + (Off_IQ - Def_IQ) * 1%`。
    *   *說明*: 基礎 1%，智商每高對手 1 點，多 1% 要到犯規機率。
    *   *下限*: 最低 0.1%。
*   **犯規判定**: 骰 `0-100` <= 犯規機率 -> **觸發犯規**。

#### D. 最終結果結算 (Outcome)
| 進球判定 | 犯規判定 | 結果描述 | 得分 | 後續 |
| :--- | :--- | :--- | :--- | :--- |
| **成功** | **無** | **快攻得分** | +2 | 攻守交換 |
| **成功** | **有** | **進算加罰 (And-1)** | +2 | 執行 1 次罰球 |
| **失敗** | **有** | **阻擋/打手犯規** | 0 | 執行 2 次罰球 |
| **失敗** | **無** | **防守成功** | 0 | 攻守交換 (視為籃板/火鍋) |

## 4. 比賽引擎：前場階段 (Frontcourt Phase)

### 4.1 進攻時間與出手品質
*   **基礎時間範圍**: `8.0` ~ `上限` 秒。
    *   **上限**: 一般回合為 `24.0 - 後場花費時間`；前場籃板回合為 `14.0`。
*   **時間下限修正**:
    *   **影響屬性**: `速度` (不可訓練), `進攻智商` (不可訓練), `傳球` (可訓練)。
    *   **邏輯**: 團隊上述三項屬性越高，能降低時間花費的下限 (最低不低於 4.0 秒)。
*   **實際花費時間**: 在 `修正後下限` 與 `上限` 之間隨機產生。
*   **出手品質加成**: 時間花費越少 -> 出手品質加成越高，實際公式：時間加成 = (7 - **實際花費時間**) * 0.01。

### 4.2 空間與跑位 (Spacing)
*   **影響屬性**:
    *   **進攻方 (Off_Sum)**: `跑位` (可訓練) + `進攻智商` (不可訓練)。
    *   **防守方 (Def_Sum)**: `跑位` (可訓練) + `防守智商` (不可訓練)。
*   **空間加成係數 (Spacing Bonus)**:
    *   **公式**: `(Off_Sum - Def_Sum) / Def_Sum`，以25%為下限、125%為上限，隨機產生。
    *   **上限**: 最大值為 **1.0**。
*   **空間效果判定**:
    *   **加成 > 0.5**: **完全空檔 (Wide Open)**，封蓋不會發生 (機率 = 0%)。
    *   **加成 < 0**: **空間擁擠**，增加被封蓋的機率。
    *   **一般情況 (0 ~ 0.5)**: 正常計算封蓋機率。

### 4.3 防守事件：封蓋 (Block)
封蓋判定分為兩個階段：**觸發判定** 與 **對抗判定**。

#### 階段一：觸發判定 (Attempt Check)
決定防守者是否能跟上並嘗試封蓋。
*   **前提**: 若 `空間加成 > 0.5`，此階段直接失敗 (無法封蓋)。
*   **基礎機率**: **1%**。
*   **機率修正**:
    *   **降低**: 進攻方 `跑位`。
    *   **提升**: 防守方 `干擾` + `防守智商`。
    *   **空間懲罰**: 若 `空間加成 < 0`，額外大幅提升觸發機率。
*   **結果**: 若判定通過，進入階段二；否則無封蓋。

#### 階段二：對抗判定 (Success Check)
決定是「成功蓋火鍋」還是「進攻方強行出手/灌籃」。
*   **對抗公式**: **[New v2.1 增加身高修正]**
    *   `進攻力 (Off_Power)` = 力量 + 彈跳 + 進攻智商 + 身高
    *   `防守力 (Def_Power)` = 力量 + 彈跳 + 干擾 + 防守智商 + 身高
    *   **判定標準 (Ratio)** = `Off_Power / Def_Power`
*   **結算邏輯**:
    *   **Ratio 數值越低**: 防守方優勢越大 -> **封蓋成功 (Block)**。
    *   **Ratio 數值越高**: 進攻方優勢越大 -> **封蓋失敗** (可能轉為犯規或強行進球)。

### 4.4 防守事件：抄截 (Steal)
*   **基礎機率**: **1%**。
*   **影響屬性**: **[New v2.1 增加身高、智商、跑位修正]**
    *   **進攻方 (Off_Ball)**: `運球` + `控球` + `傳球` - `身高` + `進攻智商` 。
    *   **防守方 (Def_Steal)**: `速度` (不可訓練) + `抄截` (可訓練) + `防守智商` (不可訓練) - `身高` + `跑位` (可訓練)。
*   **判定流程**:
    *   計算雙方屬性差值。
    *   **最終機率** = `1% + (Def_Steal - Off_Ball) * 係數`。
    *   骰 `1-100` <= 最終機率 -> **抄截成功 (Turnover)**。

## 5. 比賽引擎：投籃命中與結算 (Shooting & Scoring) **(v1.8 重構投籃判定機制)**

### 5.1 投籃類型判定 (Shot Type Determination)
若前場階段未發生失誤或被封蓋，首先決定這是一記 2 分球還是 3 分球。

*   **閾值計算**: `Threshold = 1 / (進攻方射程總和 / 100)`。
*   **判定**: 骰一個隨機數 `R` (0.0 ~ 1.0)。
    *   若 `R > Threshold`: **+3 分** (三分球)。
    *   若 `R <= Threshold`: **+2 分** (兩分球)。
*   *邏輯驗證*: 射程越高 -> Threshold 越小 -> R 大於它的機率越高 -> 越容易是三分。
*   **輸出**: 決定本回合的 **基礎命中率 (Base Rate)**。 **(v1.7 新增三分球)**
    *   **兩分球**: **40%**
    *   **三分球**: **20%**

### 5.2 命中率判定 (Hit Rate Calculation)
依據投籃類型與雙方屬性計算最終命中率。

#### A. 屬性池定義 **[New v2.1 增加身高、三分球加成修正]**
*   **進攻方總和 (Off_Total)**:
    *   `力量` + `速度` + `彈跳` + `手感` + `出手速度` + `進攻智商` + `運氣` + `投籃技巧` + `射程` + `跑位` + `運球` + `傳球` + `控球` + `身高` (共 14 項)。
    *   **3分球特殊加成**: 若判定為 3分球，則 `shot_accuracy` 、 `shot_range` 與 `off_move` 的數值 **x 2** 計算。
*   **防守方總和 (Def_Total)**:
    *   `力量` + `速度` + `彈跳` + `手感` + `出手速度` + `防守智商` + `運氣` + `身高` + `卡位` + `干擾` + `抄截` + `跑位` (共 12 項)。

#### B. 技巧加成 (Skill Bonus) [New v2.2]
針對出手者個人能力進行額外修正，使高數值射手更具優勢。
*   **公式**: `Skill_Bonus = 1 + (出手者.shot_accuracy + 出手者.shot_range + 出手者.off_move) / 800`
*   *說明*: 三項屬性滿值 (99+99+99) 約提供 1.37 倍率；屬性和 100 約提供 1.12 倍率。

#### C. 最終計算公式
*   **對抗修正**: `Diff_Mod = (Off_Total - Def_Total) / Def_Total`
*   **命中率**: `(基礎命中率 + Diff_Mod) * Skill_Bonus * (1 + 空間加成*0.1) * (1 + 品質加成)`。
*   **結算**: 骰 `0.0 ~ 1.0` <= 命中率 -> **投籃命中**。

### 5.3 犯規判定 (Foul Check)
無論是否命中，皆需進行犯規檢定。

*   **公式**: `犯規率 = (進攻方 IQ總和 - 防守方 IQ總和) / 防守方 IQ總和`。
*   **結算**: 骰 `0.0 ~ 1.0` <= 犯規率 -> **觸發犯規**。
*   **結果**:
    *   **進球 + 犯規**: And-1 (加罰 1 球)。
    *   **沒進 + 犯規**: 罰球 (依據 5.1 判定罰 2 球或 3 球)。
    *   **沒進 + 沒犯**: 進入籃板判定 (5.4)。
    *   **進球 + 沒犯**: 進入助攻判定 (5.5)。
*   **罰球命中率公式**:
    *   `隨機基數`: 在 **40% ~ 95%** 之間隨機產生一個浮點數。
    *   `屬性加成`: `(罰球者運氣 + 罰球者手感) * 0.01`。
        *   *註: 兩項屬性相加 100 點約提供 +1% 修正。*
        *   *註2: 如果是快攻發生罰球，則罰球者=快攻執行者，若非則罰球者則為團隊總合計算。*
    *   `最終罰球率` = `隨機基數 + 屬性加成`。

### 5.4 籃板判定 (Rebound) **[New v2.1 增加身高加成修正]**
若投籃未中且未犯規，進行籃板爭奪。

#### A. 屬性池定義
*   **進攻方 (Off_Reb_Stat)**: `進攻智商` + `籃板` + `卡位` + `身高`。
*   **防守方 (Def_Reb_Stat)**: `防守智商` + `籃板` + `卡位` + `身高`。

#### B. 防守籃板機率 (Def_Reb_Rate)
*   **公式**: `10% + Def_Reb_Stat / (Off_Reb_Stat + Def_Reb_Stat)`。
*   *說明*: 基礎 10% 優勢 + 雙方屬性佔比。防守方通常佔優。

#### C. 結算
*   骰 `0.0 ~ 1.0` <= 防守籃板機率 -> **防守籃板** (攻守交換)。
*   骰 `0.0 ~ 1.0` > 防守籃板機率 -> **進攻籃板** (進攻方重置時間為 14秒，繼續進攻)。

### 5.5 助攻判定 (Assist) - *僅進球後計算*
*   **A. 助攻發生判定**:
    *   **團隊屬性**: `Team_Stat` = 進攻方 5 人 (`進攻智商`+`控球`+`傳球`+`跑位`) 總和。
    *   **機率**: `(Team_Stat / 助攻係數) * 0.01` (助攻係數 = 1 / 團隊5人幸運總和)。
    *   若判定通過，則該次得分記為助攻。
*   **B. 助攻者分配**:
    *   **權重**: 場上隊友的 (`控球` + `傳球`) 數值。
    *   **分配**: 依權重比例隨機分配給其中一人 ((`控球` + `傳球`) 越高者 機率較高)。

## 6. 數據歸屬判定 (Data Attribution)
當比賽引擎產生事件（如得分、籃板、失誤）時，系統需依據以下規則將數據分配給特定球員。

### 6.1 投籃出手與得分 (FGA, FGM, PTS, 3PA, 3PM)
*   觸發時機: 進入 Spec 5.1 投籃類型判定之前。
*   候選人: 進攻方場上 5 人。
*   權重計算 (Weight):
*   基礎權重: 引用 Spec 5.2.A 之 Off_Total 屬性池 (共13項屬性總和)。
*   特殊加成:
    *   若判定為 3分球回合: 出手速度、射程、跑位 數值 x 2。
    *   若判定為 2分球回合: 無額外屬性加成。
*   戰術加成:
    *   角色為 Star: 最終權重 x 1.5。
    *   角色為 Starter: 最終權重 x 1.2。
*   分配邏輯:
    *   計算場上 5 人權重總和。
    *   計算每人權重佔比 (Weight / Total)。
    *   產生隨機數 R (0.0 ~ 1.0)。
    *   由權重佔比最小的球員開始依次判定，若 R 落在其區間內則選中。
*   結算:
    *   選中者為 出手者 (Shooter)。
    *   若命中: 獲得 PTS, FGM, (3PM)。
    *   無論命中與否: 獲得 FGA, (3PA)。
### 6.2 罰球 (FTA, FTM)
*   觸發時機: Spec 3.5 (快攻犯規) 或 Spec 5.3 (投籃犯規)。
*   歸屬邏輯:
    *   快攻 (Fastbreak): 歸屬於 快攻執行者 (Runner)。
    *   陣地戰 (Set Play): 歸屬於 出手者 (Shooter)。
*   結算: 執行罰球獲得 FTA，罰進獲得 FTM 與 PTS。
### 6.3 籃板球 (REB, OR, DR)
*   觸發時機: Spec 5.4 判定投籃不進且無犯規。
*   候選人:
    *   防守籃板 (DR): 防守方場上 5 人。
    *   進攻籃板 (OR): 進攻方場上 5 人。
    *   權重計算 (Weight):
    *   通用屬性: 力量 + 速度 + 跑位。
    *   加權屬性: 身高 (*1.5) + 彈跳 (*1.5) + 籃板 (*1.5) + 卡位 (*1.5)。
    *   智商屬性: 若為 DR 則加 防守智商；若為 OR 則加 進攻智商。
*   分配邏輯:
    *   計算 5 人權重佔比。
    *   產生隨機數 R (0.0 ~ 1.0)。
    *   由權重佔比最小的球員開始依次判定 (同投籃邏輯)。
### 6.4 助攻 (AST)
*   觸發時機: Spec 5.5 判定「助攻發生」且投籃命中。
*   候選人: 進攻方場上 5 人 (排除出手者)。
*   權重計算 (Weight):
    *   AST_Weight = 控球 + 傳球 + 進攻智商。
*   分配邏輯:
    *   計算候選人權重佔比。
    *   產生隨機數 R (0.0 ~ 1.0)。
    *   固定判定順序: 依序檢查 C -> PF -> SF -> SG -> PG 的累積機率區間。
        說明: 此順序確保在浮點數邊界或同權重下，PG 擁有最後的判定優勢 (通常機率區間最大)。
### 6.5 抄截 (STL)
*   觸發時機: Spec 3.4 (後場) 或 Spec 4.4 (前場) 判定成功。
*   候選人: 防守方場上 5 人。
*   權重計算:
    *   STL_Weight = 抄截 + 防守智商 + 速度 + 干擾。
*   分配邏輯: 計算權重佔比後隨機分配。
### 6.6 封蓋 (BLK)
*   觸發時機: Spec 4.3 判定「封蓋成功」。
*   歸屬邏輯: 直接對位分配。
    *   判定 出手者 (Shooter) 的位置 (例如 PG)。
    *   歸屬於防守方 相同位置 的球員 (防守方的 PG)。
### 6.7 失誤 (TOV)
*   A. 被抄截 (Stolen):
    *   觸發: 發生 STL 事件。
    *   歸屬: 抄截者 (Defender) 的 對位進攻球員 (例如 Defender PG 抄截 -> Offender PG 失誤)。
*   B. 8秒/24秒違例 (Violation):
    *   歸屬: 團隊失誤 (Team TOV)。
    *   說明: 此類失誤計入球隊總失誤數，但不計入任何球員的個人數據。

## 7. 輸出數據定義 (Output Data Definition) [New v1.8]
比賽引擎執行完畢後，將回傳以下結構化數據。

### 7.1 比賽結果摘要 (Match Result)
*   **資料來源**：`MatchEngine.simulate()` 回傳之 `MatchResult` 物件。

| 欄位名稱 (Field) | 類型 | 說明 (Description) | 範例 / 備註 |
| :--- | :---: | :--- | :--- |
| `game_id` | `str` | **比賽識別碼** | "SIM_GAME_001" |
| `home_team_id` | `str` | **主隊 ID** | |
| `away_team_id` | `str` | **客隊 ID** | |
| `home_score` | `int` | **主隊最終得分** | |
| `away_score` | `int` | **客隊最終得分** | |
| `is_ot` | `bool` | **是否延長** | `True` 表示有進行 OT |
| `total_quarters` | `int` | **總節數** | 4 (正規賽), >4 (含延長賽) |
| `pbp_log` | `List` | **文字轉播紀錄** | 逐行紀錄比賽事件字串 |

### 7.2 球員統計數據 (Player Statistics / Box Score)
*   **資料來源**：需遍歷賽後 `EngineTeam.roster` 中的 `EnginePlayer` 物件取得。

| 分類 (Category) | 欄位代號 (Key) | 名稱 (Label) | 說明與備註 (Notes) |
| :--- | :--- | :--- | :--- |
| **基礎數據** | `stat_pts` | **得分** (PTS) | 球員總得分 |
| | `stat_reb` | **總籃板** (REB) | 進攻籃板 + 防守籃板 |
| | `stat_ast` | **助攻** (AST) | |
| | `stat_stl` | **抄截** (STL) | |
| | `stat_blk` | **阻攻** (BLK) | |
| | `stat_tov` | **個人失誤** (TOV) | 僅包含個人責任失誤 (如被抄截、傳球出界) |
| | `fouls` | **犯規** (PF) | 累計達 6 次即犯滿離場 |
| **投籃數據** | `stat_fgm` | **投籃命中** (FGM) | 包含 2 分球與 3 分球 |
| | `stat_fga` | **投籃出手** (FGA) | 包含 2 分球與 3 分球 |
| | `stat_3pm` | **三分命中** (3PM) | |
| | `stat_3pa` | **三分出手** (3PA) | |
| | `stat_ftm` | **罰球命中** (FTM) | |
| | `stat_fta` | **罰球出手** (FTA) | |
| **進階/狀態** | `stat_orb` | **進攻籃板** (ORB) | |
| | `stat_drb` | **防守籃板** (DRB) | |
| | `seconds_played` | **上場時間** (SEC) | 單位：**秒** (顯示時需除以 60 換算為分鐘) |
| | `current_stamina` | **剩餘體力** | 賽後剩餘數值 (0.0 ~ 100.0) |
| | `is_fouled_out` | **犯滿狀態** | `True` 表示該場比賽已犯滿離場 |

### 7.3 團隊統計數據 (Team Statistics)
*   **資料來源**：賽後 `EngineTeam` 物件。

| 欄位代號 (Key) | 名稱 (Label) | 說明與備註 (Notes) |
| :--- | :--- | :--- |
| `score` | **團隊總分** | 隊伍最終得分 |
| `stat_tov` | **團隊失誤** | **非個人歸屬失誤** (如 8秒/24秒違例)<br>註：球隊總失誤數 = `Team.stat_tov` + `Sum(Player.stat_tov)` |

============================================================

File: ASBL_Player_System_Specification.md
------------------------------------------------------------
# ASBL 籃球遊戲球員系統規格書 (v3.3)

**版本**：3.3
**文件類型**：核心邏輯規格 (Core Logic Specification)
**狀態**：已定案 (Confirmed)
**最後更新**：2025-12-28
**變更記錄**：
*   **v1.0 (2025-12-03)**：初始版本，定義生成、成長、老化邏輯。
*   **v2.0 (2025-12-03)**：
    *   **移除**：體重 (Weight) 生成系統。
    *   **修改**：可訓練能力生成邏輯，由「壓縮機制」改為「重骰機制 (Reroll)」，允許極端偏科數值出現。
*   **v2.1 (2025-12-03)**：
    *   **修正**：移除薪資公式中的 `* 100` 倍率。
    *   **格式**：將數學公式改為純文字格式以便閱讀。
*   **v2.2 (2025-12-03)**：
    *   **修改**：姓名生成邏輯，針對「姓氏」設定長度機率 (80/15/5)。
    *   **新增**：定義開隊陣容檢核標準 (C>=2, PG>=2, G>=4, F>=4)。
*   **v2.4 (2025-12-04)**：
    *   **新增**：球員初始年齡生成規則 (SSR 固定 18 歲，隨等級下降範圍擴大)。
    *   **新增**：初始合約規則 (年限與角色定位與等級掛鉤)。
*   **v2.5 (2025-12-04)**：
    *   **新增**：第 6 章「上場時間分配系統 (Minutes Distribution System)」。
    *   **定義**：各角色定位 (Role) 的保底時間與權重浮動範圍。
    *   **演算法**：定義基於權重的動態時間分配公式。
*   **v2.6 (2025-12-11)**：
    *   **新增**：球員屬性的欄位定義。
    *   **用途**：確保後續設計程式時能保持一致性。
*   **v3.1 (2025-12-22)**：
    *   **重構**：重新定義球員生成流程順序 (姓名 -> 等級 -> 天賦 -> 身高 -> 位置 -> 能力 -> 年齡)。
    *   **恢復**：加回 `2.3.1` 天賦 (Untrainable) 的詳細數值區間定義 (Sum/Stat Range)。
    *   **新增**：`2.4.2` 可訓練能力 (Trainable) 的 **位置檢核機制 (Position Validation)**。
    *   **新增**：`2.4.3` 可訓練能力 (Trainable) 的 **身高修正機制 (Height Modifier)**，包含補償 (Bonus) 與懲罰 (Penalty) 邏輯。
*   **v3.2 (2025-12-24)**：
    *   **新增**：`5.4` 開隊球員特殊生成規則 (Initial Roster Rules)，定義僅在開隊時套用 **50% 能力下限**，以縮小初始隨機範圍。
*   **v3.3 (2025-12-28)**：
    *   **新增**：`5.2` 位置檢核條件新增高階位置覆蓋。

---

## 1. 系統概述
本文件定義了 ASBL (Advanced Simulation Basketball League) 中球員生成、能力值分配、成長與老化機制的核心邏輯。設計目標是創造一個具備高度策略性、隨機性與經營深度的籃球模擬環境。

---

## 2. 球員生成系統 (Player Generation)

### 2.0 球員生成流程 (Player Generation Workflow)
本章節描述單一球員生成的標準作業程序 (SOP)，程式實作需嚴格遵守此順序，因為後續步驟依賴前序步驟的產出。

**執行順序**：
1.  **決定姓名** (Name)
2.  **決定等級** (Grade)
3.  **生成天賦** (Untrainable Stats - 依據等級)
4.  **決定身高** (Height)
5.  **決定位置** (Position - 依據身高)
6.  **生成能力** (Trainable Stats - 依據等級、位置、身高)
7.  **生成年齡** (Age - 依據等級)

---

### 2.1 姓名生成 (Name Generation)
*   **資料來源**：`NameLibrary` 資料庫 (分為 `last` 姓氏庫 與 `first` 名字庫)。
*   **生成流程**：
    1.  隨機抽取一個 **姓氏 (Last Name)**。
        *   **80%**：單字 (如：林)      **(v2.2 更新)**
        *   **15%**：雙字 (如：歐陽)    **(v2.2 更新)**
        *   **5%**：長字 (3字以上)      **(v2.2 更新)**
    2.  隨機抽取一個 **名字 (First Name)**。
    3.  組合為 `FullName`。
*   **補字邏輯 (Add Character Logic)**：
    *   **觸發條件**：
        1.  `FullName` 總長度 $\le 2$ (如：林豪)。
        2.  `Last` 長度 $> 1$ 且 `First` 長度 $= 1$ (如：歐陽鋒)。
    *   **機率**：符合上述任一條件時，**50% 機率** 觸發補字。
    *   **執行補字**：
        *   從 `first` 庫中再抽取一個字。
        *   **防呆檢查**：若抽到的字長度 $> 1$ (如抽到「志豪」)，則**強制取消補字**，維持原名 (避免出現「歐陽鋒志豪」)。
        *   若抽到的字長度 $= 1$，則追加至名字後方。
    *   **例外處理 1.**：外國譯名通常長度已 $> 2$ 且不符合複姓單名規則，故不觸發補字。
    *   **例外處理 2.**：補字時從名字庫再抽一字，若抽到多字詞則取消補字。

---

### 2.2 等級與天賦生成 (Grade & Untrainable Stats)

#### 2.2.1 決定等級
*   **機率分佈**：
    *   **G**: 28% | **C**: 26% | **B**: 22% | **A**: 14%
    *   **S**: 7% | **SS**: 2.5% | **SSR**: 0.5%

#### 2.2.2 生成不可訓練能力 (Untrainable Stats)
*   **定義**：代表球員的天賦，生成後無法透過訓練提升。
*   **項目 (10項)**：`體力`, `力量`, `速度`, `彈跳`, `手感`, `出手速度`, `進攻智商`, `防守智商`, `健康`, `運氣`。
*   **生成規則**：依據等級設定的「總和範圍」與「單項範圍」進行隨機生成。

**(V2.6 新增)**

| 中文名稱 | Config Key (YAML) | DB Field (Storage) | 備註說明 |
| :--- | :--- | :--- | :--- |
| **體力** | `ath_stamina` | `physical.stamina` | 影響體力以及比賽中能力變化 |
| **力量** | `ath_strength` | `physical.strength` | 基本運動能力，影響比賽表現 |
| **速度** | `ath_speed` | `physical.speed` | 基本運動能力，影響比賽表現 |
| **彈跳** | `ath_jump` | `physical.jumping` | 基本運動能力，影響比賽表現 |
| **健康** | `talent_health` | `physical.health` | 影響受傷機率與體力恢復加成 (隱藏數值) |
| **手感** | `shot_touch` | `offense.touch` | 影響投籃命中判定 |
| **出手速度** | `shot_release` | `offense.release` | 影響投籃命中判定 |
| **進攻智商** | `talent_offiq` | `mental.off_iq` | 影響投籃命中判定與進攻事件 |
| **防守智商** | `talent_defiq` | `mental.def_iq` | 影響投籃命中判定與防守事件 |
| **運氣** | `talent_luck` | `mental.luck` | 影響所有機率事件的微幅修正 (隱藏數值) |

| 等級 | 總和下限 (Sum Min) | 總和上限 (Sum Max) | 單項下限 (Stat Min) | 單項上限 (Stat Max) |
| :--- | :--- | :--- | :--- | :--- |
| **G** | 10 | 400 | 1 | 99 |
| **C** | 399 | 600 | 1 | 99 |
| **B** | 599 | 700 | 1 | 99 |
| **A** | 699 | 800 | 10 | 99 |
| **S** | 799 | 900 | 20 | 99 |
| **SS** | 900 | 950 | 30 | 99 |
| **SSR**| 951 | 990 | 91 | 99 |

---

### 2.3 身高與位置 (Height & Position)
*   **2.3.1 身高生成**：
    *   演算法：Box-Muller Transform (常態分佈)。
    *   參數：平均值 (Mean) **195cm**，標準差 (SD) **10**。
    *   範圍限制：**160cm ~ 230cm** (超出範圍需重骰)。
*   **2.3.2 位置判定**：由身高決定機率分佈 (非絕對切斷)。
    *   **< 190cm**：PG (60%), SG (40%)
    *   **190-199cm**：PG (35%), SG (45%), SF (20%)
    *   **200-209cm**：PF (50%), C (15%), SF (20%), SG (10%), PG (5%)
    *   **>= 210cm**：C (45%), PF (30%), SF (10%), SG (10%), PG (5%)

---

### 2.4 可訓練能力生成 (Trainable Stats Generation)
此步驟為生成流程中最複雜的環節，需綜合考量等級上限、位置檢核與身高修正。

*   **項目 (10項)**：`投籃技巧`, `射程`, `籃板`, `卡位`, `干擾`, `抄截`, `跑位`, `運球`, `傳球`, `控球`。

**(V2.6 新增)**

| 中文名稱 | Config Key (YAML) | DB Field (Storage) | 備註說明 |
| :--- | :--- | :--- | :--- |
| **投籃技巧** | `shot_accuracy` | `offense.accuracy` | 影響投籃命中判定 |
| **射程** | `shot_range` | `offense.range` | 影響投籃命中判定 |
| **傳球** | `off_pass` | `offense.passing` | 影響進攻事件 |
| **運球** | `off_dribble` | `offense.dribble` | 影響進攻事件 |
| **控球** | `off_handle` | `offense.handle` | 影響進攻事件 |
| **跑位** | `off_move` | `offense.move` | 影響進攻事件及防守事件 |
| **籃板** | `def_rebound` | `defense.rebound` | 影響籃板事件 |
| **卡位** | `def_boxout` | `defense.boxout` | 影響籃板事件 |
| **干擾** | `def_contest` | `defense.contest` | 影響防守事件 |
| **抄截** | `def_disrupt` | `defense.disrupt` | 影響防守事件 |

#### 2.4.1 基礎生成規則 (Base Logic)
1.  **隨機生成**：每項能力在 **1~99** 之間隨機生成。
2.  **反向總上限限制 (Reverse Cap)**：
    *   **設計意圖**：低等級球員 (G) 擁有較高的初始能力上限，代表「即戰力」；高等級球員 (SSR) 初始能力受限，代表需培養的「璞玉」。 (**v3.2 補充**)
    *   **G**: 800 | **C**: 700 | **B**: 650 | **A**: 600 | **S/SS/SSR**: 550
    *   *邏輯*：若總和 > 上限，則視為無效，觸發 **Reroll**。

#### 2.4.2 位置檢核機制 (Position Validation)
在基礎生成符合「反向總上限」後，需額外檢查數值分佈是否符合「位置特徵」。若不符合，視為無效，觸發 **Reroll**。

*   **C / PF (內線)**：
    *   條件：`(籃板 + 卡位 + 干擾) > (其他 7 項總和)`
*   **SG (得分後衛)**：
    *   條件：`(干擾 + 抄截 + 射程) > (其他 7 項總和)`
*   **PG (控球後衛)**：
    *   條件：`(抄截 + 運球 + 控球 + 傳球) > (其他 6 項總和)`
*   **SF (小前鋒)**：
    *   條件：無限制 (No Restriction)

#### 2.4.3 身高修正機制 (Height Modifiers)
依據身高區間，對生成結果進行「次數擇優/擇差」與「數值加成」。

| 身高區間 (cm) | 生成次數 (Trials) | 選擇邏輯 | 額外修正 (Bonus/Penalty) |
| :--- | :--- | :--- | :--- |
| **160 ~ 169** | **3 次** | 取**最高**總分者 | 全能力總和 **+30** (權重分配*) |
| **170 ~ 179** | **2 次** | 取**最高**總分者 | 全能力總和 **+20** (權重分配*) |
| **180 ~ 189** | **1 次** | N/A | 全能力 **+1** (總和 +10) |
| **190 ~ 209** | **1 次** | N/A | 無修正 |
| **210 ~ 219** | **2 次** | 取**最低**總分者 | 無修正 |
| **220 ~ 230** | **3 次** | 取**最低**總分者 | 無修正 |

*   **權重分配規則 (Weighted Distribution)**：
    *   針對 160-179cm 的額外加點 (+20/+30)，採隨機分配至 10 個項目。
    *   **限制**：分配時，PG 關鍵四項 (`抄截`, `運球`, `控球`, `傳球`) 獲得點數的機率/權重需 **大於** 其他 6 項。
*   **有效性判定**：上述「生成次數」中的每一次嘗試，都必須先通過 **2.4.1 (上限)** 與 **2.4.2 (位置)** 的檢核才算一次有效嘗試。

---

### 2.5 年齡生成 (Age Generation) **(v2.4 新增)**
*   **基礎規則**：SSR 級固定為 18 歲，每降一級，年齡浮動範圍 (Range) 增加 1 歲。
*   **公式**：`Age = 18 + Random(0, Grade_Offset)`
*   **各級對照**：
    *   **SSR**: 18 歲 (固定)
    *   **SS**: 18 ~ 19 歲
    *   **S**: 18 ~ 20 歲
    *   **A**: 18 ~ 21 歲
    *   **B**: 18 ~ 22 歲
    *   **C**: 18 ~ 23 歲
    *   **G**: 18 ~ 24 歲

---

## 3. 成長與老化系統 (Growth & Aging)

### 3.1 基礎參數
*   **賽季設定**：1 賽季 = **91 天** (70 場比賽)。
*   **初始年齡**：18 歲。
*   **體能極限**：單場上場時間上限約 **37 分鐘**。

### 3.2 成長期 (18 - 25 歲)
*   **機制**：累積上場時間換取訓練點數。
*   **公式**：每累積 48 分鐘 -> 獲得 1 點。
*   **幸運修正 (Luck Modifier)**：
    *   基準值：Luck 80。
    *   修正公式：實際獲得 = 基礎點數 * [1 + (Luck - 80) * 1%]。
    *   *效果：Luck 99 的球員成長速度快 19%。*

### 3.3 巔峰期 (26 - 29 歲)
*   **機制**：成長速度放緩。
*   **公式**：每累積 144 分鐘 -> 獲得 1 點。
*   **幸運修正**：同上。

### 3.4 退化期 (30 歲以上)
*   **機制**：非線性加速老化，包含「上場磨損」與「歲月流逝」。
*   **抗性系統 (Resilience)**：
    *   **幸運抗性**：[(Luck - 70) * 1%] (若 Luck < 70 則為 0)。
    *   **等級抗性**：A (1%), S (3%), SS (5%), SSR (10%)。
    *   **總抗性** = 幸運抗性 + 等級抗性。
*   **掉點公式 (負成長)**：
    1.  **上場磨損**：滿 [300 / MAX(1, Age-29)] 分鐘 -> 扣 1 點。
        *   *隨著年齡增加，分母變小，掉點門檻降低。*
    2.  **歲月流逝**：每 [10 - (Age-30)] 天 -> 扣 1 點。
        *   *隨著年齡增加，天數變少，掉點頻率變高。*
    3.  **抗性應用**：上述兩種扣點計算出的數值，扣點數 * (1 - 總抗性)。
*   **練球補償**：滿 [150 * (Age-29)] 分鐘 -> 補 1 點。

---

## 4. 經濟與其他 (Economy & Misc)

### 4.1.1 薪資計算 (Salary)
*   **公式**：所有能力總和 * 等級係數。**(v2.1 更新)**
*   **等級係數**：
    *   G: 1.0
    *   C: 1.1
    *   B: 1.3
    *   A: 1.6
    *   S: 2.0
    *   SS: 2.5
    *   SSR: 3.0

### 4.1.2 初始合約規則 (Initial Contract) **(v2.4 新增)**
球員生成時，依據等級自動賦予初始合約年限與角色定位。

|  等 級  | 合約年限  |  角色定位 (Role)    | 說明                                |
| :---    | :---     | :---               | :---                                |
| **SSR** | **4 季** | **明星 (Star)**     | 絕對核心，享有最高薪資加成與上場時間。 |
| **SS**  | **4 季** | **先發 (Starter)**  | 球隊主力。                           |
| **S**   | **4 季** | **先發 (Starter)**  | 球隊主力。                           |
| **A**   | **2 季** | **綠葉 (Rotation)** | 主要輪替球員。                       |
| **B**   | **2 季** | **綠葉 (Rotation)** | 主要輪替球員。                       |
| **C**   | **1 季** | **功能 (Role)**     | 功能性球員，特定戰術使用。            |
| **G**   | **1 季** | **板凳 (Bench)**    | 邊緣球員/陪練，填補名單使用。         |

### 4.2 點數分配
*   **分配方式**：**手動分配 (Manual)**。
*   **儲存**：球員獲得的訓練點數存入 `training_points` 欄位，由玩家決定加到哪一項可訓練能力上。

### 4.3 體重 (Weight)
*   **(v2.0 已移除)**
*   **(v1.0 公式 - 已移除)**：~~$(\text{Height} - 100) \times 0.9 + \text{Random}(-5, 5)$。~~

## 5. 開隊陣容檢核 (Team Creation Validation) **(v2.2 新增、v3.2 更新)**

### 5.1 執行邏輯
生成 15 人名單 -> 檢查「位置數量」與「等級數量」 -> 若任一條件不符合，則整隊重骰 (Reroll Team)。

### 5.2 位置檢核條件
1.  **C**  >= 2
2.  **PG** >= 2
3.  **PG + SG** >= 4
4.  **PF + SF** >= 4
5.  **高階位置覆蓋 (High-Tier Coverage) [New v3.3]**:
    *   範圍：**SSR (1人) + SS (2人) + S (2人)**，共 5 名球員。
    *   條件：上述 5 名球員的組合中，必須包含 **C, PF, SF, SG, PG** 五個位置各至少 1 名。
    *   *目的：確保玩家的高階核心陣容是完整的，避免開局神卡位置嚴重重疊。*

### 5.3 等級檢核條件 (強制分佈)
*   **SSR**: 1 人
*   **SS**: 2 人
*   **S**: 2 人
*   **A**: 2 人
*   **B**: 2 人
*   **C**: 2 人
*   **G**: 4 人

### 5.4 開隊球員特殊生成規則 (Initial Roster Stat Constraints) **(v3.3 新增)**
為了縮小開局隨機範圍，避免玩家初始隊伍中出現過多無法使用的球員，**僅在開隊生成階段**套用以下規則：

*   **啟用下限限制 (Enable Lower Bound)**：
    *   在執行 `2.4.1` 基礎生成時，額外增加下限檢查。
    *   **條件**：`可訓練能力總和` >= `上限 (Upper Cap) * 50%`。
    *   **參數**：`initial_team_min_ratio` = **0.5** (可於 YAML 配置)。

| 等級 | 開隊時下限 (Min) | 開隊時上限 (Max) | 說明 |
| :--- | :--- | :--- | :--- |
| **G** | **400** | 800 | 確保開隊 G 級球員至少有基礎戰力 |
| **C** | **350** | 700 | |
| **B** | **325** | 650 | |
| **A** | **300** | 600 | |
| **S/SS/SSR** | **275** | 550 | |

*   **注意**：此規則不適用於遊戲開始後的選秀或自由球員生成。
    
---

## 6. 上場時間分配系統 (Minutes Distribution System) **(v2.5 新增)**

### 6.1 系統概述
比賽模擬時，系統需將 **240 分鐘** (48分鐘 x 5人) 分配給登錄名單中的球員。分配機制採用 **「保底時間 + 權重浮動」** 演算法，確保核心球員地位，同時保留單場比賽的隨機性與調度彈性。

### 6.2 角色參數設定
不同合約角色擁有不同的「保底時間 (Base)」與「權重範圍 (Weight Range)」。

| 角色定位 (Role) | 保底時間 (Base) | 權重範圍 (Weight) | 說明 |
| :--- | :--- | :--- | :--- |
| **明星 (Star)** | **30 min** | **-1 ~ 5** | 絕對主力，波動極小，極低機率扣時。 |
| **先發 (Starter)** | **20 min** | **-2 ~ 7** | 主力球員，有較高機率獲得額外時間。 |
| **綠葉 (Rotation)**| **10 min** | **5 ~ 15** | 輪替核心，主要競爭剩餘時間的族群。 |
| **功能 (Role)** | **0 min** | **5 ~ 12** | 無保底，需靠權重爭取上場。 |
| **板凳 (Bench)** | **0 min** | **0 ~ 10** | 邊緣人，權重範圍大，可能 DNP 也可能爆發。 |

### 6.3 分配演算法 (Algorithm)

#### 步驟 1：計算總保底與剩餘時間
*   `Total_Base` = 所有球員保底時間總和。
*   `Remaining_Time` = 240 - `Total_Base`。

#### 步驟 2：生成單場權重
*   為每位球員隨機生成一個權重值 `W` (介於該角色的 Min ~ Max 之間)。
*   `Total_Weight` = 所有球員權重總和。

#### 步驟 3：計算單位時間價值 (Unit Value)
*   `Unit` = `Remaining_Time` / `Total_Weight`。

#### 步驟 4：計算個人時間
*   `Raw_Minutes` = `Base` + (`W` * `Unit`)。
*   **捨去規則**：取至小數點後第一位，第二位以後無條件捨去 (Floor)。
    *   公式：`Final_Minutes = floor(Raw_Minutes * 10) / 10`。

#### 步驟 5：尾數修正
*   由於捨去規則，分配後的總時間通常會略小於 240 分鐘。
*   **修正方式**：將剩餘的尾數 (通常 < 1 分鐘) 全部加給名單中的 **最後一位球員**。

### 6.4 範例模擬
假設剩餘時間 130 分鐘，總權重 65，則 `Unit = 2`。
*   **Star (W=-1)**: 30 + (-1 * 2) = **28 min**。
*   **Starter (W=7)**: 20 + (7 * 2) = **34 min** (手感火燙，上場時間超越明星)。
*   **Bench (W=0)**: 0 + (0 * 2) = **0 min** (DNP)。

============================================================

File: config\game_config.yaml
------------------------------------------------------------
# =============================================================================
# ASBL 遊戲核心設定檔 (Final Version - Commented)
# 對應規格書: 
#   - Player System Specification v3.2 (2025/12/24 Update for TeamCreator role)
#   - Match Engine Specification v2.1 (2025/12/28 Update)
# 路徑 config/game_config.yaml
# =============================================================================

system: # 系統設定
  season_days: 91 # 賽季天數
  games_per_season: 70 # 賽季比賽數

  # 新增：季後賽設定 (Playoff Configuration)
  playoff:
    series_length:
      round_1: 3  # 16強賽 (打滿3場)
      round_2: 3  # 8強賽 (打滿3場)
      round_3: 3  # 4強賽 (打滿3場)
      finals: 5   # 總冠軍賽 (打滿5場)
    
    # 用於程式邏輯判斷是否要強制打滿 (True=打滿, False=搶勝制)
    force_full_series: True 

# =============================================================================
# 1. 球員生成設定 (Player Generation)
# 對應規格書: Player System v3.2
# =============================================================================
generation:
  # [Spec v3.1 Section 2.2.1] 等級與機率
  grades: ["SSR", "SS", "S", "A", "B", "C", "G"]
  grade_weights: [0.005, 0.025, 0.07, 0.14, 0.22, 0.26, 0.28]
  
  # [Spec v3.1 Section 4.1.1] 薪資係數
  # 計算公式: 球員薪資 = (20項屬性總和) * 該等級係數
  # 用途: 決定球員身價，等級越高，每一點能力值換算的薪水越高
  salary_factors:
    SSR: 3.0
    SS: 2.5
    S: 2.0
    A: 1.6
    B: 1.3
    C: 1.1
    G: 1.0

  # [Spec v3.1 Section 2.5] 年齡生成規則
  # 用途: 決定新秀的初始年齡，SSR 最年輕(潛力最大)，G 級平均年齡較大
  age_rules:
    base: 18
    offsets: {SSR: 0, SS: 1, S: 2, A: 3, B: 4, C: 5, G: 6}

  # [Spec v3.1 Section 4.1.2] 初始合約規則
  # 用途: 生成球員時自動賦予的合約長度與角色定位
  contracts:
    SSR: {years: 4, role: "Star"}
    SS:  {years: 4, role: "Star"}
    S:   {years: 4, role: "Starter"}
    A:   {years: 2, role: "Rotation"}
    B:   {years: 2, role: "Rotation"}
    C:   {years: 1, role: "Role"}
    G:   {years: 1, role: "Bench"}

  # [Spec v3.1 Section 2.2.2 & 2.4] 屬性定義
  attributes:
    untrainable: ["ath_stamina", "ath_strength", "ath_speed", "ath_jump", "shot_touch", "shot_release", "talent_offiq", "talent_defiq", "talent_health", "talent_luck"]
    trainable: ["shot_accuracy", "shot_range", "def_rebound", "def_boxout", "def_contest", "def_disrupt", "off_move", "off_dribble", "off_pass", "off_handle"]

  # [Spec v3.1 Section 2.2.2] 天賦生成規則 (Untrainable)
  untrainable_rules:
    G:   {sum_min: 10,  sum_max: 400, stat_min: 1, stat_max: 99}
    C:   {sum_min: 399, sum_max: 600, stat_min: 1, stat_max: 99}
    B:   {sum_min: 599, sum_max: 700, stat_min: 1, stat_max: 99}
    A:   {sum_min: 699, sum_max: 800, stat_min: 10, stat_max: 99}
    S:   {sum_min: 799, sum_max: 900, stat_min: 20, stat_max: 99}
    SS:  {sum_min: 900, sum_max: 950, stat_min: 30, stat_max: 99}
    SSR: {sum_min: 951, sum_max: 990, stat_min: 91, stat_max: 99}

  # [Spec v3.1 Section 2.4.1] 技術反向總上限 (Trainable Caps)
  # 用途: 限制可訓練屬性的初始總和，等級越低上限越高(即戰力)，等級越高上限越低(需培養)
  trainable_caps:
    G: 800
    C: 700
    B: 650
    A: 600
    S: 550
    SS: 550
    SSR: 550

  # [Spec v3.1 Section 2.3.1] 身高生成參數 (New)
  # 用途: 定義 Box-Muller 演算法的參數，避免寫死在程式碼中
  height_distribution:
    mean: 195
    std_dev: 10
    min: 160
    max: 230

  # [Spec v3.1 Section 2.3.2] 位置判定矩陣 (New)
  # 用途: 定義不同身高區間的位置機率分佈
  # 邏輯: 程式會依序檢查 max_height，符合則使用該組權重
  position_matrix:
    - max_height: 189
      weights: {PG: 60, SG: 40}
    - max_height: 199
      weights: {PG: 35, SG: 45, SF: 20}
    - max_height: 209
      weights: {PF: 50, SF: 20, C: 15, SG: 10, PG: 5}
    - max_height: 999 # 210+ (Catch-all)
      weights: {C: 45, PF: 30, SF: 10, SG: 10, PG: 5}

  # [Spec v3.1 Section 2.4.2] 位置檢核機制 (Position Validation) [v3.1 new]
  # 用途: 確保生成的能力值分佈符合該位置的特徵，否則重骰
  position_validation:
    C:
      condition: "sum(def_rebound, def_boxout, def_contest) > sum(others)"
      others_count: 7
    PF:
      condition: "sum(def_rebound, def_boxout, def_contest) > sum(others)"
      others_count: 7
    SG:
      condition: "sum(def_contest, def_disrupt, shot_range) > sum(others)"
      others_count: 7
    PG:
      condition: "sum(def_disrupt, off_dribble, off_handle, off_pass) > sum(others)"
      others_count: 6
    SF:
      condition: "none" # 無限制

  # [Spec v3.1 Section 2.4.3] 身高修正機制 (Height Modifiers) [v3.1 new]
  # 用途: 根據身高區間調整生成次數與數值加成
  height_modifiers:
    "160-169":
      trials: 3
      selection: "max" # 取最高總分
      bonus_points: 30
      bonus_type: "weighted" # 權重分配 (PG 關鍵屬性權重較高)
      key_ratio_min: 0.5
      key_ratio_max: 1.0
    "170-179":
      trials: 2
      selection: "max"
      bonus_points: 20
      bonus_type: "weighted" # 權重分配 (PG 關鍵屬性權重較高)
      key_ratio_min: 0.5
      key_ratio_max: 1.0
    "180-189":
      trials: 1
      selection: "none"
      bonus_points: 10 # 全能力+1 = 總和+10
      bonus_type: "flat" # 平均分配 (+1 per stat)
    "190-209":
      trials: 1
      selection: "none"
      bonus_points: 0
      bonus_type: "none"
    "210-219":
      trials: 2
      selection: "min" # 取最低總分
      bonus_points: 0
      bonus_type: "none"
    "220-230":
      trials: 3
      selection: "min"
      bonus_points: 0
      bonus_type: "none"

  # [Spec v3.1 Section 2.4.3] 權重分配規則 (Weighted Distribution Keys) [v3.1 new]
  # 用途: 定義身高補償點數分配時，哪些屬性權重較高 (針對 PG 關鍵四項)
  weighted_bonus_keys:
    high_priority: ["def_disrupt", "off_dribble", "off_handle", "off_pass"]
    low_priority: ["shot_accuracy", "shot_range", "def_rebound", "def_boxout", "def_contest", "off_move"]

# =============================================================================
# 2. 團隊與時間設定 (Team & Minutes)
# 對應規格書: Player System v3.1 Section 5 & 6
# =============================================================================
team_creation:
  # [Spec v3.1 Section 5] 開隊陣容檢核標準
  composition_count: {SSR: 1, SS: 2, S: 2, A: 2, B: 2, C: 2, G: 4} # 總共 15 人
  validation:
    min_c: 2       # 最少中鋒數
    min_pg: 2      # 最少控衛數
    min_guards: 4  # PG+SG 總數下限
    min_forwards: 4 # SF+PF 總數下限
    
    # 新增: Spec 5.2 高階球員位置覆蓋規則
    # 程式邏輯: 檢查 team 中 grade 在 target_grades 的球員，其 position 集合是否包含 required_positions 的所有元素
    high_tier_coverage:
      enabled: True
      target_grades: ["SSR", "SS", "S"]
      required_positions: ["C", "PF", "SF", "SG", "PG"]

  # [Spec v3.2 Section 5.4] 開隊球員特殊生成規則 (New)
  # 用途: 僅在開隊時啟用能力下限限制，縮小隨機範圍
  initial_team_min_ratio: 0.5 # 下限 = 上限 * 50%

minutes_distribution:
  # [Spec v3.1 Section 6] 上場時間分配
  total_minutes: 240
  roles:
    Star:     {base: 30, min_w: -1, max_w: 5}
    Starter:  {base: 20, min_w: -2, max_w: 7}
    Rotation: {base: 10, min_w: 5,  max_w: 15}
    Role:     {base: 0,  min_w: 5,  max_w: 12}
    Bench:    {base: 0,  min_w: 0,  max_w: 10}

# =============================================================================
# 3. 比賽引擎設定 (Match Engine)
# 對應規格書: Match Engine Specification v1.4
# =============================================================================
match_engine:
  # === 全域設定 (General Rules) ===
  general:
    quarter_length: 720            # 每節比賽秒數 (12分鐘)
    ot_length: 300                 # 延長賽秒數 (5分鐘)
    
    # [Spec v1.5 New] 犯規與換人規則
    substitution:
      foul_limit: 6                # 犯滿離場次數
      stamina_threshold: 80.0      # 低於此體力觸發換人
      clutch_time_threshold: 120   # [Spec v2.1] 關鍵時刻定義 (最後2分鐘)
      
      # 犯滿離場後的時間重分配邏輯
      redistribution:
        method: "positional_top_k" # 邏輯名稱: 每個位置取前 K 名
        top_k: 3                   # 取前 3 名
        positions: ["C", "PF", "SF", "SG", "PG"] # 遍歷順序 (共 15 個 slot)
    
    # [Spec v2.1] 體力系統參數 (更新)
    stamina_recovery_halftime: 20.0 # 中場休息時間 (分鐘)
    stamina_recovery_quarter: 2.0   # 節間休息時間 (分鐘)
    stamina_nerf_threshold: 80     # 體力低於此數值開始，能力值會線性衰退
    stamina_min_multiplier: 0.21   # 體力耗盡(剩1)時，能力值剩下的百分比 (21%)
    stamina_drain_coeff: 3.0       # 體力消耗公式的倍率係數 (數值越大消耗越快)

  # [Spec v2.1 Section 1.5] 賽前身高修正 (New)
  height_correction:
    bonus_threshold: 190 # BONUS_H
    nerf_threshold: 210  # NERF_H
    affected_attrs:
      speed_dribble:
        keys: ['ath_speed', 'off_dribble']
        coeff: 0.02
      handle_disrupt:
        keys: ['off_handle', 'def_disrupt']
        coeff: 0.01

  # [Spec v1.4 Section 2.3 & 2.4] 體力計算公式成分
  stamina_system:
    drain_attrs: ['ath_stamina', 'talent_health']   # 消耗公式: 3.0 * [1+(1-體能)] + (1-健康)
    recover_attrs: ['ath_stamina', 'talent_health'] # 恢復公式: 1.0 + 體能 - (1-健康)
    age_threshold: 20      # [New Spec v2.1]
    age_decay_rate: 0.01   # [New Spec v2.1]

  # [Spec 1.6 Section 1.5] 開場跳球設定 (New)
  jump_ball:
    # 參與者篩選公式: 身高 + 彈跳 + 進攻智商
    participant_formula: ['height', 'ath_jump', 'talent_offiq']
    # 獲勝機率計算: 依據數值總和比例 (無額外隨機係數，純看數值佔比)
    random_factor: 0.0 

  # [Spec v1.4 Section 1.1] 位置能力評分 (Positional Scoring)
  # 用途: 決定 Best 5 與 輪替順序，定義每個位置看重哪些屬性
  positional_scoring:
    C:  ['height', 'ath_strength', 'def_rebound', 'def_boxout', 'def_contest']
    PF: ['height', 'ath_strength', 'def_rebound', 'def_boxout', 'def_contest', 'ath_jump', 'ath_speed']
    SF: ['all_stats', 'height'] 
    SG: ['shot_touch', 'shot_release', 'talent_offiq', 'talent_defiq', 'def_contest', 'def_disrupt', 'shot_range']
    PG: ['ath_speed', 'talent_offiq', 'def_disrupt', 'off_dribble', 'off_pass', 'off_handle', '-height'] # 負號代表扣分

  # [Spec v1.4 Section 5.1.A] 屬性池定義
  # 用途: 定義「進攻總值」與「防守總值」包含哪些屬性
  attr_pools:
    off_14: ['ath_strength', 'ath_speed', 'ath_jump', 'shot_touch', 'shot_release', 'talent_offiq', 'talent_luck', 'shot_accuracy', 'shot_range', 'off_move', 'off_dribble', 'off_pass', 'off_handle', 'height']
    def_12: ['ath_strength', 'ath_speed', 'ath_jump', 'shot_touch', 'shot_release', 'talent_defiq', 'talent_luck', 'def_rebound', 'def_boxout', 'def_contest', 'def_disrupt', 'off_move'] # Def 移除 height (由公式獨立處理或屬性池不含), Spec 5.2.A Def_Total 包含 height, 這裡補上
    def_12_with_height: ['ath_strength', 'ath_speed', 'ath_jump', 'shot_touch', 'shot_release', 'talent_defiq', 'talent_luck', 'height', 'def_boxout', 'def_contest', 'def_disrupt', 'off_move']
    all_stats: [
      'ath_stamina', 'ath_strength', 'ath_speed', 'ath_jump', 
      'shot_touch', 'shot_release', 'talent_offiq', 'talent_defiq', 'talent_health', 'talent_luck',
      'shot_accuracy', 'shot_range', 'def_rebound', 'def_boxout', 'def_contest', 'def_disrupt', 
      'off_move', 'off_dribble', 'off_pass', 'off_handle', 'height'
    ]

  # === 後場階段 (Backcourt Phase) [Spec v1.4 Section 3] ===
  backcourt:
    params:
      time_base_min: 1.0         # 基礎過半場時間下限 (秒)
      time_base_max: 8.0         # 基礎過半場時間上限 (秒)
      time_coeff: 0.008          # 時間修正係數: (防守總值 - 進攻總值) * 0.008
      violation_threshold: 8.0   # 超過此秒數 -> 8秒違例 (失誤)
      steal_threshold: 3.0       # 超過此秒數 -> 觸發後場抄截判定
      fastbreak_threshold: 1.5   # 低於此秒數 -> 觸發快攻判定
      steal_base_prob: 0.01      # 後場抄截基礎機率 (1%)
      steal_bonus_coeff: 0.001   # 抄截機率加成: (防守差值) * 0.1%
      
      # [v2.3] 抄截轉換設定
      transition_base_prob: 0.50   # 基礎機率 50%

    formulas:
      # [Spec 3.1] 屬性池 (增加身高懲罰)
      off_sum: ['off_dribble', 'off_pass', 'talent_offiq', '-height']       # 決定過半場速度的進攻屬性
      def_sum: ['def_disrupt', 'def_contest', 'talent_defiq', '-height']    # 決定過半場阻礙的防守屬性
      # [Spec 3.4] 抄截判定 (Def - Off)
      steal_off: ['off_dribble', 'off_pass', 'talent_offiq', '-height']     # 被抄截者的抵抗屬性
      steal_def: ['def_disrupt', 'def_contest', 'talent_defiq', '-height']  # 抄截者的攻擊屬性
      # [v2.3] 轉換判定用的速度總和 (全隊)
      team_speed_sum: ['ath_speed']

    # [Spec v1.4 Section 3.5] 快攻判定
    fastbreak:
      params:
        base_success_min: 0.3    # 快攻基礎成功率下限 (30%)
        base_success_max: 1.0    # 快攻基礎成功率上限 (100%)
        stat_diff_coeff: 0.005   # 成功率修正: (屬性差) * 0.5%
        foul_base_prob: 0.01     # 快攻犯規基礎機率 (1%)
        foul_iq_coeff: 0.01      # 犯規智商修正: (IQ差) * 1%

      formulas:
        runner_selection: ['ath_speed', 'off_dribble']   # 決定誰跑快攻 (跑最快者)
        chaser_selection: ['ath_speed', 'talent_defiq']  # 決定誰追防 (追最快者)
        
        # [Spec 3.5.A] 快攻綜合能力 (9項 vs 9項)
        off_power: ['ath_strength', 'ath_speed', 'ath_jump', 'shot_touch', 'shot_release', 'talent_offiq', 'talent_luck', 'off_move', 'off_dribble', 'shot_accuracy']
        def_power: ['ath_strength', 'ath_speed', 'ath_jump', 'shot_touch', 'shot_release', 'talent_defiq', 'talent_luck', 'def_contest', 'def_disrupt']
        
        # [Spec 3.5.C] 犯規判定
        foul_off_iq: ['talent_offiq'] # 進攻方 IQ
        foul_def_iq: ['talent_defiq'] # 防守方 IQ

  # === 前場階段 (Frontcourt Phase) [Spec v1.4 Section 4] ===
  frontcourt:
    params:
      time_min_limit: 4.0        # 前場進攻時間下限 (最快4秒出手)
      time_quality_base: 7.0     # 品質基準秒數 (低於7秒開始有命中加成)
      spacing_bonus_coeff: 0.1   # 空間加成權重 (10%)
    
    formulas:
      # [Spec 4.1] 時間下限修正 (團隊屬性)
      time_reduction: ['ath_speed', 'talent_offiq', 'off_pass'] # 這些屬性越高，進攻時間下限越低
      
      # [Spec 4.2] 空間與跑位
      spacing_off: ['off_move', 'talent_offiq'] # 進攻方製造空間的屬性
      spacing_def: ['off_move', 'talent_defiq'] # 防守方壓縮空間的屬性

    # [Spec v1.4 Section 4.3] 封蓋判定
    block:
      params:
        base_prob: 0.01             # 基礎封蓋觸發率 (1%)
        spacing_penalty_prob: 0.05  # 當空間擁擠(<0)時，額外增加的封蓋率 (5%)
      formulas:
        # 階段一: 觸發 (能否摸到球)
        trigger_off: ['off_move']                    # 進攻跑位越高，越難被封蓋
        trigger_def: ['def_contest', 'talent_defiq'] # 防守干擾越高，越容易觸發封蓋
        # 階段二: 對抗 (Power Ratio - 硬碰硬)
        power_off: ['ath_strength', 'ath_jump', 'talent_offiq', 'height']
        power_def: ['ath_strength', 'ath_jump', 'def_contest', 'talent_defiq', 'height']

    # [Spec v1.4 Section 4.4] 前場抄截
    steal:
      params:
        base_prob: 0.01          # 基礎前場抄截率 (1%)
        stat_diff_coeff: 0.001   # 機率加成係數 (0.1%)
      formulas:
        off_attr: ['off_dribble', 'off_handle', 'off_pass', 'talent_offiq', '-height']      # 持球者的護球屬性
        def_attr: ['ath_speed', 'def_disrupt', 'talent_defiq', '-height']   # 防守者的抄截屬性

  # === 投籃與結算 (Shooting & Scoring) [Spec v2.1 Section 5] ===
  shooting:
    params:
      base_rate_2pt: 0.40         # [Spec 5.1] 兩分球基礎命中率 (40%) - v1.7
      base_rate_3pt: 0.20         # [Spec 5.1] 三分球基礎命中率 (20%) - v1.7
      spacing_weight: 0.1         # 空間加成係數 (公式中的 * 0.1)
      assist_prob_coeff: 0.1      # [Spec 5.5] 助攻機率係數 (公式中的 * 0.1)
      multiplier_3pt: 1.2         # [Spec 5.2.A] 3分球特殊加成倍率
      
      # [New] 技巧加成參數
      # 公式: * (1 + (屬性總和 / divisor))
      skill_bonus_divisor: 800.0 
    
    formulas:
      # [Spec 5.2.A] 命中率總和 (包含 height)
      off_total: 'off_14'         # 引用 attr_pools.off_14 (含 height)
      def_total: 'def_12_with_height' # 引用 attr_pools.def_12_with_height
      
      # [New] 技巧加成屬性池
      # 定義哪些屬性會影響基礎命中率的額外加成
      skill_bonus_attrs: ['shot_accuracy', 'shot_range', 'off_move']
      
      # 3分球特殊加成屬性 (這些屬性在3分判定時會 x multiplier_3pt)
      bonus_3pt_attrs: ['shot_accuracy', 'shot_range', 'off_move']
      
      # [Spec 5.2] 犯規判定 (IQ vs IQ)
      foul_off_iq: ['talent_offiq']
      foul_def_iq: ['talent_defiq']
      
      # [Spec 5.3] 三分球判定
      range_attr: ['shot_range']  # 射程越高，三分球機率越高

    # [Spec v1.4 Section 5.4] 籃板判定
    rebound:
      params:
        def_base_rate: 0.10       # 防守籃板基礎優勢 (10%)
      formulas:
        off_attr: ['talent_offiq', 'def_rebound', 'def_boxout', 'height'] # 進攻籃板屬性
        def_attr: ['talent_defiq', 'def_rebound', 'def_boxout', 'height'] # 防守籃板屬性

    # [Spec v1.4 Section 5.2 & 5.3] 罰球
    ft:
      params:
        base_min: 0.40            # 罰球基礎命中率下限
        base_max: 0.95            # 罰球基礎命中率上限
        attr_coeff: 0.0001        # 屬性修正係數 (100點屬性約 +1%)
      formulas:
        bonus_attrs: ['talent_luck', 'shot_touch'] # 罰球看運氣與手感

    # [Spec v1.4 Section 5.5] 助攻
    assist:
      formulas:
        team_stat: ['talent_offiq', 'off_handle', 'off_pass', 'off_move'] # 判定是否發生助攻的團隊屬性
        luck_stat: ['talent_luck']                                         # 影響助攻係數的運氣屬性
        distribution: ['off_handle', 'off_pass']                           # 用於決定是誰傳出助攻的權重

  # === 數據歸屬權重 (Data Attribution) [Spec v1.4 Section 6] ===
  attribution:
    params:
      shot_star_bonus: 1.5        # Star 球員出手權重加成 (1.5倍)
      shot_starter_bonus: 1.2     # Starter 球員出手權重加成 (1.2倍)
      rebound_height_weight: 1.5  # 身高/彈跳/籃板/卡位的加權倍率 (1.5倍)
    
    formulas:
      # [Spec 6.1] 投籃歸屬 (引用 Off_Total, 額外加成由程式邏輯判斷 3分/2分)
      shot_weight_base: 'off_13'  # 基礎出手權重看進攻總值
      shot_3pt_bonus: ['shot_release', 'shot_range', 'off_move'] # 若是三分球回合，這些屬性權重加倍

      # [Spec 6.3] 籃板歸屬
      rebound_base: ['ath_strength', 'ath_speed', 'off_move']    # 基礎權重
      rebound_bonus: ['ath_jump', 'def_rebound', 'def_boxout']   # 加權權重 (會乘上 height_weight)
      rebound_iq_off: ['talent_offiq']                           # 進攻籃板額外看 IQ
      rebound_iq_def: ['talent_defiq']                           # 防守籃板額外看 IQ

      # [Spec 6.4] 助攻歸屬
      assist_weight: ['off_handle', 'off_pass', 'talent_offiq']  # 誰最容易拿到助攻

      # [Spec 6.5] 抄截歸屬
      steal_weight: ['def_disrupt', 'talent_defiq', 'ath_speed', 'def_contest'] # 誰最容易拿到抄截

============================================================

File: app\services\player_generator.py
------------------------------------------------------------
# app/services/player_generator.py
import random
import math
import re
from sqlalchemy.sql.expression import func
from app import db
from app.models.player import Player, Contract
from app.models.system import NameLibrary
from app.utils.game_config_loader import GameConfigLoader

# ==========================================
# ASBL Player Generator Service
# Specification: v3.1 (Final Revised - Dynamic Validation)
# Environment: i9-14900k + 128G RAM
# Features: 
#   - Fully Configurable (Logic extracted from YAML)
#   - Cache on Startup (Rule Compilation)
#   - Stage-based Reroll
# ==========================================

class PlayerGenerator:
    
    # -------------------------------------------------------------------------
    # 靜態快取區 (Static Cache)
    # -------------------------------------------------------------------------
    _names_cache = {'last': [], 'first': []}
    _config_cache = {}
    _is_initialized = False

    # [Spec v2.6] 屬性映射表
    ATTR_MAPPING = {
        # Untrainable (天賦)
        "ath_stamina":   ("physical", "stamina"),
        "ath_strength":  ("physical", "strength"),
        "ath_speed":     ("physical", "speed"),
        "ath_jump":      ("physical", "jumping"),
        "talent_health": ("physical", "health"),
        "shot_touch":    ("offense", "touch"),
        "shot_release":  ("offense", "release"),
        "talent_offiq":  ("mental", "off_iq"),
        "talent_defiq":  ("mental", "def_iq"),
        "talent_luck":   ("mental", "luck"),
        # Trainable (技術)
        "shot_accuracy": ("offense", "accuracy"),
        "shot_range":    ("offense", "range"),
        "off_pass":      ("offense", "passing"),
        "off_dribble":   ("offense", "dribble"),
        "off_handle":    ("offense", "handle"),
        "off_move":      ("offense", "move"),
        "def_rebound":   ("defense", "rebound"),
        "def_boxout":    ("defense", "boxout"),
        "def_contest":   ("defense", "contest"),
        "def_disrupt":   ("defense", "disrupt")
    }

    @classmethod
    def initialize_class(cls):
        """
        [系統初始化]
        在伺服器啟動時呼叫，將資料與設定載入記憶體。
        包含將 YAML 字串規則編譯為 Python 物件的邏輯。
        """
        if cls._is_initialized:
            return

        print("[PlayerGenerator] Initializing cache for High Performance Mode...")

        # 1. 載入姓名庫
        lasts = db.session.query(NameLibrary.text).filter_by(category='last').yield_per(1000)
        firsts = db.session.query(NameLibrary.text).filter_by(category='first').yield_per(1000)
        
        cls._names_cache['last'] = [row.text for row in lasts]
        cls._names_cache['first'] = [row.text for row in firsts]

        # 2. 預載入 Config (基礎)
        cls._config_cache['grades'] = GameConfigLoader.get('generation.grades')
        cls._config_cache['grade_weights'] = GameConfigLoader.get('generation.grade_weights')
        cls._config_cache['untrainable_keys'] = GameConfigLoader.get('generation.attributes.untrainable')
        cls._config_cache['trainable_keys'] = GameConfigLoader.get('generation.attributes.trainable')
        cls._config_cache['height_modifiers'] = GameConfigLoader.get('generation.height_modifiers')
        cls._config_cache['weighted_bonus_keys'] = GameConfigLoader.get('generation.weighted_bonus_keys')
        
        # 3. 預載入身高與位置參數 (消除 Hardcode)
        cls._config_cache['height_dist'] = GameConfigLoader.get('generation.height_distribution')
        
        # 3.1 位置矩陣優化
        raw_pos_matrix = GameConfigLoader.get('generation.position_matrix')
        cls._config_cache['pos_matrix_optimized'] = []
        for entry in raw_pos_matrix:
            cls._config_cache['pos_matrix_optimized'].append({
                'threshold': entry['max_height'],
                'roles': list(entry['weights'].keys()),
                'weights': list(entry['weights'].values())
            })

        # 3.2 [New] 位置檢核規則編譯 (Rule Compiler)
        # 將 YAML 中的 "sum(a, b, c) > ..." 字串解析為 Python list ['a', 'b', 'c']
        raw_validation = GameConfigLoader.get('generation.position_validation')
        cls._config_cache['pos_validation_compiled'] = {}
        
        for pos, rule in raw_validation.items():
            condition_str = rule.get('condition', 'none')
            if condition_str == 'none':
                cls._config_cache['pos_validation_compiled'][pos] = None
            else:
                # 使用 Regex 提取 sum(...) 中的內容
                # 假設格式總是 sum(key1, key2...) > ...
                match = re.search(r"sum\((.*?)\)", condition_str)
                if match:
                    keys_str = match.group(1)
                    # 轉為 list: ['def_rebound', 'def_boxout', 'def_contest']
                    keys = [k.strip() for k in keys_str.split(',')]
                    cls._config_cache['pos_validation_compiled'][pos] = keys
                else:
                    # Fallback: 若解析失敗，視為無限制，避免 Crash
                    print(f"[Warning] Failed to parse validation rule for {pos}: {condition_str}")
                    cls._config_cache['pos_validation_compiled'][pos] = None

        # 4. 預載入各等級規則
        cls._config_cache['rules_by_grade'] = {}
        for g in cls._config_cache['grades']:
            cls._config_cache['rules_by_grade'][g] = {
                'untrainable': GameConfigLoader.get(f'generation.untrainable_rules.{g}'),
                'trainable_cap': GameConfigLoader.get(f'generation.trainable_caps.{g}'),
                'salary_factor': GameConfigLoader.get(f'generation.salary_factors.{g}'),
                'contract': GameConfigLoader.get(f'generation.contracts.{g}'),
                'age_offset': GameConfigLoader.get(f'generation.age_rules.offsets.{g}')
            }

        cls._is_initialized = True
        print(f"[PlayerGenerator] Cache initialized. Validation Rules Compiled.")

    # =========================================================================
    # 1. 姓名生成 (Name Generation)
    # =========================================================================
    @classmethod
    def _generate_name(cls):
        if not cls._is_initialized: cls.initialize_class()

        r = random.random()
        target_len = 1 if r < 0.80 else (2 if r < 0.95 else 3)
        
        valid_lasts = [n for n in cls._names_cache['last'] if (len(n) == target_len if target_len < 3 else len(n) >= 3)]
        last_name = random.choice(valid_lasts) if valid_lasts else random.choice(cls._names_cache['last'])
        first_name = random.choice(cls._names_cache['first'])
        
        full_name = last_name + first_name
        
        should_add = False
        if len(full_name) <= 2:
            should_add = random.choice([True, False])
        elif len(last_name) > 1 and len(first_name) == 1:
            should_add = random.choice([True, False])
            
        if should_add:
            second_char = random.choice(cls._names_cache['first'])
            if len(second_char) == 1:
                full_name += second_char
                
        return full_name

    # =========================================================================
    # 2. 天賦生成 (Untrainable Stats)
    # =========================================================================
    @classmethod
    def _generate_untrainable_stats(cls, grade):
        keys = cls._config_cache['untrainable_keys']
        rule = cls._config_cache['rules_by_grade'][grade]['untrainable']
        
        stat_min, stat_max = rule["stat_min"], rule["stat_max"]
        sum_min, sum_max = rule["sum_min"], rule["sum_max"]
        
        while True:
            stats = {k: stat_min for k in keys}
            current_sum = sum(stats.values())
            target_sum = random.randint(sum_min, sum_max)
            remaining = target_sum - current_sum
            
            valid_keys = list(keys)
            while remaining > 0 and valid_keys:
                k = random.choice(valid_keys)
                space = stat_max - stats[k]
                if space <= 0:
                    valid_keys.remove(k)
                    continue
                
                step = random.randint(1, min(remaining, space, 10))
                stats[k] += step
                remaining -= step
            
            if remaining == 0:
                return stats

    # =========================================================================
    # 3. 身高與位置 (Height & Position) - Fully Configurable
    # =========================================================================
    @classmethod
    def _generate_height(cls):
        conf = cls._config_cache['height_dist']
        mean, std_dev = conf['mean'], conf['std_dev']
        min_h, max_h = conf['min'], conf['max']
        
        while True:
            u1, u2 = random.random(), random.random()
            z = math.sqrt(-2.0 * math.log(max(u1, 1e-12))) * math.cos(2.0 * math.pi * u2)
            height = int(round(mean + z * std_dev))
            if min_h <= height <= max_h:
                return height

    @classmethod
    def _pick_position(cls, h):
        for rule in cls._config_cache['pos_matrix_optimized']:
            if h <= rule['threshold']:
                return random.choices(rule['roles'], weights=rule['weights'], k=1)[0]
        return "C"

    # =========================================================================
    # 4. 可訓練能力生成 (Trainable Stats)
    # =========================================================================
    
    @classmethod
    def _check_position_validation(cls, stats, pos):
        """
        [Spec 2.4.2] 位置檢核機制 (Dynamic)
        不再使用 Hardcode，而是讀取初始化時編譯好的 Key List
        """
        # 1. 取得該位置的關鍵屬性列表 (List of keys)
        core_keys = cls._config_cache['pos_validation_compiled'].get(pos)
        
        # 若無規則 (如 SF)，直接通過
        if not core_keys:
            return True
            
        # 2. 計算核心總和
        # 使用 Generator Expression 進行加總，效能極佳
        core_sum = sum(stats[k] for k in core_keys)
        
        # 3. 計算總和
        total_sum = sum(stats.values())
        
        # 4. 判定: 核心 > (總和 - 核心) => 核心 > 其他
        return core_sum > (total_sum - core_sum)

    @staticmethod
    def _safe_distribute(stats, target_keys, points_to_add):
        """[Helper] 安全分配點數，包含防爆機制 (Max 99)"""
        if points_to_add <= 0: return
        valid_keys = list(target_keys)
        while points_to_add > 0 and valid_keys:
            k = random.choice(valid_keys)
            capacity = 99 - stats[k]
            if capacity <= 0:
                valid_keys.remove(k)
                continue
            stats[k] += 1
            points_to_add -= 1

    @classmethod
    def _distribute_bonus_points(cls, stats, bonus, bonus_type, bonus_config=None):
        """[Spec 2.4.3] 執行加點邏輯 (Revised)"""
        if bonus <= 0: return stats
        
        all_keys = list(stats.keys())
        
        if bonus_type == 'flat':
            per_stat = bonus // len(all_keys)
            for k in all_keys:
                stats[k] = min(99, stats[k] + per_stat)
                
        elif bonus_type == 'weighted':
            ratio_min = bonus_config.get('key_ratio_min', 0.5) if bonus_config else 0.5
            ratio_max = bonus_config.get('key_ratio_max', 1.0) if bonus_config else 1.0
            
            ratio = random.uniform(ratio_min, ratio_max)
            key_pool = int(bonus * ratio)
            general_pool = bonus - key_pool
            
            high_p_keys = cls._config_cache['weighted_bonus_keys']['high_priority']
            
            cls._safe_distribute(stats, high_p_keys, key_pool)
            cls._safe_distribute(stats, all_keys, general_pool)
                    
        return stats

    @classmethod
    def _generate_trainable_stats(cls, grade, height, position):
        keys = cls._config_cache['trainable_keys']
        cap = cls._config_cache['rules_by_grade'][grade]['trainable_cap']
        
        # 1. 取得身高修正規則
        mod_rules = cls._config_cache['height_modifiers']
        # 區間判斷邏輯 (可以進一步優化為 Config 驅動，但此處為效能熱點，且區間變動機率低)
        if 160 <= height <= 169: rule = mod_rules['160-169']
        elif 170 <= height <= 179: rule = mod_rules['170-179']
        elif 180 <= height <= 189: rule = mod_rules['180-189']
        elif 190 <= height <= 209: rule = mod_rules['190-209']
        elif 210 <= height <= 219: rule = mod_rules['210-219']
        elif 220 <= height <= 230: rule = mod_rules['220-230']
        else: rule = mod_rules['190-209']

        trials = rule.get('trials', 1)
        selection = rule.get('selection', 'none')
        bonus = rule.get('bonus_points', 0)
        bonus_type = rule.get('bonus_type', 'none')

        candidates = []

        # 2. 執行 Trials (分階段重骰)
        for _ in range(trials):
            while True:
                temp_stats = {k: random.randint(1, 99) for k in keys}
                if sum(temp_stats.values()) > cap:
                    continue
                # [Dynamic Check]
                if not cls._check_position_validation(temp_stats, position):
                    continue
                candidates.append(temp_stats)
                break
        
        # 3. 選擇最佳/最差
        final_stats = candidates[0]
        if selection == 'max':
            final_stats = max(candidates, key=lambda x: sum(x.values()))
        elif selection == 'min':
            final_stats = min(candidates, key=lambda x: sum(x.values()))
            
        # 4. 應用身高獎勵
        final_stats = cls._distribute_bonus_points(final_stats, bonus, bonus_type, rule)
        
        return final_stats

    # =========================================================================
    # 主流程 (Main Workflow)
    # =========================================================================
    @classmethod
    def generate_payload(cls, specific_grade=None):
        if not cls._is_initialized: cls.initialize_class()

        # 1. Name
        name = cls._generate_name()

        # 2. Grade
        if specific_grade:
            grade = specific_grade
        else:
            grade = random.choices(
                cls._config_cache['grades'], 
                weights=cls._config_cache['grade_weights'], 
                k=1
            )[0]

        # 3. Untrainable
        untrainable = cls._generate_untrainable_stats(grade)

        # 4. Height & Position
        height = cls._generate_height()
        position = cls._pick_position(height)

        # 5. Trainable
        trainable = cls._generate_trainable_stats(grade, height, position)

        # 6. Age
        age_base = 18
        age_offset = cls._config_cache['rules_by_grade'][grade]['age_offset']
        age = age_base + random.randint(0, age_offset)

        # 7. Derived Data
        raw_stats = {**untrainable, **trainable}
        total_sum = sum(raw_stats.values())
        
        salary_factor = cls._config_cache['rules_by_grade'][grade]['salary_factor']
        salary = int(round(total_sum * salary_factor))
        
        contract_rule = cls._config_cache['rules_by_grade'][grade]['contract']

        # 8. Assembly
        detailed_stats = {"physical": {}, "offense": {}, "defense": {}, "mental": {}}
        for cfg_key, (cat, db_key) in cls.ATTR_MAPPING.items():
            if cfg_key in raw_stats:
                detailed_stats[cat][db_key] = raw_stats[cfg_key]

        return {
            "name": name,
            "grade": grade,
            "age": age,
            "height": height,
            "position": position,
            "rating": int(total_sum / 20),
            "salary": salary,
            "contract_rule": contract_rule,
            "detailed_stats": detailed_stats,
            "raw_stats": raw_stats
        }

    # ====================================================
    # 工具方法
    # ====================================================
    @staticmethod
    def to_flat_dict(payload):
        flat = {
            "name": payload['name'],
            "grade": payload['grade'],
            "age": payload['age'],
            "height": payload['height'],
            "position": payload['position'],
            "rating": payload['rating'],
            "salary": payload['salary'],
            "contract_years": payload['contract_rule']['years'],
            "contract_role": payload['contract_rule']['role']
        }
        for cat, stats in payload['detailed_stats'].items():
            for k, v in stats.items():
                flat[f"{cat}_{k}"] = v
        return flat

    @classmethod
    def save_to_db(cls, payload, user_id=None, team_id=None):
        player = Player(
            name=payload['name'],
            age=payload['age'],
            height=payload['height'],
            position=payload['position'],
            rating=payload['rating'],
            detailed_stats=payload['detailed_stats'],
            user_id=user_id,
            team_id=team_id,
            training_points=0
        )
        db.session.add(player)
        db.session.flush()

        contract_data = None
        if team_id:
            rule = payload['contract_rule']
            contract = Contract(
                player_id=player.id,
                team_id=team_id,
                salary=payload['salary'],
                years=rule['years'],
                years_left=rule['years'],
                role=rule['role']
            )
            db.session.add(contract)
            contract_data = rule

        return player, contract_data

============================================================

File: app\services\team_creator.py
------------------------------------------------------------
# app/services/team_creator.py

from collections import Counter
from typing import List, Dict, Any
from app.services.player_generator import PlayerGenerator
from app.utils.game_config_loader import GameConfigLoader

class TeamCreator:
    """
    ASBL 開隊陣容生成服務 (Pure Logic Version)
    只負責生成符合規則的球員資料結構，不涉及資料庫寫入。
    對應規格書: Player System Specification v3.3 (2025/12/28 Update)
    """

    @classmethod
    def create_valid_roster(cls, max_attempts: int = 100000) -> List[Dict[str, Any]]:
        """
        [Spec 5] 生成符合檢核條件的 15 人名單
        邏輯: 
          1. 依據等級分佈生成球員
          2. [Spec 5.4] 針對每一位生成的球員進行「下限檢核」，不合格則單兵重骰
          3. [Spec 5.2] 針對整隊進行「位置檢核」與「高階覆蓋檢核」，不合格則整隊重骰
        Returns:
            List[Dict]: 包含 15 個球員 Payload 的列表
        """
        # 1. 從參數檔讀取設定
        comp_rules = GameConfigLoader.get('team_creation.composition_count')
        val_rules = GameConfigLoader.get('team_creation.validation')
        
        # [Spec 5.4] 讀取開隊特殊規則參數
        min_ratio = GameConfigLoader.get('team_creation.initial_team_min_ratio', 0.5)
        trainable_caps = GameConfigLoader.get('generation.trainable_caps')
        trainable_attrs = GameConfigLoader.get('generation.attributes.trainable')

        attempts = 0
        while attempts < max_attempts:
            attempts += 1
            roster = []

            # 2. 依據等級分佈生成球員
            # 注意: Python 3.7+ 字典保持插入順序，通常 SSR 會先被執行
            for grade, count in comp_rules.items():
                # 取得該等級的能力上限，用於計算下限門檻
                grade_cap = trainable_caps.get(grade, 9999)
                lower_bound = grade_cap * min_ratio

                for _ in range(count):
                    # 單兵生成迴圈 (針對下限檢核)
                    player_payload = cls._generate_qualified_player(
                        grade, 
                        lower_bound, 
                        trainable_attrs
                    )
                    roster.append(player_payload)

            # 3. 執行整隊陣容檢核 (位置數量 + 高階覆蓋)
            if cls._validate_roster_positions(roster, val_rules):
                return roster
        
        raise Exception(f"Failed to generate a valid team after {max_attempts} attempts. Please check config constraints.")

    @classmethod
    def _generate_qualified_player(cls, grade: str, lower_bound: float, trainable_attrs: List[str], max_single_attempts: int = 50000) -> Dict[str, Any]:
        """
        [Spec 5.4] 生成並檢核單一球員是否符合開隊下限
        若生成的球員能力總和低於 lower_bound，則視為無效(太弱)，重新生成。
        """
        for _ in range(max_single_attempts):
            # 呼叫純粹的生成器
            payload = PlayerGenerator.generate_payload(specific_grade=grade)
            
            # 解析屬性來源
            # PlayerGenerator 可能將數值放在 'raw_stats' (扁平) 或 'attributes' (巢狀)
            stats_source = {}
            
            if 'raw_stats' in payload:
                # 優先使用 raw_stats，因為這是最完整的扁平化數據
                stats_source = payload['raw_stats']
            else:
                # Fallback: 嘗試解析 attributes 結構
                attrs = payload.get('attributes', {})
                if 'trainable' in attrs:
                    # 若結構為 {'attributes': {'trainable': {...}}}
                    stats_source = attrs['trainable']
                else:
                    # 若結構為 {'attributes': {...扁平...}}
                    stats_source = attrs

            # 計算可訓練能力總和
            total_score = sum(stats_source.get(attr, 0) for attr in trainable_attrs)

            # 檢核下限
            if total_score >= lower_bound:
                return payload
        
        # 若連續 100 次都失敗，通常代表數據讀取錯誤 (total_score=0) 或下限設定不合理
        raise Exception(f"Failed to generate a qualified player for grade {grade} (Target > {lower_bound}). Last Score: {total_score}")

    @staticmethod
    def _validate_roster_positions(roster: List[Dict[str, Any]], rules: Dict[str, Any]) -> bool:
        """
        [Spec 5.2] 檢核整隊位置分佈
        包含基礎數量檢核與高階球員位置覆蓋檢核
        """
        # 統計位置數量
        positions = [p['position'] for p in roster]
        counts = Counter(positions)
        
        # 1. C (中鋒) 數量至少 min_c
        if counts['C'] < rules.get('min_c', 2):
            return False
        
        # 2. PG (控球後衛) 數量至少 min_pg
        if counts['PG'] < rules.get('min_pg', 2):
            return False
        
        # 3. 後衛組 (PG + SG) 總數至少 min_guards
        guard_count = counts['PG'] + counts['SG']
        if guard_count < rules.get('min_guards', 4):
            return False
        
        # 4. 前鋒組 (PF + SF) 總數至少 min_forwards
        forward_count = counts['PF'] + counts['SF']
        if forward_count < rules.get('min_forwards', 4):
            return False
        
        # 5. [New v3.3] 高階位置覆蓋檢核 (High-Tier Coverage)
        # 確保 SSR/SS/S 組合包含所有 5 個位置
        coverage_rule = rules.get('high_tier_coverage', {})
        if coverage_rule.get('enabled', False):
            target_grades = set(coverage_rule.get('target_grades', []))
            required_positions = set(coverage_rule.get('required_positions', []))
            
            # 篩選出高階球員
            high_tier_positions = {
                p['position'] for p in roster 
                if p.get('grade') in target_grades
            }
            
            # 檢查是否包含所有必要位置 (issubset: required 是否被 high_tier 包含)
            if not required_positions.issubset(high_tier_positions):
                return False
            
        return True

============================================================

File: app\services\match_engine\core.py
------------------------------------------------------------
# app/services/match_engine/core.py

from typing import Dict, List, Optional, Tuple, Union
import math

from .structures import EngineTeam, EnginePlayer, MatchState, MatchResult
from .utils.calculator import Calculator
from .utils.rng import rng
from .systems.stamina import StaminaSystem
from .systems.substitution import SubstitutionSystem
from .systems.attribution import AttributionSystem

class MatchEngine:
    """
    ASBL 比賽引擎核心 (Level 4 - Phase 2 Final)
    對應規格書: Match Engine Specification v1.8
    
    [Phase 2 Updates]
    - 整合 Pace 計算 (Record Possession)。
    - 整合快攻效率統計 (Record Fastbreak)。
    - 輸出包含進階數據的 MatchResult。
    
    [Update 2026-01-16]
    - 新增: 正負值 (+/-) 統計
    - 新增: 回合時間 (Possession Time) 記錄
    """

    def __init__(self, home_team: EngineTeam, away_team: EngineTeam, config: Dict, game_id: str = "SIM_GAME"):
        self.home_team = home_team
        self.away_team = away_team
        self.config = config
        self.game_id = game_id
        
        # 1. 初始化比賽狀態
        general_config = config.get('match_engine', {}).get('general', {})
        self.quarter_length = general_config.get('quarter_length', 720)
        self.ot_length = general_config.get('ot_length', 300)
        
        # [修正] 讀取換人相關參數 (犯規上限 & 關鍵時刻閾值)
        sub_config = general_config.get('substitution', {})
        self.foul_limit = sub_config.get('foul_limit', 6)
        self.clutch_threshold = sub_config.get('clutch_time_threshold', 120.0)
        
        self.state = MatchState(time_remaining=float(self.quarter_length))
        
        # 2. 執行賽前準備
        self._initialize_match()
        
        # 3. 初始化 PBP Logs
        self.pbp_logs = []

    def _initialize_match(self):
        """賽前準備流程"""
        # [新增] Spec v2.1 Section 1.5 賽前身高修正 (必須在體力與評分計算前執行)
        self._apply_height_correction(self.home_team)
        self._apply_height_correction(self.away_team)

        for team in [self.home_team, self.away_team]:
            self._calculate_all_positional_scores(team)
            self._determine_best_five(team)
            self._distribute_team_minutes(team)
            self._set_initial_lineup(team)

    # [新增整個方法]
    def _apply_height_correction(self, team: EngineTeam):
        """
        [Spec v2.1 Section 1.5] 身高屬性修正 (Initial Height Correction)
        針對特定屬性進行基於身高的物理修正，此為永久性修正。
        """
        hc_config = self.config.get('match_engine', {}).get('height_correction', {})
        bonus_h = hc_config.get('bonus_threshold', 190)
        nerf_h = hc_config.get('nerf_threshold', 210)
        affected_attrs = hc_config.get('affected_attrs', {})

        for player in team.roster:
            h = getattr(player, 'height', 195)
            
            # 計算修正倍率因子
            # 公式: max(BONUS_H - h, min(NERF_H - h, 0))
            factor = max(bonus_h - h, min(nerf_h - h, 0))
            
            if factor == 0:
                continue

            # 應用修正
            for _, rule in affected_attrs.items():
                keys = rule.get('keys', [])
                coeff = rule.get('coeff', 0.0)
                multiplier = 1.0 + (factor * coeff)
                
                for key in keys:
                    original_val = getattr(player, key, 0)
                    if original_val > 0:
                        new_val = original_val * multiplier
                        # 確保數值邊界
                        new_val = max(1, min(999, new_val)) 
                        setattr(player, key, new_val)

    def _calculate_all_positional_scores(self, team: EngineTeam):
        """[Spec 1.1] 計算位置評分"""
        scoring_rules = self.config.get('match_engine', {}).get('positional_scoring', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})
        positions = ["C", "PF", "SF", "SG", "PG"]

        for player in team.roster:
            player.pos_scores = {}
            for pos in positions:
                rule_attrs = scoring_rules.get(pos, [])
                score = Calculator.get_player_attr_sum(player, rule_attrs, attr_pools)
                player.pos_scores[pos] = score

    def _determine_best_five(self, team: EngineTeam):
        """[Spec 1.1] 標記最強陣容"""
        positions = ["C", "PF", "SF", "SG", "PG"]
        best_five = [None] * 5
        taken_ids = set()
        candidates = []
        
        for p in team.roster:
            for i, pos in enumerate(positions):
                candidates.append((p.pos_scores[pos], i, p))
        
        candidates.sort(key=lambda x: x[0], reverse=True)

        for score, pos_idx, player in candidates:
            if best_five[pos_idx] is None and player.id not in taken_ids:
                best_five[pos_idx] = player
                taken_ids.add(player.id)
            if all(best_five): break
        
        if not all(best_five):
            remaining = [p for p in team.roster if p.id not in taken_ids]
            for i in range(5):
                if best_five[i] is None and remaining:
                    p = remaining.pop(0)
                    best_five[i] = p
                    taken_ids.add(p.id)
        team.best_five = best_five

    def _distribute_team_minutes(self, team: EngineTeam):
        """[Spec 1.4 & 2.6] 上場時間分配"""
        min_config = self.config.get('minutes_distribution', {})
        total_minutes = min_config.get('total_minutes', 240)
        role_config = min_config.get('roles', {})

        total_base = 0.0
        active_players = []
        for player in team.roster:
            role_data = role_config.get(player.role, role_config.get('Bench'))
            total_base += role_data.get('base', 0)
            active_players.append(player)

        remaining_time = max(0, total_minutes - total_base)
        
        total_weight = 0.0
        player_weights = {}
        for player in active_players:
            role_data = role_config.get(player.role, role_config.get('Bench'))
            min_w = role_data.get('min_w', 0)
            max_w = role_data.get('max_w', 10)
            w = rng.get_float(float(min_w), float(max_w))
            player_weights[player.id] = w
            total_weight += w

        unit_value = remaining_time / total_weight if total_weight > 0 else 0
        allocated_sum = 0.0

        for i, player in enumerate(active_players):
            role_data = role_config.get(player.role, role_config.get('Bench'))
            base = role_data.get('base', 0)
            raw = base + (player_weights[player.id] * unit_value)
            final = math.floor(raw * 10) / 10.0
            
            if i == len(active_players) - 1:
                diff = total_minutes - allocated_sum
                if diff > 0: final = diff
            
            allocated_sum += final
            player.target_seconds = final * 60.0
            player.seconds_played = 0.0

    def _set_initial_lineup(self, team: EngineTeam):
        """[Spec 1.2] 決定先發陣容"""
        positions = ["PG", "SG", "SF", "PF", "C"]
        starters = [None] * 5
        taken_ids = set()

        def try_fill(player):
            my_scores = []
            for i, pos in enumerate(positions):
                if starters[i] is None:
                    my_scores.append((player.pos_scores[pos], i))
            my_scores.sort(key=lambda x: x[0], reverse=True)
            if my_scores:
                _, idx = my_scores[0]
                starters[idx] = player
                taken_ids.add(player.id)
                player.position = positions[idx]
                return True
            return False

        for role in ['Star', 'Starter']:
            for p in [x for x in team.roster if x.role == role]:
                try_fill(p)
        
        remaining = [p for p in team.roster if p.id not in taken_ids]
        for i, pos in enumerate(positions):
            if starters[i] is None:
                best_p = max(remaining, key=lambda p: p.pos_scores[pos], default=None)
                if best_p:
                    starters[i] = best_p
                    best_p.position = pos
                    taken_ids.add(best_p.id)
                    remaining.remove(best_p)

        team.on_court = [p for p in starters if p]
        team.bench = [p for p in team.roster if p.id not in taken_ids]

    def _resolve_formula(self, formula: Union[str, List[str]], attr_pools: Dict) -> List[str]:
        if isinstance(formula, str):
            return attr_pools.get(formula, [])
        return formula

    # =========================================================================
    # Simulation Loop
    # =========================================================================

    def simulate(self) -> MatchResult:
        """
        [Spec v1.8] 執行整場模擬
        """
        # 1. 跳球
        jb_winner = self._jump_ball()
        jb_loser = self.home_team.id if jb_winner == self.away_team.id else self.away_team.id
        
        # 2. 節次球權
        q_possessions = {1: jb_winner, 2: jb_loser, 3: jb_loser, 4: jb_winner}

        # 3. 正規賽
        for q in range(1, 5):
            self.state.quarter = q
            self.state.time_remaining = float(self.quarter_length)
            self.state.possession = q_possessions[q]
            self.pbp_logs.append(f"=== Q{q} Start (Possession: {self.state.possession}) ===")
            self._simulate_quarter()

        # 4. 延長賽
        while self.home_team.score == self.away_team.score:
            self.state.quarter += 1
            self.state.time_remaining = float(self.ot_length)
            ot_winner = self._jump_ball()
            self.state.possession = ot_winner
            self.pbp_logs.append(f"=== OT{self.state.quarter-4} Start ===")
            self._simulate_quarter()

        self.state.is_over = True
        
        # 5. 計算 Pace (Possessions per 48 min)
        total_possessions = self.home_team.stat_possessions + self.away_team.stat_possessions
        total_minutes = self.state.game_time_elapsed / 60.0
        pace = 0.0
        if total_minutes > 0:
            # Pace = 48 * (Total Poss / 2) / Minutes ? 
            # Standard Pace = (Team Poss + Opp Poss) / 2 * (48 / Minutes)
            pace = (total_possessions / 2.0) * (48.0 / total_minutes)

        # 6. 回傳結果
        return MatchResult(
            game_id=self.game_id,
            home_team_id=self.home_team.id,
            away_team_id=self.away_team.id,
            home_score=self.home_team.score,
            away_score=self.away_team.score,
            is_ot=(self.state.quarter > 4),
            total_quarters=self.state.quarter,
            pbp_log=self.pbp_logs,
            # Phase 2 Data
            pace=pace,
            home_possessions=self.home_team.stat_possessions,
            away_possessions=self.away_team.stat_possessions,
            home_fb_made=self.home_team.stat_fb_made,
            home_fb_attempt=self.home_team.stat_fb_attempt,
            away_fb_made=self.away_team.stat_fb_made,
            away_fb_attempt=self.away_team.stat_fb_attempt,
            # [New] 回合時間統計與平均值計算
            home_possession_history=self.home_team.stat_possession_history,
            away_possession_history=self.away_team.stat_possession_history,
            home_avg_seconds_per_poss=(self.home_team.stat_possession_seconds / self.home_team.stat_possessions) if self.home_team.stat_possessions > 0 else 0.0,
            away_avg_seconds_per_poss=(self.away_team.stat_possession_seconds / self.away_team.stat_possessions) if self.away_team.stat_possessions > 0 else 0.0
        )

    def _jump_ball(self) -> str:
        """(Spec 1.5) 跳球"""
        jb_config = self.config.get('match_engine', {}).get('jump_ball', {})
        attrs = jb_config.get('participant_formula', ['height', 'ath_jump', 'talent_offiq'])
        
        def get_jumper(team):
            c = [p for p in team.on_court if p.position == 'C']
            return c[0] if c else max(team.on_court, key=lambda p: p.pos_scores.get('C', 0))

        h_jumper = get_jumper(self.home_team)
        a_jumper = get_jumper(self.away_team)
        
        h_score = Calculator.get_player_attr_sum(h_jumper, attrs)
        a_score = Calculator.get_player_attr_sum(a_jumper, attrs)
        total = h_score + a_score or 1
        
        if rng.decision(h_score / total):
            self.pbp_logs.append(f"Jump Ball: {self.home_team.name} wins")
            return self.home_team.id
        else:
            self.pbp_logs.append(f"Jump Ball: {self.away_team.name} wins")
            return self.away_team.id

    def _simulate_quarter(self):
        """
        模擬單節比賽流程
        [Phase 2] 加入 Possession 記錄邏輯
        """
        is_opening = (self.state.quarter == 1)
        
        # 標記是否為新的一波球權 (節次開始或攻守交換後)
        is_new_possession = True 

        while self.state.time_remaining > 0:
            self._check_substitutions()
            
            # 1. 確定當前進攻方
            if self.state.possession == self.home_team.id:
                off_team, def_team = self.home_team, self.away_team
            else:
                off_team, def_team = self.away_team, self.home_team
            
            # 2. 若是新球權，記錄之 (Pace Calculation)
            if is_new_possession:
                AttributionSystem.record_possession(off_team)
                is_new_possession = False

            # 3. 執行回合
            elapsed, desc, keep = self._simulate_possession(is_opening)
            
            # [New] 記錄回合消耗時間
            # 將該次進攻所花費的時間，歸屬給進攻方
            AttributionSystem.record_possession_time(off_team, elapsed)
            
            self.state.time_remaining -= elapsed
            self.state.game_time_elapsed += elapsed
            
            # Update Stamina & Time
            for team in [self.home_team, self.away_team]:
                for p in team.on_court:
                    p.seconds_played += elapsed
                    StaminaSystem.update_stamina(p, elapsed, True, self.config)
                for p in team.bench:
                    StaminaSystem.update_stamina(p, elapsed, False, self.config)
            
            self.pbp_logs.append(f"[{self.state.quarter}Q {self.state.time_remaining:.1f}] {desc}")
            
            # 4. 攻守交換判定
            if not keep:
                # 交換球權
                self.state.possession = self.away_team.id if self.state.possession == self.home_team.id else self.home_team.id
                is_new_possession = True # 下一回合為新球權
            else:
                # 進攻籃板，維持球權 (不計為新 Possession)
                is_new_possession = False
            
            is_opening = False
        
        # 讀取時間設定
        gen_config = self.config.get('match_engine', {}).get('general', {})
        halftime_min = gen_config.get('stamina_recovery_halftime', 20.0)
        quarter_break_min = gen_config.get('stamina_recovery_quarter', 2.0)
        
        if self.state.quarter == 2:
            # 中場休息 (Q2 結束)
            self.pbp_logs.append(f"=== Halftime Break ({halftime_min} mins) ===")
            StaminaSystem.apply_rest(self.home_team.roster, halftime_min, self.config)
            StaminaSystem.apply_rest(self.away_team.roster, halftime_min, self.config)
            
        elif self.state.quarter in [1, 3]:
            # 節間休息 (Q1, Q3 結束)
            self.pbp_logs.append(f"=== Quarter Break ({quarter_break_min} mins) ===")
            StaminaSystem.apply_rest(self.home_team.roster, quarter_break_min, self.config)
            StaminaSystem.apply_rest(self.away_team.roster, quarter_break_min, self.config)

        # 3. 延長賽前休息 (Q4 結束平手, 或 OT 結束平手)
        # 邏輯: 若現在是 Q4 或 OT (Q>=4)，且分數平手，代表即將進入下一節，需要休息
        elif self.state.quarter >= 4 and self.home_team.score == self.away_team.score:
            self.pbp_logs.append(f"=== Overtime Break ({quarter_break_min} mins) ===")
            StaminaSystem.apply_rest(self.home_team.roster, quarter_break_min, self.config)
            StaminaSystem.apply_rest(self.away_team.roster, quarter_break_min, self.config)

    def _check_substitutions(self):
        """換人檢查"""
        # 判斷是否為關鍵時刻 (Q4 或 OT 的最後 2 分鐘)
        is_clutch = (self.state.quarter >= 4 and self.state.time_remaining <= self.clutch_threshold)
        
        if is_clutch:
            #  關鍵時刻：強制執行 Best 5 調度
            for team in [self.home_team, self.away_team]:
                logs = SubstitutionSystem.enforce_best_lineup(team, self.config)
                self.pbp_logs.extend(logs)
            return # 執行完強制調度後，依然不進行常規體力檢查
        
        # 非關鍵時刻：執行常規換人檢查 (體力/時間)
        for team in [self.home_team, self.away_team]:
            logs = SubstitutionSystem.check_auto_substitution(
                team, self.state.quarter, self.state.time_remaining, self.config
            )
            self.pbp_logs.extend(logs)

    def _simulate_possession(self, is_opening: bool) -> Tuple[float, str, bool]:
        """
        單一回合模擬
        更新 v2.4: 支援後場抄截後的「即時攻守交換」(Instant Transition)
        """
        # 1. 確定初始攻守方
        if self.state.possession == self.home_team.id:
            off_team, def_team = self.home_team, self.away_team
        else:
            off_team, def_team = self.away_team, self.home_team

        # ============================================================
        # Phase 1: Backcourt (後場)
        # ============================================================
        elapsed_bc, res, desc = self._run_backcourt(off_team, def_team, is_opening)
        
        # [Case A] 正常推進 -> 進入前場
        if res == 'frontcourt':
            pass # 繼續執行 Phase 2

        # [Case B] 普通失誤 (8秒/出界) -> 結束回合
        elif res == 'turnover':
            return elapsed_bc, desc, False

        # [Case C] 抄截後的轉換 (Steal Transition) [New v2.4]
        elif res in ['steal_fastbreak', 'steal_frontcourt']:
            # 這裡發生了「回合內攻守交換」
            # 原防守方 (def_team) 變成了 進攻方
            # 原進攻方 (off_team) 變成了 防守方
            # 1. 記錄防守方(現在的進攻方)的球權 (因為他們發動了快攻/反擊)
            AttributionSystem.record_possession(def_team)
            
            # 2. 處理快攻分支
            if res == 'steal_fastbreak':
                # 執行快攻 (注意參數順序互換)
                # [Update] 傳入 def_team 以計算 +/- (因為 def_team 現在是進攻方)
                elapsed_fb, fb_res, fb_desc = self._run_fastbreak(def_team, off_team, elapsed_bc)
                
                # 處理回傳的 keep 邏輯 (反轉)
                # 若快攻進球(keep=False)，我們希望下一回合球權給原進攻方(A)，而當前possession是A
                # 外層迴圈邏輯: if not keep: switch.
                # 若我們回傳 False -> switch -> 變 B 球權 (錯)
                # 若我們回傳 True -> no switch -> 變 A 球權 (對)
                # 結論: 抄截反擊的結果需要 invert keep
                
                # 特殊情況: 快攻失敗(被蓋/籃板)，回傳的是 turnover 嗎?
                # _run_fastbreak 回傳: ('score', desc) 或 ('turnover', desc)
                # 這裡的 turnover 代表防守成功(原攻方拿回球權/籃板)，相當於 keep=False (B沒拿到球)
                # 所以邏輯一致，直接回傳 True 即可讓 A 拿回球權?
                # 等等，_run_fastbreak 沒有回傳 keep，它回傳 (elapsed, type, desc)
                
                # 讓我們看 _run_fastbreak 的實作:
                # 進球 -> record_score -> return 'score'
                # 失敗 -> record_rebound(chaser) -> return 'turnover'
                
                if fb_res == 'score':
                    # 因為回傳 keep=True，主迴圈會誤以為是進攻籃板而不計數
                    # 所以這裡預先幫 off_team 記錄下一次的球權
                    AttributionSystem.record_possession(off_team)
                    return elapsed_fb, fb_desc, True # A 拿回球權
                else:
                    # 同上，off_team 獲得防守籃板，視為新回合開始
                    AttributionSystem.record_possession(off_team)
                    # 快攻失敗 (被 A 守住/抓板) -> A 拿回球權
                    return elapsed_fb, fb_desc, True

            # 3. 處理直接前場分支 (Skip Backcourt)
            elif res == 'steal_frontcourt':
                # 直接進入前場階段 (注意參數順序互換)
                # 時間繼承: 已經過了 elapsed_bc 秒
                elapsed_fc, fc_res, fc_desc, ctx = self._run_frontcourt(def_team, off_team, elapsed_bc)
                
                if fc_res == 'shooting':
                    shoot_desc, shoot_keep = self._run_shooting(def_team, off_team, ctx)
                    # 這裡 shoot_keep 是針對 def_team (現在的進攻方) 而言
                    # 如果 B 搶到進攻籃板 (True) -> 下一回合 B 繼續攻 -> possession 需切換為 B -> return False
                    # 如果 B 進球/被抓板 (False) -> 下一回合 A 攻 -> possession 維持 A -> return True
                    return elapsed_bc + elapsed_fc, shoot_desc, not shoot_keep
                else:
                    # 前場失誤 (def_team 失誤) -> off_team 拿回球權
                    # 手動補 off_team 球權
                    AttributionSystem.record_possession(off_team) # <--- 新增這行
                    # 前場失誤 (B 失誤) -> A 拿回球權
                    return elapsed_bc + elapsed_fc, fc_desc, True

        # ============================================================
        # Phase 2: Frontcourt (前場)
        # ============================================================
        elapsed_fc, res, desc, ctx = self._run_frontcourt(off_team, def_team, elapsed_bc)
        total_elapsed = elapsed_bc + elapsed_fc
        
        if res != 'shooting': 
            return total_elapsed, desc, False

        # ============================================================
        # Phase 3: Shooting (投籃)
        # ============================================================
        desc_shoot, keep = self._run_shooting(off_team, def_team, ctx)
        return total_elapsed, desc_shoot, keep

    def _run_backcourt(self, off_team: EngineTeam, def_team: EngineTeam, is_opening: bool):
        """
        (Spec 3) 後場階段
        更新 v2.3: 實作速度總和判定的攻守轉換
        """
        bc_config = self.config.get('match_engine', {}).get('backcourt', {})
        params = bc_config.get('params', {})
        formulas = bc_config.get('formulas', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})

        # Calc Time
        off_sum = Calculator.get_team_attr_sum(off_team.on_court[:3], self._resolve_formula(formulas.get('off_sum', []), attr_pools), attr_pools)
        def_sum = Calculator.get_team_attr_sum(def_team.on_court[:3], self._resolve_formula(formulas.get('def_sum', []), attr_pools), attr_pools)
        
        if is_opening:
            final_time = params.get('opening_seconds', 2.0)
        else:
            base = rng.get_float(params.get('time_base_min', 1.0), params.get('time_base_max', 8.0))
            final_time = max(0.5, min(8.1, base + (def_sum - off_sum) * params.get('time_coeff', 0.008)))

        # Events
        if final_time > params.get('violation_threshold', 8.0):
            AttributionSystem.record_team_turnover(off_team)
            return final_time, 'turnover', f"{off_team.name} 8-sec Violation"
        
        # [Modified] 抄截判定
        if final_time > params.get('steal_threshold', 3.0):
            prob = params.get('steal_base_prob', 0.01) + (def_sum - off_sum) * params.get('steal_bonus_coeff', 0.001)
            
            if rng.decision(prob):
                stealer = AttributionSystem.determine_stealer(def_team, self.config)
                AttributionSystem.record_steal(stealer, off_team)
                
                # [New v2.4] 攻守轉換判定 (Transition Decision)
                # 1. 計算雙方全隊速度總和
                spd_formula = formulas.get('team_speed_sum', ['ath_speed'])
                off_spd_sum = Calculator.get_team_attr_sum(off_team.on_court, spd_formula, attr_pools)
                def_spd_sum = Calculator.get_team_attr_sum(def_team.on_court, spd_formula, attr_pools)
                
                # 2. 計算轉換機率
                # 公式: 50% + (守方總和 - 攻方總和) / 攻方總和
                base_prob = params.get('transition_base_prob', 0.50)
                ratio = 0.0
                if off_spd_sum > 0:
                    ratio = (def_spd_sum - off_spd_sum) / off_spd_sum
                
                transition_prob = base_prob + ratio
                
                # 3. 判定分支
                if rng.decision(transition_prob):
                    # 觸發快攻
                    return final_time, 'steal_fastbreak', f"{def_team.name} Steal & Fastbreak"
                else:
                    # 觸發陣地戰 (直接進前場)
                    return final_time, 'steal_frontcourt', f"{def_team.name} Steal & Transition"

        # [修正縮排] 快攻判定應與上方的抄截判定同層級
        if final_time < params.get('fastbreak_threshold', 1.0):
            return self._run_fastbreak(off_team, def_team, final_time)
        
        return final_time, 'frontcourt', "Advance"

    def _run_frontcourt(self, off_team: EngineTeam, def_team: EngineTeam, elapsed_bc: float):
        """(Spec 4) 前場"""
        fc_config = self.config.get('match_engine', {}).get('frontcourt', {})
        params = fc_config.get('params', {})
        formulas = fc_config.get('formulas', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})
        
        ctx = {'quality': 0.0, 'spacing': 0.0}
        
        # Time & Quality
        red_attr = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(formulas.get('time_reduction', []), attr_pools), attr_pools)
        reduction = (red_attr / 1000.0) * 0.5
        min_time = max(4.0, 4.0 - reduction)
        elapsed = rng.get_float(min_time, max(min_time+1, 24.0-elapsed_bc))
        if elapsed < 7.0: ctx['quality'] = (7.0 - elapsed) * 0.01
        
        # Spacing
        off_sp = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(formulas.get('spacing_off', []), attr_pools), attr_pools)
        def_sp = Calculator.get_team_attr_sum(def_team.on_court, self._resolve_formula(formulas.get('spacing_def', []), attr_pools), attr_pools) or 1
        sp_bonus = max(-1.0, min(1.0, (off_sp - def_sp)/def_sp + rng.get_float(-0.1, 0.1)))
        ctx['spacing'] = sp_bonus

        # Block (Spec 4.3)
        if sp_bonus <= 0.5:
            blk_prob = 0.01 + (0.05 if sp_bonus < 0 else 0)
            if rng.decision(blk_prob):
                # Block Success Check
                trigger_off_f = self._resolve_formula(formulas.get('block', {}).get('formulas', {}).get('trigger_off', []), attr_pools)
                trigger_def_f = self._resolve_formula(formulas.get('block', {}).get('formulas', {}).get('trigger_def', []), attr_pools)
                
                blocker = AttributionSystem.determine_rebounder(off_team, def_team, True, self.config) 
                shooter = AttributionSystem.determine_shooter(off_team, False, self.config) 
                
                AttributionSystem.record_block(blocker, shooter)
                return elapsed, 'turnover', f"{def_team.name} Block", ctx

        # Steal (Spec 4.4)
        stl_prob = 0.01
        if rng.decision(stl_prob):
            stealer = AttributionSystem.determine_stealer(def_team, self.config)
            AttributionSystem.record_steal(stealer, off_team)
            return elapsed, 'turnover', f"{def_team.name} Frontcourt Steal", ctx

        return elapsed, 'shooting', "Shot Attempt", ctx

    def _run_fastbreak(self, off_team: EngineTeam, def_team: EngineTeam, elapsed: float) -> Tuple[float, str, str]:
        """
        (Spec 3.5) 快攻
        [Phase 2] 整合 record_fastbreak_event
        """
        fb_config = self.config.get('match_engine', {}).get('backcourt', {}).get('fastbreak', {})
        formulas = fb_config.get('formulas', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})
        
        # 簡化實作: 隨機選人 (或可改為 Spec 邏輯)
        runner = off_team.on_court[0]
        chaser = def_team.on_court[0]
        
        # 成功率
        off_power = Calculator.get_player_attr_sum(runner, self._resolve_formula(formulas.get('off_power', []), attr_pools), attr_pools)
        def_power = Calculator.get_player_attr_sum(chaser, self._resolve_formula(formulas.get('def_power', []), attr_pools), attr_pools)
        
        success_prob = 0.5 + (off_power - def_power) * 0.005
        is_success = rng.decision(success_prob)
        
        # [Phase 2] 記錄快攻事件
        AttributionSystem.record_fastbreak_event(off_team, runner, is_success)
        
        if is_success:
            AttributionSystem.record_score(off_team, runner, 2, False)
            # [New] 更新 +/-
            AttributionSystem.update_plus_minus(off_team, def_team, 2)
            return elapsed, 'score', f"{off_team.name} {runner.name} Fastbreak Score"
        else:
            AttributionSystem.record_rebound(chaser, False)
            return elapsed, 'turnover', f"{off_team.name} {runner.name} Fastbreak Stopped by {chaser.name}"

    def _run_shooting(self, off_team: EngineTeam, def_team: EngineTeam, ctx: Dict) -> Tuple[str, bool]:
        """
        [Spec 5] 投籃結算
        """
        sht_config = self.config.get('match_engine', {}).get('shooting', {})
        params = sht_config.get('params', {})
        formulas = sht_config.get('formulas', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})

        # 1. Type (決定是 2分 或 3分)
        # 這部分涉及隨機判定，保留在 Core 中
        range_sum = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(formulas.get('range_attr', []), attr_pools), attr_pools) or 1
        threshold = 1.0 / (range_sum / 100.0)
        is_3pt = rng.get_float(0.0, 1.0) > threshold
        points = 3 if is_3pt else 2

        # 2. Shooter (決定出手者)
        shooter = AttributionSystem.determine_shooter(off_team, is_3pt, self.config)

        # 3. Hit Rate (命中率計算) - [Refactored] 完全呼叫 Calculator
        hit_rate = Calculator.calculate_shooting_rate(
          off_players=off_team.on_court,  # 進攻全隊 (用於對抗)
          def_players=def_team.on_court,  # 防守全隊 (用於對抗)
          shooter=shooter,                # 出手者 (用於技巧加成)
          config=self.config,
          spacing_factor=ctx.get('spacing', 0.0),
          quality_bonus=ctx.get('quality', 0.0),
          is_3pt=is_3pt
        )
        
        is_hit = rng.decision(hit_rate)

        # 4. Foul (犯規判定)
        off_iq = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(formulas.get('foul_off_iq', []), attr_pools), attr_pools)
        def_iq = Calculator.get_team_attr_sum(def_team.on_court, self._resolve_formula(formulas.get('foul_def_iq', []), attr_pools), attr_pools) or 1
        foul_prob = max(0.01, (off_iq - def_iq) / def_iq)
        is_foul = rng.decision(foul_prob)
        
        log = ""
        keep = False

        if is_hit:
            AttributionSystem.record_score(off_team, shooter, points, is_3pt)
            # [New] 更新 +/-
            AttributionSystem.update_plus_minus(off_team, def_team, points)
            
            log = f"{off_team.name} {shooter.name} {points}pt Good"
            
            # Assist
            ast_config = sht_config.get('assist', {})
            ast_formulas = ast_config.get('formulas', {})
            team_stat = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(ast_formulas.get('team_stat', []), attr_pools), attr_pools)
            luck_stat = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(ast_formulas.get('luck_stat', []), attr_pools), attr_pools) or 1
            
            ast_prob = (team_stat / (1.0/luck_stat)) * params.get('assist_prob_coeff', 0.1)
            
            if rng.decision(ast_prob):
                passer = AttributionSystem.determine_assist_provider(off_team, shooter, self.config)
                if passer:
                    AttributionSystem.record_assist(passer)
                    log += f" (Ast {passer.name})"
            
            if is_foul:
                fouler = rng.choice(def_team.on_court)
                AttributionSystem.record_foul(fouler)
                # [Update] 傳入 def_team 以計算 +/-
                self._run_free_throw(off_team, def_team, shooter, 1)
                log += " (And-1)"
                # [新增] 檢查是否犯滿離場
                self._check_and_handle_foul_out(def_team, fouler)
        else:
            AttributionSystem.record_attempt(shooter, is_3pt)
            log = f"{off_team.name} {shooter.name} {points}pt Miss"
            
            if is_foul:
                fouler = rng.choice(def_team.on_court)
                AttributionSystem.record_foul(fouler)
                ft_count = 3 if is_3pt else 2
                # [Update] 傳入 def_team 以計算 +/-
                made = self._run_free_throw(off_team, def_team, shooter, ft_count)
                log += f" (Foul {made}/{ft_count})"
                # [新增] 檢查是否犯滿離場
                self._check_and_handle_foul_out(def_team, fouler)
            else:
                # Rebound
                reb_config = sht_config.get('rebound', {})
                reb_formulas = reb_config.get('formulas', {})
                
                off_reb_attr = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(reb_formulas.get('off_attr', []), attr_pools), attr_pools)
                def_reb_attr = Calculator.get_team_attr_sum(def_team.on_court, self._resolve_formula(reb_formulas.get('def_attr', []), attr_pools), attr_pools)
                
                dr_prob = 0.10 + (def_reb_attr / (off_reb_attr + def_reb_attr or 1))
                
                if rng.decision(dr_prob):
                    rebounder = AttributionSystem.determine_rebounder(off_team, def_team, True, self.config)
                    AttributionSystem.record_rebound(rebounder, False)
                    log += f" (Reb {rebounder.name})"
                    keep = False
                else:
                    rebounder = AttributionSystem.determine_rebounder(off_team, def_team, False, self.config)
                    AttributionSystem.record_rebound(rebounder, True)
                    log += f" (Off Reb {rebounder.name})"
                    keep = True

        return log, keep

    def _run_free_throw(self, team: EngineTeam, def_team: EngineTeam, shooter: EnginePlayer, count: int) -> int:
        """
        [Update] 新增 def_team 參數以支援 +/- 計算
        """
        made = 0
        ft_config = self.config.get('match_engine', {}).get('shooting', {}).get('ft', {})
        params = ft_config.get('params', {})
        formulas = ft_config.get('formulas', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})
        
        base = rng.get_float(params.get('base_min', 0.40), params.get('base_max', 0.95))
        bonus_formula = self._resolve_formula(formulas.get('bonus_attrs', ['talent_luck', 'shot_touch']), attr_pools)
        attr_sum = Calculator.get_player_attr_sum(shooter, bonus_formula, attr_pools)
        
        prob = min(0.99, max(0.01, base + attr_sum * params.get('attr_coeff', 0.0001)))

        for _ in range(count):
            if rng.decision(prob):
                AttributionSystem.record_free_throw(team, shooter, True)
                # [New] 更新 +/-
                AttributionSystem.update_plus_minus(team, def_team, 1)
                made += 1
            else:
                AttributionSystem.record_free_throw(team, shooter, False)
        return made
    def _check_and_handle_foul_out(self, team: EngineTeam, player: EnginePlayer):
        """
         檢查並處理犯滿離場
        邏輯：
        1. 若犯規數達標，強制從 on_court 移除。
        2. 將該球員剩餘的 target_seconds 按比例分配給其他未犯滿球員。
        3. 從 bench 挑選替補上場。
        """
        # [Correction] 直接讀取 .fouls，避免 getattr 預設值 0 導致的邏輯失效
        # EnginePlayer 使用 __slots__，直接存取比 getattr 快且安全
        current_fouls = player.fouls
        
        if current_fouls >= self.foul_limit:
            player.is_fouled_out = True 
            self.pbp_logs.append(f"{team.name} {player.name} Fouled Out ({current_fouls})")
            
            # 1. 從場上移除
            if player in team.on_court:
                team.on_court.remove(player)
            
            # =================================================================
            # [新增邏輯] 時間重新分配 (Redistribute Minutes)
            # =================================================================
            # 計算該球員原本預計還要打多久
            remaining_seconds = max(0.0, player.target_seconds - player.seconds_played)
            
            # 將犯滿球員的目標時間鎖定為「已上場時間」，確保系統不再分配時間給他
            player.target_seconds = player.seconds_played
            
            if remaining_seconds > 0:
                # [修正] Spec 2.6 邏輯: C->PF->SF->SG->PG 各取前3名，共15個 slot
                # 排除已犯滿者
                valid_players = [p for p in (team.on_court + team.bench) if not p.is_fouled_out]
                
                if valid_players:
                    # 找出這 15 個 slot 的歸屬者
                    slots = []
                    positions = ["C", "PF", "SF", "SG", "PG"]
                    top_k = 3
                    
                    for pos in positions:
                        # 該位置評分前 K 名
                        sorted_by_pos = sorted(valid_players, key=lambda p: p.pos_scores.get(pos, 0), reverse=True)
                        slots.extend(sorted_by_pos[:top_k])
                    
                    # 平均分配給這些 slot
                    if slots:
                        time_per_slot = remaining_seconds / len(slots)
                        for receiver in slots:
                            receiver.target_seconds += time_per_slot
                        
                    # 記錄日誌以便除錯
                    # self.pbp_logs.append(f"Debug: Redistributed {remaining_seconds:.1f}s among {len(valid_recipients)} players")
            # =================================================================

            # 2. 尋找替補 (排除同樣犯滿的球員)
            candidates = [
                p for p in team.bench 
                if not p.is_fouled_out
            ]
            
            if not candidates:
                # 極端保護：若板凳全犯滿，強制讓原球員繼續打以防 Crash，並記錄警告
                # 注意：雖然前面把時間分配掉了，但為了不讓程式崩潰，還是得讓他上
                team.on_court.append(player)
                self.pbp_logs.append(f"WARNING: No available subs for {team.name}, {player.name} stays on court.")
                return

            # 3. 挑選最佳替補 (優先同位置，其次最高分)
            sub = None
            target_pos = getattr(player, 'position', 'C')
            
            pos_candidates = [p for p in candidates if p.pos_scores.get(target_pos, 0) > 0]
            if pos_candidates:
                sub = max(pos_candidates, key=lambda p: p.pos_scores.get(target_pos, 0))
            else:
                sub = max(candidates, key=lambda p: sum(p.pos_scores.values()))
            
            # 4. 執行替換
            team.bench.remove(sub)
            sub.position = target_pos # 繼承位置
            team.on_court.append(sub)
            
            # 將犯滿球員移至板凳
            team.bench.append(player)
            
            self.pbp_logs.append(f"Substitution: {sub.name} replaces {player.name} (Foul Out)")


============================================================

File: app\services\match_engine\service.py
------------------------------------------------------------
# app/services/match_engine/service.py


============================================================

File: app\services\match_engine\structures.py
------------------------------------------------------------
# app/services/match_engine/structures.py

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any

# [Optimization] 使用 slots=True
# 原理：Python 預設使用 __dict__ 字典儲存物件屬性，這會消耗大量記憶體。
# slots=True 告訴直譯器預先分配固定的記憶體空間給這些屬性。
# 效益：記憶體佔用減少約 40-50%，屬性存取速度提升約 20%。
# 對於 1 億場模擬 (涉及數十億次屬性讀取) 至關重要。

@dataclass(slots=True)
class EnginePlayer:
    """
    比賽引擎專用球員物件 (Level 4 - Phase 2 Ready)
    包含基本資訊、能力屬性、以及完整的比賽統計數據。
    """
    # --- 1. 識別與基本資訊 ---
    id: str
    name: str
    position: str  # 當前場上位置 (PG, SG, SF, PF, C)
    role: str      # 合約角色 (Star, Starter, etc.) - 用於計算上場時間權重
    grade: str     # 等級 (SSR, S, etc.) - 用於 Phase 2 數據分析
    height: float  # 身高 (cm)
    
    # --- 2. 體力系統 (Spec 2) ---
    current_stamina: float = 100.0
    stamina_coeff: float = 1.0  # 當前能力修正係數 (體力低於 80 開始衰退)
    
    # --- 3. 上場時間管理 (Spec 1.4 & 2.6) ---
    target_seconds: float = 0.0 # 目標上場秒數 (由 Minutes Distribution 計算)
    seconds_played: float = 0.0 # 已上場秒數
    is_fouled_out: bool = False # 是否犯滿離場
    
    # --- 4. 屬性緩存 (Spec 2.3) ---
    # 為了效能，我們將 DB 中的巢狀結構 (physical.strength) 展平為單層屬性。
    
    # 不可訓練屬性 (Untrainable)
    ath_stamina: float = 0.0
    ath_strength: float = 0.0
    ath_speed: float = 0.0
    ath_jump: float = 0.0
    talent_health: float = 0.0
    shot_touch: float = 0.0
    shot_release: float = 0.0
    talent_offiq: float = 0.0
    talent_defiq: float = 0.0
    talent_luck: float = 0.0
    
    # 可訓練屬性 (Trainable)
    shot_accuracy: float = 0.0
    shot_range: float = 0.0
    off_pass: float = 0.0
    off_dribble: float = 0.0
    off_handle: float = 0.0
    off_move: float = 0.0
    def_rebound: float = 0.0
    def_boxout: float = 0.0
    def_contest: float = 0.0
    def_disrupt: float = 0.0 # 抄截
    
    # 屬性總和 (用於 Phase 2 驗證 "能力與表現相關性")
    attr_sum: int = 0
    
    # --- 5. 位置評分緩存 (Spec 1.1) ---
    # 儲存該球員在 5 個位置的適性分數，避免重複計算
    pos_scores: Dict[str, float] = field(default_factory=dict)
    
    # --- 6. 統計數據 (Spec 7.2 Output Data) ---
    # 這些欄位將構成 Box Score，用於 Phase 2 的大數據分析
    
    # 基礎數據
    stat_pts: int = 0   # 得分
    stat_reb: int = 0   # 總籃板
    stat_ast: int = 0   # 助攻
    stat_stl: int = 0   # 抄截
    stat_blk: int = 0   # 阻攻
    stat_tov: int = 0   # 個人失誤
    fouls: int = 0      # 犯規次數
    stat_plus_minus: int = 0 # 正負值 (+/-)
    
    # 投籃細項
    stat_fgm: int = 0   # 投籃命中 (含2分與3分)
    stat_fga: int = 0   # 投籃出手
    stat_3pm: int = 0   # 三分命中
    stat_3pa: int = 0   # 三分出手
    stat_ftm: int = 0   # 罰球命中
    stat_fta: int = 0   # 罰球出手
    
    # 進階數據
    stat_orb: int = 0   # 進攻籃板
    stat_drb: int = 0   # 防守籃板
    
    # [Phase 2 新增] 快攻數據
    # 用於驗證 "速度" 屬性是否正確轉化為快攻得分
    stat_fb_made: int = 0    # 快攻進球數
    stat_fb_attempt: int = 0 # 快攻嘗試數
    
    # [Phase 2 新增] 體力分析
    # 記錄比賽結束時的剩餘體力，用於分析體力消耗與上場時間的關係
    stat_remaining_stamina: float = 0.0

@dataclass(slots=True)
class EngineTeam:
    """
    比賽引擎專用球隊物件
    """
    id: str
    name: str
    roster: List[EnginePlayer]
    
    # 動態陣容管理
    on_court: List[EnginePlayer] = field(default_factory=list) # 場上 5 人
    bench: List[EnginePlayer] = field(default_factory=list)    # 板凳球員
    best_five: List[Optional[EnginePlayer]] = field(default_factory=list) # 最強 5 人
    
    # 團隊統計 (Spec 7.3)
    score: int = 0
    stat_tov: int = 0 # 團隊失誤 (如 8秒違例)
    
    # [Phase 2 新增] 進階團隊數據
    stat_possessions: int = 0 # 回合數 (用於計算 Pace)
    stat_possession_seconds: float = 0.0 # 累積進攻時間 (秒)
    stat_possession_history: List[float] = field(default_factory=list) # 記錄每一回合的時間 (List)
    stat_fb_made: int = 0     # 團隊快攻進球
    stat_fb_attempt: int = 0  # 團隊快攻嘗試

@dataclass(slots=True)
class MatchState:
    """
    比賽狀態追蹤
    """
    quarter: int = 1
    time_remaining: float = 720.0
    game_time_elapsed: float = 0.0
    possession: str = "" # 當前擁有球權的球隊 ID
    is_over: bool = False
  
@dataclass(slots=True)
class MatchResult:
    """
    比賽結果輸出 (Spec 7.1)
    這是 Phase 2 數據分析的主要輸入來源。
    """
    game_id: str          # 唯一識別碼
    home_team_id: str
    away_team_id: str
    home_score: int
    away_score: int
    is_ot: bool           # 是否有延長賽
    total_quarters: int   # 總節數
    pbp_log: List[str]    # 文字轉播紀錄
    
    # [Phase 2 新增] 環境與節奏數據
    # 這些數據對於驗證 "比賽引擎是否符合現代籃球節奏" 至關重要
    pace: float = 0.0           # 節奏 (Possessions per 48 min)
    home_possessions: int = 0   # 主隊總回合數
    away_possessions: int = 0   # 客隊總回合數
    
    # 詳細的回合時間紀錄 (List)
    home_possession_history: List[float] = field(default_factory=list)
    away_possession_history: List[float] = field(default_factory=list)
    # 平均回合時間 (秒)
    home_avg_seconds_per_poss: float = 0.0
    away_avg_seconds_per_poss: float = 0.0
    
    # 快攻統計 (用於驗證 Phase 4.4 節奏與環境)
    home_fb_made: int = 0
    home_fb_attempt: int = 0
    away_fb_made: int = 0
    away_fb_attempt: int = 0
    
    # 註：快攻成功率 (Success Rate) 可在資料庫層級透過 made/attempt 計算，
    # 不需在此儲存浮點數，以節省空間。

============================================================

File: app\services\match_engine\systems\attribution.py
------------------------------------------------------------
# app/services/match_engine/systems/attribution.py

from typing import List, Optional, Tuple, Dict
from ..structures import EnginePlayer, EngineTeam
from ..utils.rng import rng

class AttributionSystem:
    """
    數據歸屬系統 (Level 3) - Config Driven
    對應 Spec v1.8 Section 6
    
    [Phase 2 Updates]
    - Added record_possession for Pace calculation.
    - Added record_fastbreak_event for Fastbreak Efficiency analysis.
    """

    @staticmethod
    def _get_val(player: EnginePlayer, attr_name: str) -> float:
        """取得經體力修正後的屬性值"""
        val = getattr(player, attr_name, 0.0)
        if attr_name == 'height': return val
        return val * player.stamina_coeff

    @staticmethod
    def _get_attrs_from_config(config: Dict, key: str) -> List[str]:
        """
        Helper: 解析 Config 中的屬性列表引用
        """
        me_config = config.get('match_engine', {})
        attr_pools = me_config.get('attr_pools', {})
        
        # 嘗試從 attribution.formulas 讀取 key
        formulas = me_config.get('attribution', {}).get('formulas', {})
        val = formulas.get(key)
        
        if isinstance(val, list):
            return val
        elif isinstance(val, str):
            # 若是字串，代表引用 attr_pools
            return attr_pools.get(val, [])
        return []

    @staticmethod
    def determine_shooter(team: EngineTeam, is_3pt_attempt: bool, config: Dict) -> EnginePlayer:
        """
        [Spec 6.1] 決定投籃出手者
        """
        candidates = team.on_court
        weights = []
        total_weight = 0.0
        
        me_config = config.get('match_engine', {})
        attr_params = me_config.get('attribution', {}).get('params', {})

        # 1. 讀取屬性列表
        base_attrs = AttributionSystem._get_attrs_from_config(config, 'shot_weight_base')
        bonus_3pt_attrs = AttributionSystem._get_attrs_from_config(config, 'shot_3pt_bonus')
        
        # 2. 讀取加成係數
        star_bonus = attr_params.get('shot_star_bonus', 1.5)
        starter_bonus = attr_params.get('shot_starter_bonus', 1.2)

        for p in candidates:
            # 基礎權重
            w = sum(AttributionSystem._get_val(p, a) for a in base_attrs)

            # 3分球特殊加成
            if is_3pt_attempt:
                w += sum(AttributionSystem._get_val(p, a) for a in bonus_3pt_attrs)

            # 戰術加成
            role = getattr(p, 'role', 'Bench')
            if role == 'Star': w *= star_bonus
            elif role == 'Starter': w *= starter_bonus
            
            weights.append((p, w))
            total_weight += w

        # 分配邏輯: 權重佔比最小者優先 (Spec 6.1)
        # 註：此處維持原邏輯，若需優化可改為累積機率
        weights.sort(key=lambda x: x[1])
        r = rng.get_float(0.0, 1.0)
        current_prob = 0.0
        
        if total_weight == 0: return candidates[0]

        for p, w in weights:
            prob = w / total_weight
            current_prob += prob
            if r <= current_prob: return p
        return weights[-1][0]

    @staticmethod
    def determine_rebounder(off_team: EngineTeam, def_team: EngineTeam, is_defensive: bool, config: Dict) -> EnginePlayer:
        """
        [Spec 6.3] 決定籃板球歸屬
        """
        candidates = def_team.on_court if is_defensive else off_team.on_court
        weights = []
        total_weight = 0.0
        
        me_config = config.get('match_engine', {})
        attr_params = me_config.get('attribution', {}).get('params', {})
        
        # 讀取參數
        base_attrs = AttributionSystem._get_attrs_from_config(config, 'rebound_base')
        bonus_attrs = AttributionSystem._get_attrs_from_config(config, 'rebound_bonus')
        iq_off_attrs = AttributionSystem._get_attrs_from_config(config, 'rebound_iq_off')
        iq_def_attrs = AttributionSystem._get_attrs_from_config(config, 'rebound_iq_def')
        
        height_weight = attr_params.get('rebound_height_weight', 1.5)

        for p in candidates:
            # 通用屬性
            w = sum(AttributionSystem._get_val(p, a) for a in base_attrs)
            
            # 加權屬性 (包含身高)
            w += sum(AttributionSystem._get_val(p, a) for a in bonus_attrs) * height_weight
            w += AttributionSystem._get_val(p, 'height') * height_weight

            # 智商屬性
            if is_defensive:
                w += sum(AttributionSystem._get_val(p, a) for a in iq_def_attrs)
            else:
                w += sum(AttributionSystem._get_val(p, a) for a in iq_off_attrs)
            
            weights.append((p, w))
            total_weight += w

        weights.sort(key=lambda x: x[1])
        r = rng.get_float(0.0, 1.0)
        current_prob = 0.0
        
        if total_weight == 0: return candidates[0]

        for p, w in weights:
            prob = w / total_weight
            current_prob += prob
            if r <= current_prob: return p
        return weights[-1][0]

    @staticmethod
    def determine_assist_provider(off_team: EngineTeam, shooter: EnginePlayer, config: Dict) -> Optional[EnginePlayer]:
        """
        [Spec 6.4] 決定助攻者
        """
        candidates = [p for p in off_team.on_court if p.id != shooter.id]
        if not candidates: return None

        weights = []
        total_weight = 0.0
        
        # 讀取權重屬性
        assist_attrs = AttributionSystem._get_attrs_from_config(config, 'assist_weight')

        for p in candidates:
            w = sum(AttributionSystem._get_val(p, a) for a in assist_attrs)
            weights.append((p, w))
            total_weight += w
        
        # 判定順序: C -> PF -> SF -> SG -> PG
        pos_order_list = config.get('match_engine', {}).get('general', {}).get('substitution', {}).get('redistribution', {}).get('positions', ["C", "PF", "SF", "SG", "PG"])
        pos_order_map = {pos: idx for idx, pos in enumerate(pos_order_list)}
        
        weights.sort(key=lambda x: pos_order_map.get(x[0].position, -1))

        r = rng.get_float(0.0, 1.0)
        current_prob = 0.0
        
        if total_weight == 0: return candidates[-1]

        for p, w in weights:
            prob = w / total_weight
            current_prob += prob
            if r <= current_prob: return p
        return weights[-1][0]

    @staticmethod
    def determine_stealer(def_team: EngineTeam, config: Dict) -> EnginePlayer:
        """
        [Spec 6.5] 決定抄截者
        """
        candidates = def_team.on_court
        weights = []
        total_weight = 0.0
        
        steal_attrs = AttributionSystem._get_attrs_from_config(config, 'steal_weight')

        for p in candidates:
            w = sum(AttributionSystem._get_val(p, a) for a in steal_attrs)
            weights.append((p, w))
            total_weight += w
        
        r = rng.get_float(0.0, 1.0) * total_weight
        upto = 0.0
        for p, w in weights:
            if upto + w >= r: return p
            upto += w
      
        return candidates[-1]

    # =========================================================================
    # Recording Methods (Aligned with MatchEngine Core)
    # =========================================================================

    @staticmethod
    def get_position_matchup(target_player: EnginePlayer, opponent_team: EngineTeam) -> EnginePlayer:
        """Helper: 尋找對位球員"""
        target_pos = target_player.position
        for p in opponent_team.on_court:
            if p.position == target_pos: return p
        return opponent_team.on_court[0]

    @staticmethod
    def update_plus_minus(scoring_team: EngineTeam, defending_team: EngineTeam, points: int):
        """
        [New] 更新場上球員正負值 (+/-)
        """
        if points == 0: return
        
        for p in scoring_team.on_court:
            p.stat_plus_minus += points
        
        for p in defending_team.on_court:
            p.stat_plus_minus -= points

    @staticmethod
    def record_possession_time(team: EngineTeam, seconds: float):
        """
        [Modified] 記錄回合消耗時間
        1. 累加總時間 (stat_possession_seconds)
        2. 記錄單次時間 (stat_possession_history)
        """
        team.stat_possession_seconds += seconds      # 累加總時間
        team.stat_possession_history.append(seconds) # 記錄詳細歷史

    @staticmethod
    def record_attempt(player: EnginePlayer, is_3pt: bool):
        """記錄出手"""
        player.stat_fga += 1
        if is_3pt: player.stat_3pa += 1

    @staticmethod
    def record_score(team: EngineTeam, scorer: EnginePlayer, points: int, is_3pt: bool, assister: Optional[EnginePlayer] = None):
        """
        記錄得分 (進球)
        """
        # 1. 團隊得分
        team.score += points
        
        # 2. 個人得分
        scorer.stat_pts += points
        
        # 3. 命中數
        scorer.stat_fgm += 1
        if is_3pt: 
            scorer.stat_3pm += 1
        
        # 4. 出手數 (進球也算一次出手)
        scorer.stat_fga += 1
        if is_3pt:
            scorer.stat_3pa += 1

        # 5. 助攻
        if assister: 
            assister.stat_ast += 1

    @staticmethod
    def record_assist(passer: EnginePlayer):
        """記錄助攻 (Core 獨立呼叫)"""
        passer.stat_ast += 1

    @staticmethod
    def record_rebound(player: EnginePlayer, is_offensive: bool):
        """記錄籃板"""
        player.stat_reb += 1
        if is_offensive: player.stat_orb += 1
        else: player.stat_drb += 1

    @staticmethod
    def record_steal(stealer: EnginePlayer, victim_team: EngineTeam):
        """記錄抄截"""
        stealer.stat_stl += 1
        # 尋找受害者記錄失誤
        victim = AttributionSystem.get_position_matchup(stealer, victim_team)
        victim.stat_tov += 1

    @staticmethod
    def record_block(blocker: EnginePlayer, shooter: EnginePlayer):
        """記錄封阻"""
        blocker.stat_blk += 1
        # 籃球規則: 被蓋火鍋算一次出手 (FGA)
        shooter.stat_fga += 1

    @staticmethod
    def record_team_turnover(team: EngineTeam):
        """記錄團隊失誤"""
        if hasattr(team, 'stat_tov'): team.stat_tov += 1

    @staticmethod
    def record_foul(player: EnginePlayer):
        """記錄犯規"""
        player.fouls += 1

    @staticmethod
    def record_free_throw(team: EngineTeam, player: EnginePlayer, made: bool):
        """記錄罰球"""
        player.stat_fta += 1
        if made:
            player.stat_ftm += 1
            player.stat_pts += 1
            team.score += 1 

    # =========================================================================
    # Phase 2 New Recording Methods
    # =========================================================================

    @staticmethod
    def record_possession(team: EngineTeam):
        """
        [Phase 2] 記錄回合數
        用於計算 Pace (Possessions per 48 min)。
        應在每次球權轉換 (得分、失誤、防守籃板) 時呼叫。
        """
        team.stat_possessions += 1

    @staticmethod
    def record_fastbreak_event(team: EngineTeam, player: EnginePlayer, made: bool):
        """
        [Phase 2] 記錄快攻事件
        用於驗證速度屬性與快攻效率的相關性。
        不論進球與否，都應記錄嘗試次數。
        """
        # 記錄嘗試
        team.stat_fb_attempt += 1
        player.stat_fb_attempt += 1
        
        # 記錄進球
        if made:
            team.stat_fb_made += 1
            player.stat_fb_made += 1

============================================================

File: app\services\match_engine\systems\play_logic.py
------------------------------------------------------------
# app/services/match_engine/systems/play_logic.py


============================================================

File: app\services\match_engine\systems\stamina.py
------------------------------------------------------------
# app/services/match_engine/systems/stamina.py

from typing import Dict, List
from ..structures import EnginePlayer

class StaminaSystem:
    """
    體力系統 (Level 3) - Config Driven
    完全依賴傳入的 config 字典進行計算，不寫死任何係數。
    對應 Spec v1.5 Section 2 & v2.1 (Rest Updates)
    """

    @staticmethod
    def update_stamina(player: EnginePlayer, seconds: float, is_on_court: bool, config: Dict):
        """
        更新球員體力 (消耗或恢復)。
        """
        # 1. 讀取設定參數
        me_config = config.get('match_engine', {})
        gen_config = me_config.get('general', {})
        sys_config = me_config.get('stamina_system', {})
        
        # 取得屬性名稱
        drain_attrs = sys_config.get('drain_attrs', ['ath_stamina', 'talent_health'])
        
        # 取得係數
        drain_coeff = gen_config.get('stamina_drain_coeff', 3.0)
        
        # 2. 取得球員屬性並轉為百分比 (0.01 ~ 0.99)
        stamina_val = getattr(player, drain_attrs[0], 50)
        health_val = getattr(player, drain_attrs[1], 50)
        
        stamina_pct = max(0.01, min(0.99, stamina_val / 100.0))
        health_pct = max(0.01, min(0.99, health_val / 100.0))

        change_per_minute = 0.0

        if is_on_court:
            # [Spec 2.3] 消耗公式
            # 消耗量/分 = Coeff * [1 + (1 - 體能%)] + (1 - 健康%)
            # 這裡省略了年齡修正，若需完整實作需補上 Age 參數讀取
            drain_per_min = drain_coeff * (1.0 + (1.0 - stamina_pct)) + (1.0 - health_pct)
            change_per_minute = -drain_per_min
        else:
            # [Spec 2.4] 恢復公式
            # 恢復量/分 = 1.0 + (體能%) - (1 - 健康%)
            base_recover = 1.0 
            recover_per_min = base_recover + stamina_pct - (1.0 - health_pct)
            change_per_minute = recover_per_min

        # 3. 應用變更
        change = (change_per_minute / 60.0) * seconds
        new_val = player.current_stamina + change
        
        # 限制範圍
        if new_val > 100.0: new_val = 100.0
        elif new_val < 1.0: new_val = 1.0
        
        player.current_stamina = new_val

        # 4. 更新修正係數
        StaminaSystem._update_coefficient(player, gen_config)

    @staticmethod
    def _update_coefficient(player: EnginePlayer, gen_config: Dict):
        """
        [Spec 2.2] 能力值動態修正
        """
        threshold = gen_config.get('stamina_nerf_threshold', 80.0)
        min_multiplier = gen_config.get('stamina_min_multiplier', 0.21)
        
        current = player.current_stamina

        if current >= threshold:
            player.stamina_coeff = 1.0
        elif current > 1.0:
            # 線性衰退
            penalty = (threshold - current) * 0.01
            player.stamina_coeff = 1.0 - penalty
        else:
            # 極限狀態
            player.stamina_coeff = min_multiplier

    @staticmethod
    def apply_rest(team_players: List[EnginePlayer], minutes: float, config: Dict):
        """
        [Spec 2.4 New] 應用休息時間 (中場或節間)
        邏輯：將休息時間視為「在板凳上休息」，調用 update_stamina 進行恢復。
        """
        seconds = minutes * 60.0
        for player in team_players:
            # 強制視為下場休息 (is_on_court=False)
            StaminaSystem.update_stamina(player, seconds, False, config)

============================================================

File: app\services\match_engine\systems\substitution.py
------------------------------------------------------------
# app/services/match_engine/systems/substitution.py

from typing import List, Optional, Dict, Set
from ..structures import EngineTeam, EnginePlayer

class SubstitutionSystem:
    """
    換人系統 (Level 3) - Config Driven
    對應 Spec v1.5 Section 2.5 & 2.6
    修正: 統一使用秒 (seconds) 進行時間比較。
    """

    @staticmethod
    def check_auto_substitution(team: EngineTeam, quarter: int, time_remaining: float, config: Dict) -> List[str]:
        """
        [Spec 2.5] 常規換人檢查
        """
        logs = []
        
        # 讀取 Config
        sub_config = config.get('match_engine', {}).get('general', {}).get('substitution', {})
        fatigue_threshold = sub_config.get('stamina_threshold', 80.0)
        
        to_sub_out = []
        
        for player in team.on_court:
            reason = None
            # 條件 1: 體力過低
            if player.current_stamina < fatigue_threshold:
                reason = "體力低"
            
            # 條件 2: 時間已到 (容許 1 分鐘緩衝)
            elif (player.seconds_played > player.target_seconds + 60.0):
                reason = "時間到"

            if reason:
                to_sub_out.append((player, reason))
        
        for p_out, reason in to_sub_out:
            p_in = SubstitutionSystem._pick_bench_player(team, p_out.position, p_out.current_stamina)
            
            if p_in:
                SubstitutionSystem.execute_sub(team, p_out, p_in)
                logs.append(f"{team.name} 換人: {p_in.name} 替換 {p_out.name} ({reason})")
        
        return logs

    @staticmethod
    def handle_fouled_out(team: EngineTeam, fouled_player: EnginePlayer, config: Dict) -> str:
        """
        [Spec 2.6] 處理犯滿離場與時間重分配
        """
        fouled_player.is_fouled_out = True
        
        # 計算剩餘時間 [Fix] 使用 seconds
        remaining_seconds = max(0.0, fouled_player.target_seconds - fouled_player.seconds_played)
        fouled_player.target_seconds = fouled_player.seconds_played 
        
        # 時間重分配
        if remaining_seconds > 0:
            # 讀取重分配設定
            redis_config = config.get('match_engine', {}).get('general', {}).get('substitution', {}).get('redistribution', {})
            SubstitutionSystem._redistribute_minutes(team, remaining_seconds, redis_config)

        # 強制換人
        p_in = SubstitutionSystem._pick_best_available(team, fouled_player.position)
        
        if p_in:
            SubstitutionSystem.execute_sub(team, fouled_player, p_in)
            return f"{fouled_player.name} 犯滿離場(剩餘{remaining_seconds:.1f}分已分配)，由 {p_in.name} 接替"
        else:
            return f"{fouled_player.name} 犯滿離場，板凳無可用之兵！"

    @staticmethod
    def _redistribute_minutes(team: EngineTeam, minutes: float, redis_config: Dict):
        """
        [Spec 2.6] 分配邏輯
        """
        # 從 Config 讀取順序與數量
        positions_order = redis_config.get('positions', ["C", "PF", "SF", "SG", "PG"])
        top_k = redis_config.get('top_k', 3)
        
        all_players = team.on_court + team.bench
        targets = []
        
        for pos in positions_order:
            valid_players = [p for p in all_players if not p.is_fouled_out]
            # 排序依據該位置分數
            valid_players.sort(key=lambda p: p.pos_scores.get(pos, 0), reverse=True)
            targets.extend(valid_players[:top_k])
        
        # 分配時間 (總份數 = 位置數 * Top_K)
        total_slots = len(positions_order) * top_k
        if total_slots > 0:
            unit_time = minutes / float(total_slots)
            for p in targets:
                p.target_minutes += unit_time

    @staticmethod
    def execute_sub(team: EngineTeam, p_out: EnginePlayer, p_in: EnginePlayer):
        """執行換人"""
        if p_out in team.on_court:
            team.on_court.remove(p_out)
            team.bench.append(p_out)
        
        if p_in in team.bench:
            team.bench.remove(p_in)
            team.on_court.append(p_in)
        elif p_in not in team.on_court:
            # 防呆: 如果 p_in 既不在 bench 也不在 on_court (理論上不應發生)
            team.on_court.append(p_in)

    @staticmethod
    def _pick_bench_player(team: EngineTeam, target_position: str, current_stamina_threshold: float) -> Optional[EnginePlayer]:
        """常規替補選擇"""
        candidates = [
            p for p in team.bench 
            if not p.is_fouled_out 
            and p.current_stamina > current_stamina_threshold
            and p.seconds_played < p.target_seconds
        ]
        if not candidates: return None
        candidates.sort(key=lambda p: p.pos_scores.get(target_position, 0), reverse=True)
        return candidates[0]

    @staticmethod
    def _pick_best_available(team: EngineTeam, target_position: str) -> Optional[EnginePlayer]:
        """緊急替補選擇"""
        candidates = [p for p in team.bench if not p.is_fouled_out]
        if not candidates: return None
        candidates.sort(key=lambda p: p.pos_scores.get(target_position, 0), reverse=True)
        return candidates[0]
    
    @staticmethod
    def enforce_best_lineup(team: EngineTeam, config: Dict) -> List[str]:
        """
        [Spec 2.5 Revised] 關鍵時刻強制調度 (Clutch Override)
        邏輯：
        1. 以賽前決定的 Best 5 為基礎。
        2. 若 Best 5 有人犯滿，則依據該位置評分順序，選出下一位可用球員遞補。
        3. 確保遞補者不是「其他位置的 Best 5 成員」(避免挖東牆補西牆)。
        4. 強制換人。
        """
        logs = []
        
        # 1. 取得基礎 Best 5 (對應索引 0:C, 1:PF, 2:SF, 3:SG, 4:PG)
        # 注意: 這裡必須複製一份 list，避免修改到原始的 team.best_five
        if not team.best_five: return logs
        
        target_lineup = list(team.best_five) 
        positions_order = ["C", "PF", "SF", "SG", "PG"]
        
        # 2. 建立「已鎖定名單」集合
        # 先將 Best 5 中「未犯滿」的球員鎖定，確保他們不會被當作替補去補別的位置
        locked_ids: Set[str] = {p.id for p in target_lineup if not p.is_fouled_out}
        
        # 3. 檢查並修復陣容 (填補犯滿缺口)
        for i, player in enumerate(target_lineup):
            if player.is_fouled_out:
                target_pos = positions_order[i]
                
                # 尋找替補：
                # 條件 A: 未犯滿
                # 條件 B: 不在 locked_ids 中 (不是其他位置的主力)
                candidates = [
                    p for p in team.roster 
                    if not p.is_fouled_out and p.id not in locked_ids
                ]
                
                # 排序：依據該位置 (target_pos) 的評分由高至低
                candidates.sort(key=lambda p: p.pos_scores.get(target_pos, 0), reverse=True)
                
                if candidates:
                    replacement = candidates[0]
                    target_lineup[i] = replacement
                    locked_ids.add(replacement.id) # 鎖定這位替補，避免他被重複選用
                    # logs.append(f"Debug: {team.name} {target_pos} 由 {replacement.name} 遞補 (原: {player.name} 犯滿)")
                else:
                    # 極端情況：全隊都犯滿或無人可用，保持原樣 (避免程式崩潰)
                    pass

        # 4. 執行換人 (Diff & Swap)
        # 比較 target_lineup 與 team.on_court
        
        # 找出「該上場但不在場上」的球員 (In)
        current_court_ids = {p.id for p in team.on_court}
        players_in = [p for p in target_lineup if p.id not in current_court_ids]
        
        # 找出「在場上但不該上場」的球員 (Out)
        target_ids = {p.id for p in target_lineup}
        players_out = [p for p in team.on_court if p.id not in target_ids]
        
        # 執行替換 (一進一出)
        # 由於人數一定相等 (都是5人)，直接配對替換
        for p_in, p_out in zip(players_in, players_out):
            SubstitutionSystem.execute_sub(team, p_out, p_in)
            
            # 設定上場球員的位置 (依照他在 target_lineup 中的索引決定)
            # 找出 p_in 在 target_lineup 的 index 以決定位置
            idx = target_lineup.index(p_in)
            p_in.position = positions_order[idx]
            
            logs.append(f"{team.name} 關鍵時刻調度: {p_in.name} ({p_in.position}) 替換 {p_out.name}")
        
        return logs

============================================================

File: app\services\match_engine\utils\calculator.py
------------------------------------------------------------
# app/services/match_engine/utils/calculator.py

from typing import List, Dict, Optional, Union
from ..structures import EnginePlayer

class Calculator:
    """
    通用公式計算器 (Level 2)。
    修正: 
    1. 移除 Python 內寫死的 ALL_ATTRIBUTE_NAMES。
    2. 支援遞迴解析 attr_pools，實現真正的 Config Driven。
    3. 投籃公式正確讀取 spacing_weight。
    4. 同步 Spec v2.2 技巧加成 (Skill Bonus) 邏輯。
    5. calculate_shooting_rate 支援 3分球特殊邏輯 (Multiplier & Base Rate)。
    """

    @staticmethod
    def _resolve_formula_keys(formula: Union[str, List[str]], attr_pools: Dict) -> List[str]:
        """Helper: 解析 Config 中的屬性列表引用"""
        if isinstance(formula, str):
            return attr_pools.get(formula, [])
        return formula

    @staticmethod
    def get_player_attr_sum(player: EnginePlayer, attrs: List[str], attr_pools: Optional[Dict[str, List[str]]] = None) -> float:
        """
        計算球員指定屬性列表的總和。
        
        Args:
            player: 球員物件
            attrs: 屬性名稱列表 (可包含 pool key)
            attr_pools: 屬性池字典 (用於遞迴展開 pool key)
        """
        total = 0.0
        coeff = player.stamina_coeff

        for attr in attrs:
            is_negative = False
            clean_attr = attr
            
            # 處理負號語法 (如 '-height')
            if attr.startswith('-'):
                is_negative = True
                clean_attr = attr[1:]

            # 1. 嘗試直接從球員取得屬性
            if hasattr(player, clean_attr):
                val = getattr(player, clean_attr)
                
                # 體力修正: 只有數值型屬性才乘係數 (height 不乘)
                if clean_attr != 'height':
                    val *= coeff
                
                if is_negative:
                    total -= val
                else:
                    total += val
            
            # 2. 若球員無此屬性，檢查是否為 Pool Key (遞迴展開)
            elif attr_pools and clean_attr in attr_pools:
                # 遞迴呼叫: 傳入 pool 定義的列表
                sub_total = Calculator.get_player_attr_sum(player, attr_pools[clean_attr], attr_pools)
                
                if is_negative:
                    total -= sub_total
                else:
                    total += sub_total
        
        return total

    @staticmethod
    def get_team_attr_sum(players: List[EnginePlayer], attrs: List[str], attr_pools: Optional[Dict[str, List[str]]] = None) -> float:
        """計算一組球員的屬性總和"""
        return sum(Calculator.get_player_attr_sum(p, attrs, attr_pools) for p in players)

    @staticmethod
    def calculate_shooting_rate(
        off_players: List[EnginePlayer], # [Fix] 改為傳入進攻全隊
        def_players: List[EnginePlayer],
        shooter: EnginePlayer,           # [Fix] 新增參數：出手者 (用於技巧加成)
        config: Dict,
        spacing_factor: float = 0.0,
        quality_bonus: float = 0.0,
        is_3pt: bool = False
    ) -> float:
        """
        [Spec 5.1 & 5.2] 投籃命中率計算 (修正版)
        邏輯:
          - 對抗 (Off_Total vs Def_Total): 使用 Team Sum vs Team Sum
          - 技巧 (Skill Bonus): 使用 Shooter Individual Stats
        """
        # 1. 導航 Config
        me_config = config.get('match_engine', {})
        shooting_config = me_config.get('shooting', {})
        formulas = shooting_config.get('formulas', {})
        params = shooting_config.get('params', {})
        attr_pools = me_config.get('attr_pools', {})

        # 2. 決定基礎命中率 (Base Rate)
        base_rate = params.get('base_rate_3pt', 0.20) if is_3pt else params.get('base_rate_2pt', 0.40)

        # 3. 計算進攻總值 (Offensive Rating) - [Fix] 使用 get_team_attr_sum
        base_off_keys = Calculator._resolve_formula_keys(formulas.get('off_total', 'off_13'), attr_pools)
        off_sum = Calculator.get_team_attr_sum(off_players, base_off_keys, attr_pools)

        if is_3pt:
            # [Spec 5.2.A] 3分球特殊加成 (也是看團隊)
            bonus_keys = Calculator._resolve_formula_keys(formulas.get('bonus_3pt_attrs', []), attr_pools)
            bonus_sum = Calculator.get_team_attr_sum(off_players, bonus_keys, attr_pools)
            mult = params.get('multiplier_3pt', 2.0)
            off_sum += bonus_sum * (mult - 1.0)

        # 4. 計算防守總值 (Defensive Rating)
        def_keys = Calculator._resolve_formula_keys(formulas.get('def_total', 'def_12'), attr_pools)
        def_sum = Calculator.get_team_attr_sum(def_players, def_keys, attr_pools)
        if def_sum == 0: def_sum = 1

        # 5. 計算技巧加成 (Skill Bonus) - [Fix] 針對 shooter 個人計算
        skill_keys = Calculator._resolve_formula_keys(formulas.get('skill_bonus_attrs', ['shot_accuracy', 'shot_range', 'off_move']), attr_pools)
        skill_sum = Calculator.get_player_attr_sum(shooter, skill_keys, attr_pools)
        skill_divisor = params.get('skill_bonus_divisor', 800.0)
        skill_multiplier = 1.0 + (skill_sum / skill_divisor)

        # 6. 最終公式計算
        stat_diff = (off_sum - def_sum) / def_sum
        spacing_weight = params.get('spacing_weight', 0.1)
        
        final_rate = (base_rate + stat_diff) * skill_multiplier * (1.0 + spacing_factor * spacing_weight) * (1.0 + quality_bonus)
        
        return max(0.01, min(0.99, final_rate))

============================================================

File: app\services\match_engine\utils\rng.py
------------------------------------------------------------
# app/services/match_engine/utils/rng.py
import random
from typing import List, Any, Optional

# [Optimization] 將方法綁定移至模組層級 (Module Level)
# 這避免了在 Python 3.13+ 中，將綁定方法(Bound Method)指派給類別屬性時可能發生的參數傳遞錯誤。
# 同時保留了減少屬性查找(Attribute Lookup)的效能優勢。
_sys_random = random.random
_sys_uniform = random.uniform
_sys_choice = random.choice

class RNG:
    """
    極致效能優化版的隨機數生成器。
    針對「單次、高頻率」呼叫場景優化 (Event-Driven Simulation)。
    """
    __slots__ = () # 節省記憶體
    
    # 如果未來需要固定 Seed，可以在這裡實作初始化
    @classmethod
    def seed(cls, seed_val: Any):
        random.seed(seed_val)

    @staticmethod
    def get_float(min_val: float = 0.0, max_val: float = 1.0) -> float:
        """
        回傳 [min_val, max_val] 之間的浮點數。
        """
        # 直接呼叫模組層級的別名，避免類別屬性查找的開銷與綁定問題
        return _sys_uniform(min_val, max_val)

    @staticmethod
    def decision(probability: float) -> bool:
        """
        判定事件是否發生。
        probability: 0.0 ~ 1.0
        """
        # 優化：減少邊界檢查，假設呼叫端會傳入合法數值
        return _sys_random() < probability

    @staticmethod
    def choice(items: List[Any]) -> Any:
        """
        從列表中選擇一個項目。
        """
        return _sys_choice(items)

    @staticmethod
    def weighted_index(weights: List[float]) -> int:
        """
        根據權重回傳索引值。
        這是效能瓶頸點，Python 原生迴圈較慢。
        如果 weights 長度固定且很短 (如 5個位置)，這段 Python code 夠快。
        """
        r = _sys_random() * sum(weights)
        upto = 0.0
        for i, w in enumerate(weights):
            if w + upto >= r:
                return i
            upto += w
        return len(weights) - 1

# 為了方便其他模組呼叫，直接暴露實例或類別
rng = RNG

============================================================

