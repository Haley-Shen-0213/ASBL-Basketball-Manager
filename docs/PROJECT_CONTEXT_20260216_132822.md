# 

# ASBL Basketball Manager - å°ˆæ¡ˆå…¨æ™¯å¿«ç…§

- **ç”Ÿæˆæ™‚é–“**: 2026-02-16 13:28:22
- **å°ˆæ¡ˆè·¯å¾‘**: `D:\ASBL-Basketball-Manager`
- **åŒ…å«æ ¼å¼**: `.css, .env, .html, .js, .json, .jsx, .md, .py, .scss, .sql, .ts, .tsx, .yaml, .yml`
- **å¼·åˆ¶åŒ…å«**: `Dockerfile, Procfile, requirements.txt`
- **æª”æ¡ˆç¸½æ•¸**: 66

## 1. å°ˆæ¡ˆçµæ§‹æ¨¹ (Project Tree)

```text
ASBL-Basketball-Manager/
â”œâ”€ app/
â”‚  â”œâ”€ models/
â”‚  â”‚  â”œâ”€ __init__.py
â”‚  â”‚  â”œâ”€ contract.py
â”‚  â”‚  â”œâ”€ match.py
â”‚  â”‚  â”œâ”€ player.py
â”‚  â”‚  â”œâ”€ system.py
â”‚  â”‚  â”œâ”€ team.py
â”‚  â”‚  â””â”€ user.py
â”‚  â”œâ”€ routes/
â”‚  â”‚  â”œâ”€ __init__.py
â”‚  â”‚  â”œâ”€ auth.py
â”‚  â”‚  â”œâ”€ game.py
â”‚  â”‚  â””â”€ team.py
â”‚  â”œâ”€ services/
â”‚  â”‚  â”œâ”€ match_engine/
â”‚  â”‚  â”‚  â”œâ”€ systems/
â”‚  â”‚  â”‚  â”‚  â”œâ”€ __init__.py
â”‚  â”‚  â”‚  â”‚  â”œâ”€ attribution.py
â”‚  â”‚  â”‚  â”‚  â”œâ”€ play_logic.py
â”‚  â”‚  â”‚  â”‚  â”œâ”€ stamina.py
â”‚  â”‚  â”‚  â”‚  â””â”€ substitution.py
â”‚  â”‚  â”‚  â”œâ”€ utils/
â”‚  â”‚  â”‚  â”‚  â”œâ”€ __init__.py
â”‚  â”‚  â”‚  â”‚  â”œâ”€ calculator.py
â”‚  â”‚  â”‚  â”‚  â””â”€ rng.py
â”‚  â”‚  â”‚  â”œâ”€ __init__.py
â”‚  â”‚  â”‚  â”œâ”€ core.py
â”‚  â”‚  â”‚  â”œâ”€ service.py
â”‚  â”‚  â”‚  â””â”€ structures.py
â”‚  â”‚  â”œâ”€ __init__.py
â”‚  â”‚  â”œâ”€ player_generator.py
â”‚  â”‚  â””â”€ team_creator.py
â”‚  â”œâ”€ templates/
â”‚  â”œâ”€ utils/
â”‚  â”‚  â””â”€ game_config_loader.py
â”‚  â””â”€ __init__.py
â”œâ”€ config/
â”‚  â””â”€ game_config.yaml
â”œâ”€ frontend/
â”‚  â”œâ”€ src/
â”‚  â”‚  â”œâ”€ assets/
â”‚  â”‚  â”œâ”€ App.css
â”‚  â”‚  â”œâ”€ App.tsx
â”‚  â”‚  â”œâ”€ index.css
â”‚  â”‚  â””â”€ main.tsx
â”‚  â”œâ”€ eslint.config.js
â”‚  â”œâ”€ index.html
â”‚  â”œâ”€ package.json
â”‚  â”œâ”€ postcss.config.js
â”‚  â”œâ”€ README.md
â”‚  â”œâ”€ tailwind.config.js
â”‚  â”œâ”€ tsconfig.app.json
â”‚  â”œâ”€ tsconfig.json
â”‚  â”œâ”€ tsconfig.node.json
â”‚  â””â”€ vite.config.ts
â”œâ”€ scripts/
â”‚  â”œâ”€ utils/
â”‚  â”‚  â”œâ”€ project_exporter.py
â”‚  â”‚  â””â”€ tree.py
â”‚  â”œâ”€ __init__.py
â”‚  â”œâ”€ init_db.py
â”‚  â””â”€ terminal.py
â”œâ”€ tests/
â”‚  â”œâ”€ match_bigdata_test/
â”‚  â”‚  â”œâ”€ team/
â”‚  â”‚  â””â”€ run_core_bigdata_test.py
â”‚  â”œâ”€ player_generator_big_data/
â”‚  â”‚  â”œâ”€ analyzer.py
â”‚  â”‚  â”œâ”€ check_data_integrity.py
â”‚  â”‚  â”œâ”€ run_test.py
â”‚  â”‚  â””â”€ test_config.yaml
â”‚  â”œâ”€ team_bigdata_test/
â”‚  â”‚  â”œâ”€ manual_merge.py
â”‚  â”‚  â””â”€ run_simulation.py
â”‚  â””â”€ __init__.py
â”œâ”€ tools/
â”‚  â””â”€ code_merger.py
â”œâ”€ ASBL_Database_Schema.md
â”œâ”€ ASBL_League_Simulation_Design.md
â”œâ”€ ASBL_Match_Engine_Specification.md
â”œâ”€ ASBL_Player_System_Specification.md
â”œâ”€ config.py
â”œâ”€ DEV_LOG.md
â”œâ”€ README.md
â”œâ”€ requirements.txt
â””â”€ run.py
```

---

## 2. æª”æ¡ˆå…§å®¹è©³æƒ… (File Contents)

### ğŸ“„ File: `app\models\__init__.py`

```python
# app/models/__init__.py
from app.models.user import User
from app.models.team import Team
from app.models.player import Player, PlayerGrowthLog
from app.models.contract import Contract
from app.models.system import NameLibrary

# é€™è£¡ä¸éœ€åŒ¯å‡º matchï¼Œå› ç‚ºç›®å‰ match.py æ˜¯ç©ºçš„ï¼Œä¸”æˆ‘å€‘ä½¿ç”¨ Parquet å­˜æ¯”è³½ç´€éŒ„
```

---

### ğŸ“„ File: `app\models\contract.py`

```python
# app/models/contract.py
from app import db

class Contract(db.Model):
    __tablename__ = 'contracts'
    __table_args__ = {'comment': 'çƒå“¡åˆç´„è³‡æ–™è¡¨'}

    id = db.Column(db.Integer, primary_key=True)
    
    player_id = db.Column(db.Integer, db.ForeignKey('players.id'), nullable=False, unique=True, comment='çƒå“¡ID')
    team_id = db.Column(db.Integer, db.ForeignKey('teams.id'), nullable=False, comment='çƒéšŠID(å†—é¤˜)')
    
    salary = db.Column(db.Integer, nullable=False, comment='è³½å­£è–ªè³‡')
    years = db.Column(db.Integer, default=1, comment='ç¸½åˆç´„å¹´é™')
    years_left = db.Column(db.Integer, default=1, comment='å‰©é¤˜å¹´é™')
    
    # è§’è‰²å®šä½ (Star, Starter, Rotation, Role, Bench)
    role = db.Column(db.String(20), nullable=False, default='Bench', comment='è§’è‰²å®šä½')

    # çƒéšŠ/çƒå“¡é¸é … (Team/Player Option)
    option_type = db.Column(db.String(10), nullable=True, comment='é¸é …é¡å‹(PO/TO)') 

    created_at = db.Column(db.DateTime, server_default=db.func.now())
    updated_at = db.Column(db.DateTime, server_default=db.func.now(), onupdate=db.func.now())

    def __repr__(self):
        return f'<Contract Player:{self.player_id} ${self.salary} ({self.role})>'
```

---

### ğŸ“„ File: `app\models\match.py`

```python
# app/models/match.py
```

---

### ğŸ“„ File: `app\models\player.py`

```python
# app/models/player.py
from app import db
from sqlalchemy import JSON

class Player(db.Model):
    __tablename__ = 'players'
    __table_args__ = {'comment': 'çƒå“¡æ ¸å¿ƒè³‡æ–™è¡¨'}

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), nullable=False)
    
    # åœ‹ç±/èªç³»
    nationality = db.Column(db.String(16), nullable=False, default='zh', comment='çƒå“¡åœ‹ç±/èªç³»')

    age = db.Column(db.Integer, default=18)
    height = db.Column(db.Integer, nullable=False, comment='èº«é«˜(cm)')
    position = db.Column(db.String(10), nullable=False, comment='è¨»å†Šä½ç½®')
    
    # è¨“ç·´é»æ•¸
    training_points = db.Column(db.Integer, default=0, nullable=False, comment='å¯ç”¨è¨“ç·´é»æ•¸')

    # [æ–°å¢] åœ¨é€™è£¡åŠ å…¥ grade æ¬„ä½
    grade = db.Column(db.String(5), nullable=False, default='G', comment='çƒå“¡ç­‰ç´š (SSR/SS/S...)')
    
    # ç¶œåˆè©•åƒ¹ (Rating)
    rating = db.Column(db.Integer, comment='ç¶œåˆè©•åƒ¹åˆ†æ•¸')

    # [Schema 2.3] æ•¸æ“šæ¬„ä½
    detailed_stats = db.Column(JSON, nullable=False, comment='ç•¶å‰èƒ½åŠ›å€¼') 
    initial_stats = db.Column(JSON, nullable=True, comment='åˆå§‹/å·”å³°èƒ½åŠ›å€¼(è€åŒ–åƒè€ƒ)')

    # é—œè¯
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    team_id = db.Column(db.Integer, db.ForeignKey('teams.id'), nullable=True)

    created_at = db.Column(db.DateTime, server_default=db.func.now())
    updated_at = db.Column(db.DateTime, server_default=db.func.now(), onupdate=db.func.now())
    
    # é—œè¯è¨­å®š
    contract = db.relationship('Contract', backref='player', uselist=False, cascade="all, delete-orphan")
    growth_logs = db.relationship('PlayerGrowthLog', backref='player', lazy='dynamic', cascade="all, delete-orphan")

    def __repr__(self):
        return f'<Player {self.name} ({self.nationality})>'

class PlayerGrowthLog(db.Model):
    """
    [Schema 2.5] çƒå“¡æˆé•·/è€åŒ–ç´€éŒ„
    è¨˜éŒ„æ¯ä¸€å­£æˆ–æ¯æ¬¡è¨“ç·´çš„æ•¸å€¼è®Šå‹•ã€‚
    """
    __tablename__ = 'player_growth_logs'
    __table_args__ = {'comment': 'çƒå“¡æˆé•·èˆ‡è€åŒ–æ­·ç¨‹'}

    id = db.Column(db.Integer, primary_key=True)
    player_id = db.Column(db.Integer, db.ForeignKey('players.id'), nullable=False)
    
    season_id = db.Column(db.Integer, nullable=False, comment='ç™¼ç”Ÿè³½å­£')
    event_type = db.Column(db.String(20), nullable=False, comment='é¡å‹: AGE_DECLINE, TRAINING')
    
    # è¨˜éŒ„è®Šå‹•é‡ï¼Œä¾‹å¦‚ {"speed": -2, "strength": -1}
    change_delta = db.Column(JSON, nullable=False, comment='æ•¸å€¼è®ŠåŒ–é‡')
    
    created_at = db.Column(db.DateTime, server_default=db.func.now())

    def __repr__(self):
        return f'<GrowthLog P:{self.player_id} {self.event_type}>'
```

---

### ğŸ“„ File: `app\models\system.py`

```python
# app/models/system.py
from app import db
from sqlalchemy import Computed

class NameLibrary(db.Model):
    __tablename__ = 'system_name_library'
    __table_args__ = (
        db.UniqueConstraint('language', 'content', name='uq_lang_content'),
        db.Index('idx_lang_cat_weight', 'language', 'category', 'weight'),
        {'comment': '[ç³»çµ±] å¤šåœ‹èªç³»å§“åè©åº«'}
    )

    id = db.Column(db.Integer, primary_key=True, comment='å”¯ä¸€è­˜åˆ¥ç¢¼')
    
    # èªç³»ä»£ç¢¼ (en, zh, ja, tw_aboriginal...)
    language = db.Column(db.String(16), nullable=False, comment='èªç³»ä»£ç¢¼')
    
    # é¡åˆ¥ (surname, given_name, template) - é›–ç„¶ç­–ç•¥Aä¸åˆ†ï¼Œä½†è³‡æ–™åº«çµæ§‹ä»éœ€ä¿ç•™
    category = db.Column(db.String(16), nullable=False, comment='é¡åˆ¥')
    
    # å…§å®¹ (ä¸­æ–‡éŸ³è­¯æˆ–åŸæ–‡)
    content = db.Column(db.String(64), nullable=False, comment='å…§å®¹')
    
    # å…§å®¹å­—æ•¸ (å°æ‡‰ SQL çš„ GENERATED ALWAYS AS)
    # SQLAlchemy å¯ç”¨ Computed æ˜ å°„ï¼Œæˆ–å–®ç´”è¦–ç‚ºç”± DB ç®¡ç†çš„æ¬„ä½
    length = db.Column(db.Integer, Computed('char_length(content)'), comment='å…§å®¹å­—æ•¸')
    
    # æ¬Šé‡
    weight = db.Column(db.Integer, nullable=False, default=10, comment='å‡ºç¾æ¬Šé‡')

    def __repr__(self):
        return f'<NameLib {self.language}.{self.category}: {self.content}>'
```

---

### ğŸ“„ File: `app\models\team.py`

```python
# app/models/team.py
from app import db

class Team(db.Model):
    __tablename__ = 'teams'
    __table_args__ = {'comment': 'çƒéšŠè³‡æ–™è¡¨'}

    id = db.Column(db.Integer, primary_key=True, comment='çƒéšŠ ID (ä¸»éµ)')
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), unique=True, nullable=False, comment='æ‰€å±¬ä½¿ç”¨è€… ID')
    name = db.Column(db.String(64), nullable=False, comment='çƒéšŠåç¨±')
    
    # ç¶“ç‡Ÿè³‡è¨Š
    funds = db.Column(db.BigInteger, default=300000, comment='çƒéšŠè³‡é‡‘')
    reputation = db.Column(db.Integer, default=0, comment='çƒéšŠè²æœ›')
    
    # [æ–°å¢] å ´é¤¨èˆ‡ç²‰çµ²åœ˜
    arena_name = db.Column(db.String(64), nullable=True, comment='å ´é¤¨åç¨±')
    fanpage_name = db.Column(db.String(64), nullable=True, comment='ç²‰çµ²åœ˜åç¨±')
    
    # [æ–°å¢] çƒæ¢
    scout_chances = db.Column(db.Integer, default=100, nullable=False, comment='å‰©é¤˜çƒæ¢æ¬¡æ•¸')
    
    # [æ–°å¢] æˆ°ç¸¾å¿«å– (ç”¨æ–¼ Dashboard å¿«é€Ÿé¡¯ç¤º)
    season_wins = db.Column(db.Integer, default=0, comment='æœ¬å­£å‹å ´')
    season_losses = db.Column(db.Integer, default=0, comment='æœ¬å­£æ•—å ´')
    
    # é—œè¯
    players = db.relationship('Player', backref='team', lazy='dynamic')
    contracts = db.relationship('Contract', backref='team', lazy='dynamic')

    def __repr__(self):
        return f'<Team {self.name}>'
```

---

### ğŸ“„ File: `app\models\user.py`

```python
# app/models/user.py
from app import db
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash

class User(db.Model):
    __tablename__ = 'users'
    __table_args__ = {'comment': 'ä½¿ç”¨è€…å¸³è™Ÿè³‡æ–™è¡¨'}

    id = db.Column(db.Integer, primary_key=True, comment='ä½¿ç”¨è€… ID (ä¸»éµ)')
    username = db.Column(db.String(64), index=True, unique=True, nullable=False, comment='ä½¿ç”¨è€…åç¨±')
    email = db.Column(db.String(120), index=True, unique=True, nullable=False, comment='é›»å­ä¿¡ç®±')
    password_hash = db.Column(db.String(256), comment='å¯†ç¢¼é›œæ¹Šå€¼')
    created_at = db.Column(db.DateTime, default=datetime.utcnow, comment='å¸³è™Ÿå»ºç«‹æ™‚é–“')
    
    # [æ–°å¢] è¨˜éŒ„æœ€å¾Œç™»å…¥æ™‚é–“ï¼Œç”¨æ–¼è¨ˆç®—æ´»èºäººæ•¸
    last_login = db.Column(db.DateTime, default=datetime.utcnow, comment='æœ€å¾Œç™»å…¥æ™‚é–“')
    
    # é—œè¯ï¼šä½¿ç”¨å­—ä¸² 'Team' é¿å…å¾ªç’°å¼•ç”¨
    team = db.relationship('Team', backref='owner', uselist=False)

    def set_password(self, password):
        """å°‡æ˜æ–‡å¯†ç¢¼åŠ å¯†å¾Œå­˜å…¥"""
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        """é©—è­‰å¯†ç¢¼æ˜¯å¦æ­£ç¢º"""
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f'<User {self.username}>'
```

---

### ğŸ“„ File: `app\routes\__init__.py`

```python
# app/routes/__init__.py
from flask import Blueprint, jsonify
from datetime import datetime, timedelta
from app.models.user import User
from app.utils.game_config_loader import GameConfigLoader # [æ–°å¢]

# å®šç¾© 'main' Blueprint
main = Blueprint('main', __name__)

@main.route('/')
def index():
    """API å¥åº·æª¢æŸ¥ç«¯é»"""
    return jsonify({
        "status": "online",
        "message": "ASBL Basketball Manager API is running",
        "version": "v1.0"
    })

@main.route('/api/system/stats', methods=['GET'])
def system_stats():
    """
    [æ–°å¢] å–å¾—ç³»çµ±çµ±è¨ˆæ•¸æ“š
    å›å‚³:
        total_users: ç¸½è¨»å†Šäººæ•¸
        active_users: éå» N å¤©å…§æœ‰ç™»å…¥çš„ä½¿ç”¨è€… (N ç”± config å®šç¾©)
    """
    try:
        # å¾ Config è®€å–æ´»èºåˆ¤å®šå¤©æ•¸ï¼Œé è¨­ 7 å¤©
        active_days = GameConfigLoader.get('system.active_user_threshold_days', 7)
        
        # è¨ˆç®— N å¤©å‰çš„æ™‚é–“é»
        threshold_date = datetime.utcnow() - timedelta(days=active_days)
        
        # æŸ¥è©¢ç¸½äººæ•¸
        total_count = User.query.count()
        
        # æŸ¥è©¢æ´»èºäººæ•¸ (last_login >= Nå¤©å‰)
        active_count = User.query.filter(User.last_login >= threshold_date).count()
        
        return jsonify({
            "total_users": total_count,
            "active_users": active_count,
            "active_threshold_days": active_days # å¯é¸ï¼šå›å‚³åˆ¤å®šæ¨™æº–ä¾›å‰ç«¯åƒè€ƒ
        })
    except Exception as e:
        return jsonify({
            "error": str(e),
            "total_users": 0,
            "active_users": 0
        }), 500
```

---

### ğŸ“„ File: `app\routes\auth.py`

```python
# app/routes/auth.py
from flask import Blueprint, request, jsonify
from datetime import datetime
from app import db
from app.models.user import User
from app.models.team import Team
from app.services.team_creator import TeamCreator
from app.services.player_generator import PlayerGenerator
from app.utils.game_config_loader import GameConfigLoader # [æ–°å¢]

auth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')

@auth_bp.route('/register', methods=['POST'])
def register():
    data = request.get_json()
    
    # 1. æª¢æŸ¥å¿…è¦æ¬„ä½
    if not data or not data.get('username') or not data.get('email') or not data.get('password'):
        return jsonify({'error': 'è«‹æä¾›ä½¿ç”¨è€…åç¨±ã€Email å’Œå¯†ç¢¼'}), 400

    if User.query.filter_by(username=data['username']).first():
        return jsonify({'error': 'ä½¿ç”¨è€…åç¨±å·²è¢«ä½¿ç”¨'}), 400
    if User.query.filter_by(email=data['email']).first():
        return jsonify({'error': 'Email å·²è¢«è¨»å†Š'}), 400

    try:
        # 2. å»ºç«‹ä½¿ç”¨è€…
        user = User(username=data['username'], email=data['email'])
        user.set_password(data['password'])
        user.last_login = datetime.utcnow()
        
        db.session.add(user)
        db.session.flush() # å–å¾— user.id
        
        # 3. è®€å–åˆå§‹åŒ–è¨­å®š
        init_settings = GameConfigLoader.get('system.initial_team_settings', {})
        init_funds = init_settings.get('funds', 300000)
        init_rep = init_settings.get('reputation', 0)
        init_scout = init_settings.get('scout_chances', 100)
        
        # 4. è¨­å®šçƒéšŠåç¨± (é è¨­ç‚º Team_{ID})
        # è¦å‰‡: åˆå§‹åŒ–çš„å…§å®¹ï¼ŒçƒéšŠåç¨±=å ´é¤¨åç¨±=ç²‰çµ²åœ˜
        default_name = f"Team_{user.id}"
        team_name = data.get('team_name') or default_name
        
        team = Team(
            name=team_name, 
            owner=user,
            funds=init_funds,
            reputation=init_rep,
            arena_name=team_name,    # åŒæ­¥è¨­å®š
            fanpage_name=team_name,  # åŒæ­¥è¨­å®š
            scout_chances=init_scout
        )
        db.session.add(team)
        db.session.flush() # å–å¾— team.id

        # 5. ç”Ÿæˆåˆå§‹ 15 äººåå–®
        PlayerGenerator.initialize_class()
        
        # [ä¿®æ”¹] max_attempts æ¡é è¨­å€¼ (100è¬æ¬¡)ï¼Œè‹¥å¤±æ•—æœƒæ‹‹å‡º Exception
        roster_payloads = TeamCreator.create_valid_roster()
        
        for p_data in roster_payloads:
            PlayerGenerator.save_to_db(p_data, user_id=user.id, team_id=team.id)

        db.session.commit()
        
        return jsonify({
            'message': 'è¨»å†ŠæˆåŠŸï¼çƒéšŠèˆ‡åˆå§‹çƒå“¡å·²å»ºç«‹ã€‚',
            'user_id': user.id,
            'team_id': team.id,
            'team_name': team.name,
            'roster_count': len(roster_payloads)
        }), 201
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': f'è¨»å†Šå¤±æ•—: {str(e)}'}), 500

@auth_bp.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    
    if not data or not data.get('username') or not data.get('password'):
        return jsonify({'error': 'è«‹æä¾›å¸³è™Ÿå¯†ç¢¼'}), 400

    user = User.query.filter_by(username=data['username']).first()

    if user and user.check_password(data['password']):
        user.last_login = datetime.utcnow()
        db.session.commit()

        return jsonify({
            'message': 'ç™»å…¥æˆåŠŸ',
            'user_id': user.id,
            'username': user.username,
            'team_id': user.team.id if user.team else None
        }), 200
    else:
        return jsonify({'error': 'å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤'}), 401
```

---

### ğŸ“„ File: `app\routes\game.py`

```python
# app/routes/game.py
from flask import Blueprint, jsonify, request
# [ä¿®æ­£] Team å®šç¾©åœ¨ app.models.team
from app.models.team import Team 
from app.services.match_engine.core import MatchEngine
from app.services.match_engine.service import DBToEngineAdapter
from app.utils.game_config_loader import GameConfigLoader
import dataclasses

game_bp = Blueprint('game', __name__, url_prefix='/api/game')

@game_bp.route('/simulate', methods=['POST'])
def simulate_match():
    """
    åŸ·è¡Œå–®å ´æ¯”è³½æ¨¡æ“¬
    Payload: { "home_team_id": 1, "away_team_id": 2 }
    """
    data = request.get_json()
    home_id = data.get('home_team_id')
    away_id = data.get('away_team_id')

    if not home_id or not away_id:
        return jsonify({'error': 'éœ€è¦æä¾›ä¸»å®¢éšŠ ID'}), 400

    # 1. æ’ˆå–è³‡æ–™
    home_db = Team.query.get_or_404(home_id)
    away_db = Team.query.get_or_404(away_id)

    # 2. è½‰æ›æ¨¡å‹
    home_engine = DBToEngineAdapter.convert_team(home_db)
    away_engine = DBToEngineAdapter.convert_team(away_db)

    # 3. è¼‰å…¥è¨­å®š
    config = GameConfigLoader.load()

    # 4. åŸ·è¡Œæ¨¡æ“¬
    import time
    game_id = f"SIM_{int(time.time())}"
    
    engine = MatchEngine(home_engine, away_engine, config, game_id=game_id)
    result = engine.simulate()

    # 5. å›å‚³çµæœ
    response = {
        "game_id": result.game_id,
        "home_team": home_db.name,
        "away_team": away_db.name,
        "home_score": result.home_score,
        "away_score": result.away_score,
        "is_ot": result.is_ot,
        "pace": result.pace,
        "logs": result.pbp_log,
        "box_score": []
    }
    
    for p in home_engine.roster + away_engine.roster:
        if p.seconds_played > 0:
            response['box_score'].append({
                "id": p.id,
                "name": p.name,
                "team_id": home_id if p in home_engine.roster else away_id,
                "pts": p.stat_pts,
                "reb": p.stat_reb,
                "ast": p.stat_ast,
                "stl": p.stat_stl,
                "blk": p.stat_blk,
                "min": round(p.seconds_played / 60, 1)
            })

    return jsonify(response)
```

---

### ğŸ“„ File: `app\routes\team.py`

```python
# app/routes/team.py
from flask import Blueprint, jsonify, request
from sqlalchemy import func
from app import db
from app.models.team import Team
from app.models.user import User
from app.models.player import Player
from app.services.match_engine.service import DBToEngineAdapter
from app.utils.game_config_loader import GameConfigLoader

team_bp = Blueprint('team', __name__, url_prefix='/api/team')

@team_bp.route('/<int:team_id>/dashboard', methods=['GET'])
def get_team_dashboard(team_id):
    """
    [æ–°å¢] å–å¾— Dashboard æ‰€éœ€çš„å®Œæ•´è³‡è¨Š
    åŒ…å«: åŸºæœ¬è³‡è¨Šã€çƒå“¡äººæ•¸ã€æˆ°ç¸¾æ’å
    """
    team = Team.query.get_or_404(team_id)
    
    # 1. è®€å– Config
    roster_limit = GameConfigLoader.get('system.initial_team_settings.roster_limit', 40)
    
    # 2. è¨ˆç®—çƒå“¡äººæ•¸
    player_count = team.players.count()
    
    # 3. è¨ˆç®—æ’å (ç°¡æ˜“ç‰ˆï¼šä¾å‹å ´æ•¸ > è²æœ› æ’åº)
    # å¯¦éš›å°ˆæ¡ˆæ‡‰æœ‰ League Tableï¼Œæ­¤è™•ä½¿ç”¨å³æ™‚æŸ¥è©¢æ¨¡æ“¬
    # æŸ¥è©¢æœ‰å¤šå°‘éšŠä¼çš„ (wins, reputation) æ¯”æˆ‘é«˜
    better_teams = Team.query.filter(
        (Team.season_wins > team.season_wins) | 
        ((Team.season_wins == team.season_wins) & (Team.reputation > team.reputation))
    ).count()
    rank = better_teams + 1
    total_teams = Team.query.count()
    
    return jsonify({
        'id': team.id,
        'name': team.name,
        'funds': team.funds,
        'reputation': team.reputation,
        'arena_name': team.arena_name,
        'fanpage_name': team.fanpage_name,
        'scout_chances': team.scout_chances,
        'player_count': player_count,
        'roster_limit': roster_limit,
        'season_wins': team.season_wins,
        'season_losses': team.season_losses,
        'rank': rank,
        'total_teams': total_teams,
        'owner': team.owner.username
    })

@team_bp.route('/<int:team_id>/roster', methods=['GET'])
def get_team_roster(team_id):
    """å–å¾—çƒéšŠçš„å®Œæ•´çƒå“¡åå–® (åŒ…å«è©³ç´°å±¬æ€§)"""
    team = Team.query.get_or_404(team_id)
    
    engine_team = DBToEngineAdapter.convert_team(team)
    
    roster_data = []
    for p in engine_team.roster:
        player_dict = {
            'id': p.id,
            'name': p.name,
            'nationality': p.nationality,
            'position': p.position,
            'role': p.role,
            'grade': p.grade,
            'height': p.height,
            'age': p.age,
            'rating': p.attr_sum,
            'stats': {
                'physical': {
                    'stamina': p.ath_stamina,
                    'strength': p.ath_strength,
                    'speed': p.ath_speed,
                    'jump': p.ath_jump,
                    'health': p.talent_health
                },
                'offense': {
                    'touch': p.shot_touch,
                    'release': p.shot_release,
                    'accuracy': p.shot_accuracy,
                    'range': p.shot_range,
                    'pass': p.off_pass,
                    'dribble': p.off_dribble,
                    'handle': p.off_handle,
                    'move': p.off_move
                },
                'defense': {
                    'rebound': p.def_rebound,
                    'boxout': p.def_boxout,
                    'contest': p.def_contest,
                    'disrupt': p.def_disrupt
                },
                'mental': {
                    'off_iq': p.talent_offiq,
                    'def_iq': p.talent_defiq,
                    'luck': p.talent_luck
                }
            }
        }
        roster_data.append(player_dict)

    return jsonify(roster_data)

@team_bp.route('/my', methods=['POST'])
def get_my_team():
    data = request.get_json()
    user_id = data.get('user_id')
    
    if not user_id:
        return jsonify({'error': 'Missing user_id'}), 400
        
    user = User.query.get(user_id)
    if not user or not user.team:
        return jsonify({'error': 'Team not found'}), 404
        
    return jsonify({
        'team_id': user.team.id,
        'team_name': user.team.name
    })
```

---

### ğŸ“„ File: `app\services\match_engine\systems\__init__.py`

```python
```

---

### ğŸ“„ File: `app\services\match_engine\systems\attribution.py`

```python
# app/services/match_engine/systems/attribution.py

from typing import List, Optional, Tuple, Dict
from ..structures import EnginePlayer, EngineTeam
from ..utils.rng import rng

class AttributionSystem:
    """
    æ•¸æ“šæ­¸å±¬ç³»çµ± (Level 3) - Config Driven
    å°æ‡‰ Spec v1.8 Section 6
    
    [Phase 2 Updates]
    - Added record_possession for Pace calculation.
    - Added record_fastbreak_event for Fastbreak Efficiency analysis.
    """

    @staticmethod
    def _get_val(player: EnginePlayer, attr_name: str) -> float:
        """å–å¾—ç¶“é«”åŠ›ä¿®æ­£å¾Œçš„å±¬æ€§å€¼"""
        val = getattr(player, attr_name, 0.0)
        if attr_name == 'height': return val
        return val * player.stamina_coeff

    @staticmethod
    def _get_attrs_from_config(config: Dict, key: str) -> List[str]:
        """
        Helper: è§£æ Config ä¸­çš„å±¬æ€§åˆ—è¡¨å¼•ç”¨
        """
        me_config = config.get('match_engine', {})
        attr_pools = me_config.get('attr_pools', {})
        
        # å˜—è©¦å¾ attribution.formulas è®€å– key
        formulas = me_config.get('attribution', {}).get('formulas', {})
        val = formulas.get(key)
        
        if isinstance(val, list):
            return val
        elif isinstance(val, str):
            # è‹¥æ˜¯å­—ä¸²ï¼Œä»£è¡¨å¼•ç”¨ attr_pools
            return attr_pools.get(val, [])
        return []

    @staticmethod
    def determine_shooter(team: EngineTeam, is_3pt_attempt: bool, config: Dict) -> EnginePlayer:
        """
        [Spec 6.1] æ±ºå®šæŠ•ç±ƒå‡ºæ‰‹è€…
        """
        candidates = team.on_court
        weights = []
        total_weight = 0.0
        
        me_config = config.get('match_engine', {})
        attr_params = me_config.get('attribution', {}).get('params', {})

        # 1. è®€å–å±¬æ€§åˆ—è¡¨
        base_attrs = AttributionSystem._get_attrs_from_config(config, 'shot_weight_base')
        bonus_3pt_attrs = AttributionSystem._get_attrs_from_config(config, 'shot_3pt_bonus')
        
        # 2. è®€å–åŠ æˆä¿‚æ•¸
        star_bonus = attr_params.get('shot_star_bonus', 1.5)
        starter_bonus = attr_params.get('shot_starter_bonus', 1.2)

        for p in candidates:
            # åŸºç¤æ¬Šé‡
            w = sum(AttributionSystem._get_val(p, a) for a in base_attrs)

            # 3åˆ†çƒç‰¹æ®ŠåŠ æˆ
            if is_3pt_attempt:
                w += sum(AttributionSystem._get_val(p, a) for a in bonus_3pt_attrs)

            # æˆ°è¡“åŠ æˆ
            role = getattr(p, 'role', 'Bench')
            if role == 'Star': w *= star_bonus
            elif role == 'Starter': w *= starter_bonus
            
            weights.append((p, w))
            total_weight += w

        # åˆ†é…é‚è¼¯: æ¬Šé‡ä½”æ¯”æœ€å°è€…å„ªå…ˆ (Spec 6.1)
        # è¨»ï¼šæ­¤è™•ç¶­æŒåŸé‚è¼¯ï¼Œè‹¥éœ€å„ªåŒ–å¯æ”¹ç‚ºç´¯ç©æ©Ÿç‡
        weights.sort(key=lambda x: x[1])
        r = rng.get_float(0.0, 1.0)
        current_prob = 0.0
        
        if total_weight == 0: return candidates[0]

        for p, w in weights:
            prob = w / total_weight
            current_prob += prob
            if r <= current_prob: return p
        return weights[-1][0]

    @staticmethod
    def determine_rebounder(off_team: EngineTeam, def_team: EngineTeam, is_defensive: bool, config: Dict) -> EnginePlayer:
        """
        [Spec 6.3] æ±ºå®šç±ƒæ¿çƒæ­¸å±¬
        """
        candidates = def_team.on_court if is_defensive else off_team.on_court
        weights = []
        total_weight = 0.0
        
        me_config = config.get('match_engine', {})
        attr_params = me_config.get('attribution', {}).get('params', {})
        
        # è®€å–åƒæ•¸
        base_attrs = AttributionSystem._get_attrs_from_config(config, 'rebound_base')
        bonus_attrs = AttributionSystem._get_attrs_from_config(config, 'rebound_bonus')
        iq_off_attrs = AttributionSystem._get_attrs_from_config(config, 'rebound_iq_off')
        iq_def_attrs = AttributionSystem._get_attrs_from_config(config, 'rebound_iq_def')
        
        height_weight = attr_params.get('rebound_height_weight', 1.5)

        for p in candidates:
            # é€šç”¨å±¬æ€§
            w = sum(AttributionSystem._get_val(p, a) for a in base_attrs)
            
            # åŠ æ¬Šå±¬æ€§ (åŒ…å«èº«é«˜)
            w += sum(AttributionSystem._get_val(p, a) for a in bonus_attrs) * height_weight
            w += AttributionSystem._get_val(p, 'height') * height_weight

            # æ™ºå•†å±¬æ€§
            if is_defensive:
                w += sum(AttributionSystem._get_val(p, a) for a in iq_def_attrs)
            else:
                w += sum(AttributionSystem._get_val(p, a) for a in iq_off_attrs)
            
            weights.append((p, w))
            total_weight += w

        weights.sort(key=lambda x: x[1])
        r = rng.get_float(0.0, 1.0)
        current_prob = 0.0
        
        if total_weight == 0: return candidates[0]

        for p, w in weights:
            prob = w / total_weight
            current_prob += prob
            if r <= current_prob: return p
        return weights[-1][0]

    @staticmethod
    def determine_assist_provider(off_team: EngineTeam, shooter: EnginePlayer, config: Dict) -> Optional[EnginePlayer]:
        """
        [Spec 6.4] æ±ºå®šåŠ©æ”»è€…
        """
        candidates = [p for p in off_team.on_court if p.id != shooter.id]
        if not candidates: return None

        weights = []
        total_weight = 0.0
        
        # è®€å–æ¬Šé‡å±¬æ€§
        assist_attrs = AttributionSystem._get_attrs_from_config(config, 'assist_weight')

        for p in candidates:
            w = sum(AttributionSystem._get_val(p, a) for a in assist_attrs)
            weights.append((p, w))
            total_weight += w
        
        # åˆ¤å®šé †åº: C -> PF -> SF -> SG -> PG
        pos_order_list = config.get('match_engine', {}).get('general', {}).get('substitution', {}).get('redistribution', {}).get('positions', ["C", "PF", "SF", "SG", "PG"])
        pos_order_map = {pos: idx for idx, pos in enumerate(pos_order_list)}
        
        weights.sort(key=lambda x: pos_order_map.get(x[0].position, -1))

        r = rng.get_float(0.0, 1.0)
        current_prob = 0.0
        
        if total_weight == 0: return candidates[-1]

        for p, w in weights:
            prob = w / total_weight
            current_prob += prob
            if r <= current_prob: return p
        return weights[-1][0]

    @staticmethod
    def determine_stealer(def_team: EngineTeam, config: Dict) -> EnginePlayer:
        """
        [Spec 6.5] æ±ºå®šæŠ„æˆªè€…
        """
        candidates = def_team.on_court
        weights = []
        total_weight = 0.0
        
        steal_attrs = AttributionSystem._get_attrs_from_config(config, 'steal_weight')

        for p in candidates:
            w = sum(AttributionSystem._get_val(p, a) for a in steal_attrs)
            weights.append((p, w))
            total_weight += w
        
        r = rng.get_float(0.0, 1.0) * total_weight
        upto = 0.0
        for p, w in weights:
            if upto + w >= r: return p
            upto += w
      
        return candidates[-1]

    # =========================================================================
    # Recording Methods (Aligned with MatchEngine Core)
    # =========================================================================

    @staticmethod
    def get_position_matchup(target_player: EnginePlayer, opponent_team: EngineTeam) -> EnginePlayer:
        """Helper: å°‹æ‰¾å°ä½çƒå“¡"""
        target_pos = target_player.position
        for p in opponent_team.on_court:
            if p.position == target_pos: return p
        return opponent_team.on_court[0]

    @staticmethod
    def update_plus_minus(scoring_team: EngineTeam, defending_team: EngineTeam, points: int):
        """
        [New] æ›´æ–°å ´ä¸Šçƒå“¡æ­£è² å€¼ (+/-)
        """
        if points == 0: return
        
        for p in scoring_team.on_court:
            p.stat_plus_minus += points
        
        for p in defending_team.on_court:
            p.stat_plus_minus -= points

    @staticmethod
    def record_possession_time(team: EngineTeam, seconds: float):
        """
        [Modified] è¨˜éŒ„å›åˆæ¶ˆè€—æ™‚é–“
        1. ç´¯åŠ ç¸½æ™‚é–“ (stat_possession_seconds)
        2. è¨˜éŒ„å–®æ¬¡æ™‚é–“ (stat_possession_history)
        """
        team.stat_possession_seconds += seconds      # ç´¯åŠ ç¸½æ™‚é–“
        team.stat_possession_history.append(seconds) # è¨˜éŒ„è©³ç´°æ­·å²

    @staticmethod
    def record_attempt(player: EnginePlayer, is_3pt: bool):
        """è¨˜éŒ„å‡ºæ‰‹"""
        player.stat_fga += 1
        if is_3pt: player.stat_3pa += 1

    @staticmethod
    def record_score(team: EngineTeam, scorer: EnginePlayer, points: int, is_3pt: bool, assister: Optional[EnginePlayer] = None):
        """
        è¨˜éŒ„å¾—åˆ† (é€²çƒ)
        """
        # 1. åœ˜éšŠå¾—åˆ†
        team.score += points
        
        # 2. å€‹äººå¾—åˆ†
        scorer.stat_pts += points
        
        # 3. å‘½ä¸­æ•¸
        scorer.stat_fgm += 1
        if is_3pt: 
            scorer.stat_3pm += 1
        
        # 4. å‡ºæ‰‹æ•¸ (é€²çƒä¹Ÿç®—ä¸€æ¬¡å‡ºæ‰‹)
        scorer.stat_fga += 1
        if is_3pt:
            scorer.stat_3pa += 1

        # 5. åŠ©æ”»
        if assister: 
            assister.stat_ast += 1

    @staticmethod
    def record_assist(passer: EnginePlayer):
        """è¨˜éŒ„åŠ©æ”» (Core ç¨ç«‹å‘¼å«)"""
        passer.stat_ast += 1

    @staticmethod
    def record_rebound(player: EnginePlayer, is_offensive: bool):
        """è¨˜éŒ„ç±ƒæ¿"""
        player.stat_reb += 1
        if is_offensive: player.stat_orb += 1
        else: player.stat_drb += 1

    @staticmethod
    def record_steal(stealer: EnginePlayer, victim_team: EngineTeam):
        """è¨˜éŒ„æŠ„æˆª"""
        stealer.stat_stl += 1
        # å°‹æ‰¾å—å®³è€…è¨˜éŒ„å¤±èª¤
        victim = AttributionSystem.get_position_matchup(stealer, victim_team)
        victim.stat_tov += 1

    @staticmethod
    def record_block(blocker: EnginePlayer, shooter: EnginePlayer):
        """è¨˜éŒ„å°é˜»"""
        blocker.stat_blk += 1
        # ç±ƒçƒè¦å‰‡: è¢«è“‹ç«é‹ç®—ä¸€æ¬¡å‡ºæ‰‹ (FGA)
        shooter.stat_fga += 1

    @staticmethod
    def record_team_turnover(team: EngineTeam):
        """è¨˜éŒ„åœ˜éšŠå¤±èª¤"""
        if hasattr(team, 'stat_tov'): team.stat_tov += 1

    @staticmethod
    def record_8sec_violation(team: EngineTeam):
        """[New v2.4] è¨˜éŒ„8ç§’é•ä¾‹"""
        team.stat_violation_8s += 1
        team.stat_tov += 1

    @staticmethod
    def record_24sec_violation(team: EngineTeam):
        """[New v2.4] è¨˜éŒ„24ç§’é•ä¾‹"""
        team.stat_violation_24s += 1
        team.stat_tov += 1

    @staticmethod
    def record_foul(player: EnginePlayer):
        """è¨˜éŒ„çŠ¯è¦"""
        player.fouls += 1

    @staticmethod
    def record_free_throw(team: EngineTeam, player: EnginePlayer, made: bool):
        """è¨˜éŒ„ç½°çƒ"""
        player.stat_fta += 1
        if made:
            player.stat_ftm += 1
            player.stat_pts += 1
            team.score += 1 

    # =========================================================================
    # Phase 2 New Recording Methods
    # =========================================================================

    @staticmethod
    def record_possession(team: EngineTeam):
        """
        [Phase 2] è¨˜éŒ„å›åˆæ•¸
        ç”¨æ–¼è¨ˆç®— Pace (Possessions per 48 min)ã€‚
        æ‡‰åœ¨æ¯æ¬¡çƒæ¬Šè½‰æ› (å¾—åˆ†ã€å¤±èª¤ã€é˜²å®ˆç±ƒæ¿) æ™‚å‘¼å«ã€‚
        """
        team.stat_possessions += 1

    @staticmethod
    def record_fastbreak_event(team: EngineTeam, player: EnginePlayer, made: bool):
        """
        [Phase 2] è¨˜éŒ„å¿«æ”»äº‹ä»¶
        ç”¨æ–¼é©—è­‰é€Ÿåº¦å±¬æ€§èˆ‡å¿«æ”»æ•ˆç‡çš„ç›¸é—œæ€§ã€‚
        ä¸è«–é€²çƒèˆ‡å¦ï¼Œéƒ½æ‡‰è¨˜éŒ„å˜—è©¦æ¬¡æ•¸ã€‚
        """
        # è¨˜éŒ„å˜—è©¦
        team.stat_fb_attempt += 1
        player.stat_fb_attempt += 1
        
        # è¨˜éŒ„é€²çƒ
        if made:
            team.stat_fb_made += 1
            player.stat_fb_made += 1
```

---

### ğŸ“„ File: `app\services\match_engine\systems\play_logic.py`

```python
# app/services/match_engine/systems/play_logic.py
```

---

### ğŸ“„ File: `app\services\match_engine\systems\stamina.py`

```python
# app/services/match_engine/systems/stamina.py

from typing import Dict, List
from ..structures import EnginePlayer

class StaminaSystem:
    """
    é«”åŠ›ç³»çµ± (Level 3) - Config Driven
    å®Œå…¨ä¾è³´å‚³å…¥çš„ config å­—å…¸é€²è¡Œè¨ˆç®—ï¼Œä¸å¯«æ­»ä»»ä½•ä¿‚æ•¸ã€‚
    å°æ‡‰ Spec v1.5 Section 2 & v2.1 (Rest Updates)
    """

    @staticmethod
    def update_stamina(player: EnginePlayer, seconds: float, is_on_court: bool, config: Dict):
        """
        æ›´æ–°çƒå“¡é«”åŠ› (æ¶ˆè€—æˆ–æ¢å¾©)ã€‚
        """
        # 1. è®€å–è¨­å®šåƒæ•¸
        me_config = config.get('match_engine', {})
        gen_config = me_config.get('general', {})
        sys_config = me_config.get('stamina_system', {})
        age_threshold = sys_config.get('age_threshold', 20)
        age_decay_rate = sys_config.get('age_decay_rate', 0.01)

        # è¨ˆç®—å¹´é½¡å› å­
        age_factor = 1.0
        if player.age > age_threshold:
            # (Age - 20) * 1%
            age_factor = 1.0 + (player.age - age_threshold) * age_decay_rate
        
        # å–å¾—å±¬æ€§åç¨±
        drain_attrs = sys_config.get('drain_attrs', ['ath_stamina', 'talent_health'])
        
        # å–å¾—ä¿‚æ•¸
        drain_coeff = gen_config.get('stamina_drain_coeff', 3.0)
        
        # 2. å–å¾—çƒå“¡å±¬æ€§ä¸¦è½‰ç‚ºç™¾åˆ†æ¯” (0.01 ~ 0.99)
        stamina_val = getattr(player, drain_attrs[0], 50)
        health_val = getattr(player, drain_attrs[1], 50)
        
        stamina_pct = max(0.01, min(0.99, stamina_val / 100.0))
        health_pct = max(0.01, min(0.99, health_val / 100.0))

        change_per_minute = 0.0

        if is_on_court:
            # [Spec 2.3] æ¶ˆè€—å…¬å¼
            # æ¶ˆè€—é‡/åˆ† = Coeff * [1 + (1 - é«”èƒ½%)] + (1 - å¥åº·%)
            drain_per_min = drain_coeff * ((1.0 + (1.0 - stamina_pct)) + (1.0 - health_pct))
            drain_per_min *= age_factor # <--- ä¹˜ä¸Šå¹´é½¡å› å­
            change_per_minute = -drain_per_min
        else:
            # [Spec 2.4] æ¢å¾©å…¬å¼
            # æ¢å¾©é‡/åˆ† = 1.0 + (é«”èƒ½%) - (1 - å¥åº·%)
            recover_factor = 1.0 
            if player.age > age_threshold:
                recover_factor = 1.0 - (player.age - age_threshold) * age_decay_rate
            
            base_recover = 1.0 
            recover_per_min = (base_recover + stamina_pct - (1.0 - health_pct)) * recover_factor # <--- ä¹˜ä¸Šæ¢å¾©è¡°é€€
            change_per_minute = recover_per_min

        # 3. æ‡‰ç”¨è®Šæ›´
        change = (change_per_minute / 60.0) * seconds
        new_val = player.current_stamina + change
        
        # é™åˆ¶ç¯„åœ
        if new_val > 100.0: new_val = 100.0
        elif new_val < 1.0: new_val = 1.0
        
        player.current_stamina = new_val

        # 4. æ›´æ–°ä¿®æ­£ä¿‚æ•¸
        StaminaSystem._update_coefficient(player, gen_config)

    @staticmethod
    def _update_coefficient(player: EnginePlayer, gen_config: Dict):
        """
        [Spec 2.2] èƒ½åŠ›å€¼å‹•æ…‹ä¿®æ­£
        """
        threshold = gen_config.get('stamina_nerf_threshold', 80.0)
        min_multiplier = gen_config.get('stamina_min_multiplier', 0.21)
        
        current = player.current_stamina

        if current >= threshold:
            player.stamina_coeff = 1.0
        elif current > 1.0:
            # ç·šæ€§è¡°é€€
            penalty = (threshold - current) * 0.01
            player.stamina_coeff = 1.0 - penalty
        else:
            # æ¥µé™ç‹€æ…‹
            player.stamina_coeff = min_multiplier

    @staticmethod
    def apply_rest(team_players: List[EnginePlayer], minutes: float, config: Dict):
        """
        [Spec 2.4 New] æ‡‰ç”¨ä¼‘æ¯æ™‚é–“ (ä¸­å ´æˆ–ç¯€é–“)
        é‚è¼¯ï¼šå°‡ä¼‘æ¯æ™‚é–“è¦–ç‚ºã€Œåœ¨æ¿å‡³ä¸Šä¼‘æ¯ã€ï¼Œèª¿ç”¨ update_stamina é€²è¡Œæ¢å¾©ã€‚
        """
        seconds = minutes * 60.0
        for player in team_players:
            # å¼·åˆ¶è¦–ç‚ºä¸‹å ´ä¼‘æ¯ (is_on_court=False)
            StaminaSystem.update_stamina(player, seconds, False, config)
```

---

### ğŸ“„ File: `app\services\match_engine\systems\substitution.py`

```python
# app/services/match_engine/systems/substitution.py

from typing import List, Optional, Dict, Set
from ..structures import EngineTeam, EnginePlayer

class SubstitutionSystem:
    """
    æ›äººç³»çµ± (Level 3) - Config Driven
    å°æ‡‰ Spec v1.5 Section 2.5 & 2.6
    ä¿®æ­£: çµ±ä¸€ä½¿ç”¨ç§’ (seconds) é€²è¡Œæ™‚é–“æ¯”è¼ƒã€‚
    """

    @staticmethod
    def check_auto_substitution(team: EngineTeam, quarter: int, time_remaining: float, config: Dict) -> List[str]:
        """
        [Spec 2.5] å¸¸è¦æ›äººæª¢æŸ¥
        """
        logs = []
        
        # è®€å– Config
        sub_config = config.get('match_engine', {}).get('general', {}).get('substitution', {})
        fatigue_threshold = sub_config.get('stamina_threshold', 80.0)
        
        to_sub_out = []
        
        for player in team.on_court:
            reason = None
            # æ¢ä»¶ 1: é«”åŠ›éä½
            if player.current_stamina < fatigue_threshold:
                reason = "é«”åŠ›ä½"
            
            # æ¢ä»¶ 2: æ™‚é–“å·²åˆ° (å®¹è¨± 1 åˆ†é˜ç·©è¡)
            elif (player.seconds_played > player.target_seconds + 60.0):
                reason = "æ™‚é–“åˆ°"

            if reason:
                to_sub_out.append((player, reason))
        
        for p_out, reason in to_sub_out:
            p_in = SubstitutionSystem._pick_bench_player(team, p_out.position, p_out.current_stamina)
            
            if p_in:
                SubstitutionSystem.execute_sub(team, p_out, p_in)
                logs.append(f"{team.name} æ›äºº: {p_in.name} æ›¿æ› {p_out.name} ({reason})")
        
        return logs

    @staticmethod
    def handle_fouled_out(team: EngineTeam, fouled_player: EnginePlayer, config: Dict) -> str:
        """
        [Spec 2.6] è™•ç†çŠ¯æ»¿é›¢å ´èˆ‡æ™‚é–“é‡åˆ†é…
        """
        fouled_player.is_fouled_out = True
        
        # è¨ˆç®—å‰©é¤˜æ™‚é–“ [Fix] ä½¿ç”¨ seconds
        remaining_seconds = max(0.0, fouled_player.target_seconds - fouled_player.seconds_played)
        fouled_player.target_seconds = fouled_player.seconds_played 
        
        # æ™‚é–“é‡åˆ†é…
        if remaining_seconds > 0:
            # è®€å–é‡åˆ†é…è¨­å®š
            redis_config = config.get('match_engine', {}).get('general', {}).get('substitution', {}).get('redistribution', {})
            SubstitutionSystem._redistribute_minutes(team, remaining_seconds, redis_config)

        # å¼·åˆ¶æ›äºº
        p_in = SubstitutionSystem._pick_best_available(team, fouled_player.position)
        
        if p_in:
            SubstitutionSystem.execute_sub(team, fouled_player, p_in)
            return f"{fouled_player.name} çŠ¯æ»¿é›¢å ´(å‰©é¤˜{remaining_seconds:.1f}åˆ†å·²åˆ†é…)ï¼Œç”± {p_in.name} æ¥æ›¿"
        else:
            return f"{fouled_player.name} çŠ¯æ»¿é›¢å ´ï¼Œæ¿å‡³ç„¡å¯ç”¨ä¹‹å…µï¼"

    @staticmethod
    def _redistribute_minutes(team: EngineTeam, minutes: float, redis_config: Dict):
        """
        [Spec 2.6] åˆ†é…é‚è¼¯
        """
        # å¾ Config è®€å–é †åºèˆ‡æ•¸é‡
        positions_order = redis_config.get('positions', ["C", "PF", "SF", "SG", "PG"])
        top_k = redis_config.get('top_k', 3)
        
        all_players = team.on_court + team.bench
        targets = []
        
        for pos in positions_order:
            valid_players = [p for p in all_players if not p.is_fouled_out]
            # æ’åºä¾æ“šè©²ä½ç½®åˆ†æ•¸
            valid_players.sort(key=lambda p: p.pos_scores.get(pos, 0), reverse=True)
            targets.extend(valid_players[:top_k])
        
        # åˆ†é…æ™‚é–“ (ç¸½ä»½æ•¸ = ä½ç½®æ•¸ * Top_K)
        total_slots = len(positions_order) * top_k
        if total_slots > 0:
            unit_time = minutes / float(total_slots)
            for p in targets:
                p.target_seconds += unit_time

    @staticmethod
    def execute_sub(team: EngineTeam, p_out: EnginePlayer, p_in: EnginePlayer):
        """åŸ·è¡Œæ›äºº"""
        if p_out in team.on_court:
            team.on_court.remove(p_out)
            team.bench.append(p_out)
        
        if p_in in team.bench:
            team.bench.remove(p_in)
            team.on_court.append(p_in)
        elif p_in not in team.on_court:
            # é˜²å‘†: å¦‚æœ p_in æ—¢ä¸åœ¨ bench ä¹Ÿä¸åœ¨ on_court (ç†è«–ä¸Šä¸æ‡‰ç™¼ç”Ÿ)
            team.on_court.append(p_in)

    @staticmethod
    def _pick_bench_player(team: EngineTeam, target_position: str, current_stamina_threshold: float) -> Optional[EnginePlayer]:
        """å¸¸è¦æ›¿è£œé¸æ“‡"""
        candidates = [
            p for p in team.bench 
            if not p.is_fouled_out 
            and p.current_stamina > current_stamina_threshold
            and p.seconds_played < p.target_seconds
        ]
        if not candidates: return None
        candidates.sort(key=lambda p: p.pos_scores.get(target_position, 0), reverse=True)
        return candidates[0]

    @staticmethod
    def _pick_best_available(team: EngineTeam, target_position: str) -> Optional[EnginePlayer]:
        """ç·Šæ€¥æ›¿è£œé¸æ“‡"""
        candidates = [p for p in team.bench if not p.is_fouled_out]
        if not candidates: return None
        candidates.sort(key=lambda p: p.pos_scores.get(target_position, 0), reverse=True)
        return candidates[0]
    
    @staticmethod
    def enforce_best_lineup(team: EngineTeam, config: Dict) -> List[str]:
        """
        [Spec 2.5 Revised] é—œéµæ™‚åˆ»å¼·åˆ¶èª¿åº¦ (Clutch Override)
        é‚è¼¯ï¼š
        1. ä»¥è³½å‰æ±ºå®šçš„ Best 5 ç‚ºåŸºç¤ã€‚
        2. è‹¥ Best 5 æœ‰äººçŠ¯æ»¿ï¼Œå‰‡ä¾æ“šè©²ä½ç½®è©•åˆ†é †åºï¼Œé¸å‡ºä¸‹ä¸€ä½å¯ç”¨çƒå“¡éè£œã€‚
        3. ç¢ºä¿éè£œè€…ä¸æ˜¯ã€Œå…¶ä»–ä½ç½®çš„ Best 5 æˆå“¡ã€(é¿å…æŒ–æ±ç‰†è£œè¥¿ç‰†)ã€‚
        4. å¼·åˆ¶æ›äººã€‚
        """
        logs = []
        
        # 1. å–å¾—åŸºç¤ Best 5 (å°æ‡‰ç´¢å¼• 0:C, 1:PF, 2:SF, 3:SG, 4:PG)
        # æ³¨æ„: é€™è£¡å¿…é ˆè¤‡è£½ä¸€ä»½ listï¼Œé¿å…ä¿®æ”¹åˆ°åŸå§‹çš„ team.best_five
        if not team.best_five: return logs
        
        target_lineup = list(team.best_five) 
        positions_order = ["C", "PF", "SF", "SG", "PG"]
        
        # 2. å»ºç«‹ã€Œå·²é–å®šåå–®ã€é›†åˆ
        # å…ˆå°‡ Best 5 ä¸­ã€ŒæœªçŠ¯æ»¿ã€çš„çƒå“¡é–å®šï¼Œç¢ºä¿ä»–å€‘ä¸æœƒè¢«ç•¶ä½œæ›¿è£œå»è£œåˆ¥çš„ä½ç½®
        locked_ids: Set[str] = {p.id for p in target_lineup if not p.is_fouled_out}
        
        # 3. æª¢æŸ¥ä¸¦ä¿®å¾©é™£å®¹ (å¡«è£œçŠ¯æ»¿ç¼ºå£)
        for i, player in enumerate(target_lineup):
            if player.is_fouled_out:
                target_pos = positions_order[i]
                
                # å°‹æ‰¾æ›¿è£œï¼š
                # æ¢ä»¶ A: æœªçŠ¯æ»¿
                # æ¢ä»¶ B: ä¸åœ¨ locked_ids ä¸­ (ä¸æ˜¯å…¶ä»–ä½ç½®çš„ä¸»åŠ›)
                candidates = [
                    p for p in team.roster 
                    if not p.is_fouled_out and p.id not in locked_ids
                ]
                
                # æ’åºï¼šä¾æ“šè©²ä½ç½® (target_pos) çš„è©•åˆ†ç”±é«˜è‡³ä½
                candidates.sort(key=lambda p: p.pos_scores.get(target_pos, 0), reverse=True)
                
                if candidates:
                    replacement = candidates[0]
                    target_lineup[i] = replacement
                    locked_ids.add(replacement.id) # é–å®šé€™ä½æ›¿è£œï¼Œé¿å…ä»–è¢«é‡è¤‡é¸ç”¨
                    # logs.append(f"Debug: {team.name} {target_pos} ç”± {replacement.name} éè£œ (åŸ: {player.name} çŠ¯æ»¿)")
                else:
                    # æ¥µç«¯æƒ…æ³ï¼šå…¨éšŠéƒ½çŠ¯æ»¿æˆ–ç„¡äººå¯ç”¨ï¼Œä¿æŒåŸæ¨£ (é¿å…ç¨‹å¼å´©æ½°)
                    pass

        # 4. åŸ·è¡Œæ›äºº (Diff & Swap)
        # æ¯”è¼ƒ target_lineup èˆ‡ team.on_court
        
        # æ‰¾å‡ºã€Œè©²ä¸Šå ´ä½†ä¸åœ¨å ´ä¸Šã€çš„çƒå“¡ (In)
        current_court_ids = {p.id for p in team.on_court}
        players_in = [p for p in target_lineup if p.id not in current_court_ids]
        
        # æ‰¾å‡ºã€Œåœ¨å ´ä¸Šä½†ä¸è©²ä¸Šå ´ã€çš„çƒå“¡ (Out)
        target_ids = {p.id for p in target_lineup}
        players_out = [p for p in team.on_court if p.id not in target_ids]
        
        # åŸ·è¡Œæ›¿æ› (ä¸€é€²ä¸€å‡º)
        # ç”±æ–¼äººæ•¸ä¸€å®šç›¸ç­‰ (éƒ½æ˜¯5äºº)ï¼Œç›´æ¥é…å°æ›¿æ›
        for p_in, p_out in zip(players_in, players_out):
            SubstitutionSystem.execute_sub(team, p_out, p_in)
            
            # è¨­å®šä¸Šå ´çƒå“¡çš„ä½ç½® (ä¾ç…§ä»–åœ¨ target_lineup ä¸­çš„ç´¢å¼•æ±ºå®š)
            # æ‰¾å‡º p_in åœ¨ target_lineup çš„ index ä»¥æ±ºå®šä½ç½®
            idx = target_lineup.index(p_in)
            p_in.position = positions_order[idx]
            
            logs.append(f"{team.name} é—œéµæ™‚åˆ»èª¿åº¦: {p_in.name} ({p_in.position}) æ›¿æ› {p_out.name}")
        
        return logs
```

---

### ğŸ“„ File: `app\services\match_engine\utils\__init__.py`

```python
```

---

### ğŸ“„ File: `app\services\match_engine\utils\calculator.py`

```python
# app/services/match_engine/utils/calculator.py

from typing import List, Dict, Optional, Union
from ..structures import EnginePlayer

class Calculator:
    """
    é€šç”¨å…¬å¼è¨ˆç®—å™¨ (Level 2)ã€‚
    ä¿®æ­£: 
    1. ç§»é™¤ Python å…§å¯«æ­»çš„ ALL_ATTRIBUTE_NAMESã€‚
    2. æ”¯æ´éè¿´è§£æ attr_poolsï¼Œå¯¦ç¾çœŸæ­£çš„ Config Drivenã€‚
    3. æŠ•ç±ƒå…¬å¼æ­£ç¢ºè®€å– spacing_weightã€‚
    4. åŒæ­¥ Spec v2.2 æŠ€å·§åŠ æˆ (Skill Bonus) é‚è¼¯ã€‚
    5. calculate_shooting_rate æ”¯æ´ 3åˆ†çƒç‰¹æ®Šé‚è¼¯ (Multiplier & Base Rate)ã€‚
    """

    @staticmethod
    def _resolve_formula_keys(formula: Union[str, List[str]], attr_pools: Dict) -> List[str]:
        """Helper: è§£æ Config ä¸­çš„å±¬æ€§åˆ—è¡¨å¼•ç”¨"""
        if isinstance(formula, str):
            return attr_pools.get(formula, [])
        return formula

    @staticmethod
    def get_player_attr_sum(player: EnginePlayer, attrs: List[str], attr_pools: Optional[Dict[str, List[str]]] = None) -> float:
        """
        è¨ˆç®—çƒå“¡æŒ‡å®šå±¬æ€§åˆ—è¡¨çš„ç¸½å’Œã€‚
        
        Args:
            player: çƒå“¡ç‰©ä»¶
            attrs: å±¬æ€§åç¨±åˆ—è¡¨ (å¯åŒ…å« pool key)
            attr_pools: å±¬æ€§æ± å­—å…¸ (ç”¨æ–¼éè¿´å±•é–‹ pool key)
        """
        total = 0.0
        coeff = player.stamina_coeff

        for attr in attrs:
            is_negative = False
            clean_attr = attr
            
            # è™•ç†è² è™Ÿèªæ³• (å¦‚ '-height')
            if attr.startswith('-'):
                is_negative = True
                clean_attr = attr[1:]

            # 1. å˜—è©¦ç›´æ¥å¾çƒå“¡å–å¾—å±¬æ€§
            if hasattr(player, clean_attr):
                val = getattr(player, clean_attr)
                
                # é«”åŠ›ä¿®æ­£: åªæœ‰æ•¸å€¼å‹å±¬æ€§æ‰ä¹˜ä¿‚æ•¸ (height ä¸ä¹˜)
                if clean_attr != 'height':
                    val *= coeff
                
                if is_negative:
                    total -= val
                else:
                    total += val
            
            # 2. è‹¥çƒå“¡ç„¡æ­¤å±¬æ€§ï¼Œæª¢æŸ¥æ˜¯å¦ç‚º Pool Key (éè¿´å±•é–‹)
            elif attr_pools and clean_attr in attr_pools:
                # éè¿´å‘¼å«: å‚³å…¥ pool å®šç¾©çš„åˆ—è¡¨
                sub_total = Calculator.get_player_attr_sum(player, attr_pools[clean_attr], attr_pools)
                
                if is_negative:
                    total -= sub_total
                else:
                    total += sub_total
        
        return total

    @staticmethod
    def get_team_attr_sum(players: List[EnginePlayer], attrs: List[str], attr_pools: Optional[Dict[str, List[str]]] = None) -> float:
        """è¨ˆç®—ä¸€çµ„çƒå“¡çš„å±¬æ€§ç¸½å’Œ"""
        return sum(Calculator.get_player_attr_sum(p, attrs, attr_pools) for p in players)

    @staticmethod
    def calculate_shooting_rate(
        off_players: List[EnginePlayer], # [Fix] æ”¹ç‚ºå‚³å…¥é€²æ”»å…¨éšŠ
        def_players: List[EnginePlayer],
        shooter: EnginePlayer,           # [Fix] æ–°å¢åƒæ•¸ï¼šå‡ºæ‰‹è€… (ç”¨æ–¼æŠ€å·§åŠ æˆ)
        config: Dict,
        spacing_factor: float = 0.0,
        quality_bonus: float = 0.0,
        is_3pt: bool = False
    ) -> float:
        """
        [Spec 5.1 & 5.2] æŠ•ç±ƒå‘½ä¸­ç‡è¨ˆç®— (ä¿®æ­£ç‰ˆ)
        é‚è¼¯:
          - å°æŠ— (Off_Total vs Def_Total): ä½¿ç”¨ Team Sum vs Team Sum
          - æŠ€å·§ (Skill Bonus): ä½¿ç”¨ Shooter Individual Stats
        """
        # 1. å°èˆª Config
        me_config = config.get('match_engine', {})
        shooting_config = me_config.get('shooting', {})
        formulas = shooting_config.get('formulas', {})
        params = shooting_config.get('params', {})
        attr_pools = me_config.get('attr_pools', {})

        # 2. æ±ºå®šåŸºç¤å‘½ä¸­ç‡ (Base Rate)
        base_rate = params.get('base_rate_3pt', 0.20) if is_3pt else params.get('base_rate_2pt', 0.40)

        # 3. è¨ˆç®—é€²æ”»ç¸½å€¼ (Offensive Rating) - [Fix] ä½¿ç”¨ get_team_attr_sum
        base_off_keys = Calculator._resolve_formula_keys(formulas.get('off_total', 'off_13'), attr_pools)
        off_sum = Calculator.get_team_attr_sum(off_players, base_off_keys, attr_pools)

        if is_3pt:
            # [Spec 5.2.A] 3åˆ†çƒç‰¹æ®ŠåŠ æˆ (ä¹Ÿæ˜¯çœ‹åœ˜éšŠ)
            bonus_keys = Calculator._resolve_formula_keys(formulas.get('bonus_3pt_attrs', []), attr_pools)
            bonus_sum = Calculator.get_team_attr_sum(off_players, bonus_keys, attr_pools)
            mult = params.get('multiplier_3pt', 2.0)
            off_sum += bonus_sum * (mult - 1.0)

        # 4. è¨ˆç®—é˜²å®ˆç¸½å€¼ (Defensive Rating)
        def_keys = Calculator._resolve_formula_keys(formulas.get('def_total', 'def_12'), attr_pools)
        def_sum = Calculator.get_team_attr_sum(def_players, def_keys, attr_pools)
        if def_sum == 0: def_sum = 1

        # 5. è¨ˆç®—æŠ€å·§åŠ æˆ (Skill Bonus) - [Fix] é‡å° shooter å€‹äººè¨ˆç®—
        skill_keys = Calculator._resolve_formula_keys(formulas.get('skill_bonus_attrs', ['shot_accuracy', 'shot_range', 'off_move']), attr_pools)
        skill_sum = Calculator.get_player_attr_sum(shooter, skill_keys, attr_pools)
        skill_divisor = params.get('skill_bonus_divisor', 800.0)
        skill_multiplier = 1.0 + (skill_sum / skill_divisor)

        # 6. æœ€çµ‚å…¬å¼è¨ˆç®—
        stat_diff = (off_sum - def_sum) / def_sum
        spacing_weight = params.get('spacing_weight', 0.1)
        
        final_rate = (base_rate + stat_diff) * skill_multiplier * (1.0 + spacing_factor * spacing_weight) * (1.0 + quality_bonus)
        
        return max(0.01, min(0.99, final_rate))
```

---

### ğŸ“„ File: `app\services\match_engine\utils\rng.py`

```python
# app/services/match_engine/utils/rng.py
import random
from typing import List, Any, Optional

# [Optimization] å°‡æ–¹æ³•ç¶å®šç§»è‡³æ¨¡çµ„å±¤ç´š (Module Level)
# é€™é¿å…äº†åœ¨ Python 3.13+ ä¸­ï¼Œå°‡ç¶å®šæ–¹æ³•(Bound Method)æŒ‡æ´¾çµ¦é¡åˆ¥å±¬æ€§æ™‚å¯èƒ½ç™¼ç”Ÿçš„åƒæ•¸å‚³ééŒ¯èª¤ã€‚
# åŒæ™‚ä¿ç•™äº†æ¸›å°‘å±¬æ€§æŸ¥æ‰¾(Attribute Lookup)çš„æ•ˆèƒ½å„ªå‹¢ã€‚
_sys_random = random.random
_sys_uniform = random.uniform
_sys_choice = random.choice

class RNG:
    """
    æ¥µè‡´æ•ˆèƒ½å„ªåŒ–ç‰ˆçš„éš¨æ©Ÿæ•¸ç”Ÿæˆå™¨ã€‚
    é‡å°ã€Œå–®æ¬¡ã€é«˜é »ç‡ã€å‘¼å«å ´æ™¯å„ªåŒ– (Event-Driven Simulation)ã€‚
    """
    __slots__ = () # ç¯€çœè¨˜æ†¶é«”
    
    # å¦‚æœæœªä¾†éœ€è¦å›ºå®š Seedï¼Œå¯ä»¥åœ¨é€™è£¡å¯¦ä½œåˆå§‹åŒ–
    @classmethod
    def seed(cls, seed_val: Any):
        random.seed(seed_val)

    @staticmethod
    def get_float(min_val: float = 0.0, max_val: float = 1.0) -> float:
        """
        å›å‚³ [min_val, max_val] ä¹‹é–“çš„æµ®é»æ•¸ã€‚
        """
        # ç›´æ¥å‘¼å«æ¨¡çµ„å±¤ç´šçš„åˆ¥åï¼Œé¿å…é¡åˆ¥å±¬æ€§æŸ¥æ‰¾çš„é–‹éŠ·èˆ‡ç¶å®šå•é¡Œ
        return _sys_uniform(min_val, max_val)

    @staticmethod
    def decision(probability: float) -> bool:
        """
        åˆ¤å®šäº‹ä»¶æ˜¯å¦ç™¼ç”Ÿã€‚
        probability: 0.0 ~ 1.0
        """
        # å„ªåŒ–ï¼šæ¸›å°‘é‚Šç•Œæª¢æŸ¥ï¼Œå‡è¨­å‘¼å«ç«¯æœƒå‚³å…¥åˆæ³•æ•¸å€¼
        return _sys_random() < probability

    @staticmethod
    def choice(items: List[Any]) -> Any:
        """
        å¾åˆ—è¡¨ä¸­é¸æ“‡ä¸€å€‹é …ç›®ã€‚
        """
        return _sys_choice(items)

    @staticmethod
    def weighted_index(weights: List[float]) -> int:
        """
        æ ¹æ“šæ¬Šé‡å›å‚³ç´¢å¼•å€¼ã€‚
        é€™æ˜¯æ•ˆèƒ½ç“¶é ¸é»ï¼ŒPython åŸç”Ÿè¿´åœˆè¼ƒæ…¢ã€‚
        å¦‚æœ weights é•·åº¦å›ºå®šä¸”å¾ˆçŸ­ (å¦‚ 5å€‹ä½ç½®)ï¼Œé€™æ®µ Python code å¤ å¿«ã€‚
        """
        r = _sys_random() * sum(weights)
        upto = 0.0
        for i, w in enumerate(weights):
            if w + upto >= r:
                return i
            upto += w
        return len(weights) - 1

# ç‚ºäº†æ–¹ä¾¿å…¶ä»–æ¨¡çµ„å‘¼å«ï¼Œç›´æ¥æš´éœ²å¯¦ä¾‹æˆ–é¡åˆ¥
rng = RNG
```

---

### ğŸ“„ File: `app\services\match_engine\__init__.py`

```python
```

---

### ğŸ“„ File: `app\services\match_engine\core.py`

```python
# app/services/match_engine/core.py

from typing import Dict, List, Optional, Tuple, Union
import math

from .structures import EngineTeam, EnginePlayer, MatchState, MatchResult
from .utils.calculator import Calculator
from .utils.rng import rng
from .systems.stamina import StaminaSystem
from .systems.substitution import SubstitutionSystem
from .systems.attribution import AttributionSystem

class MatchEngine:
    """
    ASBL æ¯”è³½å¼•æ“æ ¸å¿ƒ (Level 4 - Phase 2 Final)
    å°æ‡‰è¦æ ¼æ›¸: Match Engine Specification v1.8
    
    [Phase 2 Updates]
    - æ•´åˆ Pace è¨ˆç®— (Record Possession)ã€‚
    - æ•´åˆå¿«æ”»æ•ˆç‡çµ±è¨ˆ (Record Fastbreak)ã€‚
    - è¼¸å‡ºåŒ…å«é€²éšæ•¸æ“šçš„ MatchResultã€‚
    
    [Update 2026-01-16]
    - æ–°å¢: æ­£è² å€¼ (+/-) çµ±è¨ˆ
    - æ–°å¢: å›åˆæ™‚é–“ (Possession Time) è¨˜éŒ„
    """

    def __init__(self, home_team: EngineTeam, away_team: EngineTeam, config: Dict, game_id: str = "SIM_GAME"):
        self.home_team = home_team
        self.away_team = away_team
        self.config = config
        self.game_id = game_id
        
        # 1. åˆå§‹åŒ–æ¯”è³½ç‹€æ…‹
        general_config = config.get('match_engine', {}).get('general', {})
        self.quarter_length = general_config.get('quarter_length', 720)
        self.ot_length = general_config.get('ot_length', 300)
        
        # [ä¿®æ­£] è®€å–æ›äººç›¸é—œåƒæ•¸ (çŠ¯è¦ä¸Šé™ & é—œéµæ™‚åˆ»é–¾å€¼)
        sub_config = general_config.get('substitution', {})
        self.foul_limit = sub_config.get('foul_limit', 6)
        self.clutch_threshold = sub_config.get('clutch_time_threshold', 120.0)
        
        self.state = MatchState(time_remaining=float(self.quarter_length))
        
        # 2. åŸ·è¡Œè³½å‰æº–å‚™
        self._initialize_match()
        
        # 3. åˆå§‹åŒ– PBP Logs
        self.pbp_logs = []

    def _initialize_match(self):
        """è³½å‰æº–å‚™æµç¨‹"""
        # [æ–°å¢] Spec v2.1 Section 1.5 è³½å‰èº«é«˜ä¿®æ­£ (å¿…é ˆåœ¨é«”åŠ›èˆ‡è©•åˆ†è¨ˆç®—å‰åŸ·è¡Œ)
        self._apply_height_correction(self.home_team)
        self._apply_height_correction(self.away_team)

        for team in [self.home_team, self.away_team]:
            self._calculate_all_positional_scores(team)
            self._determine_best_five(team)
            self._distribute_team_minutes(team)
            self._set_initial_lineup(team)

    # [æ–°å¢æ•´å€‹æ–¹æ³•]
    def _apply_height_correction(self, team: EngineTeam):
        """
        [Spec v2.1 Section 1.5] èº«é«˜å±¬æ€§ä¿®æ­£ (Initial Height Correction)
        é‡å°ç‰¹å®šå±¬æ€§é€²è¡ŒåŸºæ–¼èº«é«˜çš„ç‰©ç†ä¿®æ­£ï¼Œæ­¤ç‚ºæ°¸ä¹…æ€§ä¿®æ­£ã€‚
        """
        hc_config = self.config.get('match_engine', {}).get('height_correction', {})
        bonus_h = hc_config.get('bonus_threshold', 190)
        nerf_h = hc_config.get('nerf_threshold', 210)
        affected_attrs = hc_config.get('affected_attrs', {})

        for player in team.roster:
            h = getattr(player, 'height', 195)
            
            # è¨ˆç®—ä¿®æ­£å€ç‡å› å­
            # å…¬å¼: max(BONUS_H - h, min(NERF_H - h, 0))
            factor = max(bonus_h - h, min(nerf_h - h, 0))
            
            if factor == 0:
                continue

            # æ‡‰ç”¨ä¿®æ­£
            for _, rule in affected_attrs.items():
                keys = rule.get('keys', [])
                coeff = rule.get('coeff', 0.0)
                multiplier = 1.0 + (factor * coeff)
                
                for key in keys:
                    original_val = getattr(player, key, 0)
                    if original_val > 0:
                        new_val = original_val * multiplier
                        # ç¢ºä¿æ•¸å€¼é‚Šç•Œ
                        new_val = max(1, min(999, new_val)) 
                        setattr(player, key, new_val)

    def _calculate_all_positional_scores(self, team: EngineTeam):
        """[Spec 1.1] è¨ˆç®—ä½ç½®è©•åˆ†"""
        scoring_rules = self.config.get('match_engine', {}).get('positional_scoring', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})
        positions = ["C", "PF", "SF", "SG", "PG"]

        for player in team.roster:
            player.pos_scores = {}
            for pos in positions:
                rule_attrs = scoring_rules.get(pos, [])
                score = Calculator.get_player_attr_sum(player, rule_attrs, attr_pools)
                player.pos_scores[pos] = score

    def _determine_best_five(self, team: EngineTeam):
        """[Spec 1.1] æ¨™è¨˜æœ€å¼·é™£å®¹"""
        positions = ["C", "PF", "SF", "SG", "PG"]
        best_five = [None] * 5
        taken_ids = set()
        candidates = []
        
        for p in team.roster:
            for i, pos in enumerate(positions):
                candidates.append((p.pos_scores[pos], i, p))
        
        candidates.sort(key=lambda x: x[0], reverse=True)

        for score, pos_idx, player in candidates:
            if best_five[pos_idx] is None and player.id not in taken_ids:
                best_five[pos_idx] = player
                taken_ids.add(player.id)
            if all(best_five): break
        
        if not all(best_five):
            remaining = [p for p in team.roster if p.id not in taken_ids]
            for i in range(5):
                if best_five[i] is None and remaining:
                    p = remaining.pop(0)
                    best_five[i] = p
                    taken_ids.add(p.id)
        team.best_five = best_five

    def _distribute_team_minutes(self, team: EngineTeam):
        """[Spec 1.4 & 2.6] ä¸Šå ´æ™‚é–“åˆ†é…"""
        min_config = self.config.get('minutes_distribution', {})
        total_minutes = min_config.get('total_minutes', 240)
        role_config = min_config.get('roles', {})

        total_base = 0.0
        active_players = []
        for player in team.roster:
            role_data = role_config.get(player.role, role_config.get('Bench'))
            total_base += role_data.get('base', 0)
            active_players.append(player)

        remaining_time = max(0, total_minutes - total_base)
        
        total_weight = 0.0
        player_weights = {}
        for player in active_players:
            role_data = role_config.get(player.role, role_config.get('Bench'))
            min_w = role_data.get('min_w', 0)
            max_w = role_data.get('max_w', 10)
            w = rng.get_float(float(min_w), float(max_w))
            player_weights[player.id] = w
            total_weight += w

        unit_value = remaining_time / total_weight if total_weight > 0 else 0
        allocated_sum = 0.0

        for i, player in enumerate(active_players):
            role_data = role_config.get(player.role, role_config.get('Bench'))
            base = role_data.get('base', 0)
            raw = base + (player_weights[player.id] * unit_value)
            final = math.floor(raw * 10) / 10.0
            
            if i == len(active_players) - 1:
                diff = total_minutes - allocated_sum
                if diff > 0: final = diff
            
            allocated_sum += final
            player.target_seconds = final * 60.0
            player.seconds_played = 0.0

    def _set_initial_lineup(self, team: EngineTeam):
        """[Spec 1.2] æ±ºå®šå…ˆç™¼é™£å®¹"""
        positions = ["PG", "SG", "SF", "PF", "C"]
        starters = [None] * 5
        taken_ids = set()

        def try_fill(player):
            my_scores = []
            for i, pos in enumerate(positions):
                if starters[i] is None:
                    my_scores.append((player.pos_scores[pos], i))
            my_scores.sort(key=lambda x: x[0], reverse=True)
            if my_scores:
                _, idx = my_scores[0]
                starters[idx] = player
                taken_ids.add(player.id)
                player.position = positions[idx]
                return True
            return False

        for role in ['Star', 'Starter']:
            for p in [x for x in team.roster if x.role == role]:
                try_fill(p)
        
        remaining = [p for p in team.roster if p.id not in taken_ids]
        for i, pos in enumerate(positions):
            if starters[i] is None:
                best_p = max(remaining, key=lambda p: p.pos_scores[pos], default=None)
                if best_p:
                    starters[i] = best_p
                    best_p.position = pos
                    taken_ids.add(best_p.id)
                    remaining.remove(best_p)

        team.on_court = [p for p in starters if p]
        team.bench = [p for p in team.roster if p.id not in taken_ids]

    def _resolve_formula(self, formula: Union[str, List[str]], attr_pools: Dict) -> List[str]:
        if isinstance(formula, str):
            return attr_pools.get(formula, [])
        return formula

    # =========================================================================
    # Simulation Loop
    # =========================================================================

    def simulate(self) -> MatchResult:
        """
        [Spec v1.8] åŸ·è¡Œæ•´å ´æ¨¡æ“¬
        """
        # 1. è·³çƒ
        jb_winner = self._jump_ball()
        jb_loser = self.home_team.id if jb_winner == self.away_team.id else self.away_team.id
        
        # 2. ç¯€æ¬¡çƒæ¬Š
        q_possessions = {1: jb_winner, 2: jb_loser, 3: jb_loser, 4: jb_winner}

        # 3. æ­£è¦è³½
        for q in range(1, 5):
            self.state.quarter = q
            self.state.time_remaining = float(self.quarter_length)
            self.state.possession = q_possessions[q]
            self.pbp_logs.append(f"=== Q{q} Start (Possession: {self.state.possession}) ===")
            self._simulate_quarter()

        # 4. å»¶é•·è³½
        while self.home_team.score == self.away_team.score:
            self.state.quarter += 1
            self.state.time_remaining = float(self.ot_length)
            ot_winner = self._jump_ball()
            self.state.possession = ot_winner
            self.pbp_logs.append(f"=== OT{self.state.quarter-4} Start ===")
            self._simulate_quarter()

        self.state.is_over = True

        # --- æ–°å¢å›å¡«é‚è¼¯ ---
        for team in [self.home_team, self.away_team]:
            for p in team.roster:
                p.stat_remaining_stamina = p.current_stamina
        # ------------------
        
        # 5. è¨ˆç®— Pace (Possessions per 48 min)
        total_possessions = self.home_team.stat_possessions + self.away_team.stat_possessions
        total_minutes = self.state.game_time_elapsed / 60.0
        pace = 0.0
        if total_minutes > 0:
            # Pace = 48 * (Total Poss / 2) / Minutes ? 
            # Standard Pace = (Team Poss + Opp Poss) / 2 * (48 / Minutes)
            pace = (total_possessions / 2.0) * (48.0 / total_minutes)

        # 6. å›å‚³çµæœ
        return MatchResult(
            game_id=self.game_id,
            home_team_id=self.home_team.id,
            away_team_id=self.away_team.id,
            home_score=self.home_team.score,
            away_score=self.away_team.score,
            is_ot=(self.state.quarter > 4),
            total_quarters=self.state.quarter,
            pbp_log=self.pbp_logs,
            # Phase 2 Data
            pace=pace,
            home_possessions=self.home_team.stat_possessions,
            away_possessions=self.away_team.stat_possessions,
            home_fb_made=self.home_team.stat_fb_made,
            home_fb_attempt=self.home_team.stat_fb_attempt,
            away_fb_made=self.away_team.stat_fb_made,
            away_fb_attempt=self.away_team.stat_fb_attempt,
            # [New] å›åˆæ™‚é–“çµ±è¨ˆèˆ‡å¹³å‡å€¼è¨ˆç®—
            home_possession_history=self.home_team.stat_possession_history,
            away_possession_history=self.away_team.stat_possession_history,
            home_avg_seconds_per_poss=(self.home_team.stat_possession_seconds / self.home_team.stat_possessions) if self.home_team.stat_possessions > 0 else 0.0,
            away_avg_seconds_per_poss=(self.away_team.stat_possession_seconds / self.away_team.stat_possessions) if self.away_team.stat_possessions > 0 else 0.0,
            
            # =========== [FIX START] è£œä¸Šé•ä¾‹æ•¸æ“š ===========
            home_violation_8s=self.home_team.stat_violation_8s,
            home_violation_24s=self.home_team.stat_violation_24s,
            away_violation_8s=self.away_team.stat_violation_8s,
            away_violation_24s=self.away_team.stat_violation_24s
            # =========== [FIX END] ========================
        )

    def _jump_ball(self) -> str:
        """(Spec 1.5) è·³çƒ"""
        jb_config = self.config.get('match_engine', {}).get('jump_ball', {})
        attrs = jb_config.get('participant_formula', ['height', 'ath_jump', 'talent_offiq'])
        
        def get_jumper(team):
            c = [p for p in team.on_court if p.position == 'C']
            return c[0] if c else max(team.on_court, key=lambda p: p.pos_scores.get('C', 0))

        h_jumper = get_jumper(self.home_team)
        a_jumper = get_jumper(self.away_team)
        
        h_score = Calculator.get_player_attr_sum(h_jumper, attrs)
        a_score = Calculator.get_player_attr_sum(a_jumper, attrs)
        total = h_score + a_score or 1
        
        if rng.decision(h_score / total):
            self.pbp_logs.append(f"Jump Ball: {self.home_team.name} wins")
            return self.home_team.id
        else:
            self.pbp_logs.append(f"Jump Ball: {self.away_team.name} wins")
            return self.away_team.id

    def _simulate_quarter(self):
        """
        æ¨¡æ“¬å–®ç¯€æ¯”è³½æµç¨‹
        [Phase 2] åŠ å…¥ Possession è¨˜éŒ„é‚è¼¯
        """
        is_opening = (self.state.quarter == 1)
        
        # æ¨™è¨˜æ˜¯å¦ç‚ºæ–°çš„ä¸€æ³¢çƒæ¬Š (ç¯€æ¬¡é–‹å§‹æˆ–æ”»å®ˆäº¤æ›å¾Œ)
        is_new_possession = True 
        is_oreb = False 
        keep = False

        while self.state.time_remaining > 0:
            self._check_substitutions()
            
            # 1. ç¢ºå®šç•¶å‰é€²æ”»æ–¹
            if self.state.possession == self.home_team.id:
                off_team, def_team = self.home_team, self.away_team
            else:
                off_team, def_team = self.away_team, self.home_team
            
            # 2. è‹¥æ˜¯æ–°çƒæ¬Šï¼Œè¨˜éŒ„ä¹‹ (Pace Calculation)
            if is_new_possession:
                AttributionSystem.record_possession(off_team)
                is_new_possession = False

            # 3. åŸ·è¡Œå›åˆ
            is_oreb = keep if 'keep' in locals() else False 
            elapsed, desc, keep = self._simulate_possession(is_opening, is_oreb)
            
            # [New] è¨˜éŒ„å›åˆæ¶ˆè€—æ™‚é–“
            # å°‡è©²æ¬¡é€²æ”»æ‰€èŠ±è²»çš„æ™‚é–“ï¼Œæ­¸å±¬çµ¦é€²æ”»æ–¹
            AttributionSystem.record_possession_time(off_team, elapsed)
            
            self.state.time_remaining -= elapsed
            self.state.game_time_elapsed += elapsed
            
            # Update Stamina & Time
            for team in [self.home_team, self.away_team]:
                for p in team.on_court:
                    p.seconds_played += elapsed
                    StaminaSystem.update_stamina(p, elapsed, True, self.config)
                for p in team.bench:
                    StaminaSystem.update_stamina(p, elapsed, False, self.config)
            
            self.pbp_logs.append(f"[{self.state.quarter}Q {self.state.time_remaining:.1f}] {desc}")
            
            # 4. æ”»å®ˆäº¤æ›åˆ¤å®š
            if not keep:
                # äº¤æ›çƒæ¬Š
                self.state.possession = self.away_team.id if self.state.possession == self.home_team.id else self.home_team.id
                is_new_possession = True # ä¸‹ä¸€å›åˆç‚ºæ–°çƒæ¬Š
            else:
                # é€²æ”»ç±ƒæ¿ï¼Œç¶­æŒçƒæ¬Š (ä¸è¨ˆç‚ºæ–° Possession)
                is_new_possession = False
            
            is_opening = False
        
        # è®€å–æ™‚é–“è¨­å®š
        gen_config = self.config.get('match_engine', {}).get('general', {})
        halftime_min = gen_config.get('stamina_recovery_halftime', 20.0)
        quarter_break_min = gen_config.get('stamina_recovery_quarter', 2.0)
        
        if self.state.quarter == 2:
            # ä¸­å ´ä¼‘æ¯ (Q2 çµæŸ)
            self.pbp_logs.append(f"=== Halftime Break ({halftime_min} mins) ===")
            StaminaSystem.apply_rest(self.home_team.roster, halftime_min, self.config)
            StaminaSystem.apply_rest(self.away_team.roster, halftime_min, self.config)
            
        elif self.state.quarter in [1, 3]:
            # ç¯€é–“ä¼‘æ¯ (Q1, Q3 çµæŸ)
            self.pbp_logs.append(f"=== Quarter Break ({quarter_break_min} mins) ===")
            StaminaSystem.apply_rest(self.home_team.roster, quarter_break_min, self.config)
            StaminaSystem.apply_rest(self.away_team.roster, quarter_break_min, self.config)

        # 3. å»¶é•·è³½å‰ä¼‘æ¯ (Q4 çµæŸå¹³æ‰‹, æˆ– OT çµæŸå¹³æ‰‹)
        # é‚è¼¯: è‹¥ç¾åœ¨æ˜¯ Q4 æˆ– OT (Q>=4)ï¼Œä¸”åˆ†æ•¸å¹³æ‰‹ï¼Œä»£è¡¨å³å°‡é€²å…¥ä¸‹ä¸€ç¯€ï¼Œéœ€è¦ä¼‘æ¯
        elif self.state.quarter >= 4 and self.home_team.score == self.away_team.score:
            self.pbp_logs.append(f"=== Overtime Break ({quarter_break_min} mins) ===")
            StaminaSystem.apply_rest(self.home_team.roster, quarter_break_min, self.config)
            StaminaSystem.apply_rest(self.away_team.roster, quarter_break_min, self.config)

    def _check_substitutions(self):
        """æ›äººæª¢æŸ¥"""
        # åˆ¤æ–·æ˜¯å¦ç‚ºé—œéµæ™‚åˆ» (Q4 æˆ– OT çš„æœ€å¾Œ 2 åˆ†é˜)
        is_clutch = (self.state.quarter >= 4 and self.state.time_remaining <= self.clutch_threshold)
        
        if is_clutch:
            #  é—œéµæ™‚åˆ»ï¼šå¼·åˆ¶åŸ·è¡Œ Best 5 èª¿åº¦
            for team in [self.home_team, self.away_team]:
                logs = SubstitutionSystem.enforce_best_lineup(team, self.config)
                self.pbp_logs.extend(logs)
            return # åŸ·è¡Œå®Œå¼·åˆ¶èª¿åº¦å¾Œï¼Œä¾ç„¶ä¸é€²è¡Œå¸¸è¦é«”åŠ›æª¢æŸ¥
        
        # éé—œéµæ™‚åˆ»ï¼šåŸ·è¡Œå¸¸è¦æ›äººæª¢æŸ¥ (é«”åŠ›/æ™‚é–“)
        for team in [self.home_team, self.away_team]:
            logs = SubstitutionSystem.check_auto_substitution(
                team, self.state.quarter, self.state.time_remaining, self.config
            )
            self.pbp_logs.extend(logs)

    def _simulate_possession(self, is_opening: bool, is_oreb: bool = False) -> Tuple[float, str, bool]:
        """
        å–®ä¸€å›åˆæ¨¡æ“¬
        æ›´æ–° v2.4: æ”¯æ´å¾Œå ´æŠ„æˆªå¾Œçš„ã€Œå³æ™‚æ”»å®ˆäº¤æ›ã€(Instant Transition)
        """
        # 1. ç¢ºå®šåˆå§‹æ”»å®ˆæ–¹
        if self.state.possession == self.home_team.id:
            off_team, def_team = self.home_team, self.away_team
        else:
            off_team, def_team = self.away_team, self.home_team

        # ============================================================
        # Phase 1: Backcourt (å¾Œå ´)
        # ============================================================
        elapsed_bc, res, desc = self._run_backcourt(off_team, def_team, is_opening)
        
        # [Case A] æ­£å¸¸æ¨é€² -> é€²å…¥å‰å ´
        if res == 'frontcourt':
            pass # ç¹¼çºŒåŸ·è¡Œ Phase 2

        # [Case B] æ™®é€šå¤±èª¤ (8ç§’/å‡ºç•Œ) -> çµæŸå›åˆ
        elif res == 'turnover':
            return elapsed_bc, desc, False

        # [Case C] æŠ„æˆªå¾Œçš„è½‰æ› (Steal Transition) [New v2.4]
        elif res in ['steal_fastbreak', 'steal_frontcourt']:
            # é€™è£¡ç™¼ç”Ÿäº†ã€Œå›åˆå…§æ”»å®ˆäº¤æ›ã€
            # åŸé˜²å®ˆæ–¹ (def_team) è®Šæˆäº† é€²æ”»æ–¹
            # åŸé€²æ”»æ–¹ (off_team) è®Šæˆäº† é˜²å®ˆæ–¹
            # 1. è¨˜éŒ„é˜²å®ˆæ–¹(ç¾åœ¨çš„é€²æ”»æ–¹)çš„çƒæ¬Š (å› ç‚ºä»–å€‘ç™¼å‹•äº†å¿«æ”»/åæ“Š)
            AttributionSystem.record_possession(def_team)
            
            # 2. è™•ç†å¿«æ”»åˆ†æ”¯
            if res == 'steal_fastbreak':
                # åŸ·è¡Œå¿«æ”» (æ³¨æ„åƒæ•¸é †åºäº’æ›)
                # [Update] å‚³å…¥ def_team ä»¥è¨ˆç®— +/- (å› ç‚º def_team ç¾åœ¨æ˜¯é€²æ”»æ–¹)
                elapsed_fb, fb_res, fb_desc = self._run_fastbreak(def_team, off_team, elapsed_bc)
                
                # è™•ç†å›å‚³çš„ keep é‚è¼¯ (åè½‰)
                # è‹¥å¿«æ”»é€²çƒ(keep=False)ï¼Œæˆ‘å€‘å¸Œæœ›ä¸‹ä¸€å›åˆçƒæ¬Šçµ¦åŸé€²æ”»æ–¹(A)ï¼Œè€Œç•¶å‰possessionæ˜¯A
                # å¤–å±¤è¿´åœˆé‚è¼¯: if not keep: switch.
                # è‹¥æˆ‘å€‘å›å‚³ False -> switch -> è®Š B çƒæ¬Š (éŒ¯)
                # è‹¥æˆ‘å€‘å›å‚³ True -> no switch -> è®Š A çƒæ¬Š (å°)
                # çµè«–: æŠ„æˆªåæ“Šçš„çµæœéœ€è¦ invert keep
                
                # ç‰¹æ®Šæƒ…æ³: å¿«æ”»å¤±æ•—(è¢«è“‹/ç±ƒæ¿)ï¼Œå›å‚³çš„æ˜¯ turnover å—?
                # _run_fastbreak å›å‚³: ('score', desc) æˆ– ('turnover', desc)
                # é€™è£¡çš„ turnover ä»£è¡¨é˜²å®ˆæˆåŠŸ(åŸæ”»æ–¹æ‹¿å›çƒæ¬Š/ç±ƒæ¿)ï¼Œç›¸ç•¶æ–¼ keep=False (Bæ²’æ‹¿åˆ°çƒ)
                # æ‰€ä»¥é‚è¼¯ä¸€è‡´ï¼Œç›´æ¥å›å‚³ True å³å¯è®“ A æ‹¿å›çƒæ¬Š?
                # ç­‰ç­‰ï¼Œ_run_fastbreak æ²’æœ‰å›å‚³ keepï¼Œå®ƒå›å‚³ (elapsed, type, desc)
                
                # è®“æˆ‘å€‘çœ‹ _run_fastbreak çš„å¯¦ä½œ:
                # é€²çƒ -> record_score -> return 'score'
                # å¤±æ•— -> record_rebound(chaser) -> return 'turnover'
                
                if fb_res == 'score':
                    # å› ç‚ºå›å‚³ keep=Trueï¼Œä¸»è¿´åœˆæœƒèª¤ä»¥ç‚ºæ˜¯é€²æ”»ç±ƒæ¿è€Œä¸è¨ˆæ•¸
                    # æ‰€ä»¥é€™è£¡é å…ˆå¹« off_team è¨˜éŒ„ä¸‹ä¸€æ¬¡çš„çƒæ¬Š
                    AttributionSystem.record_possession(off_team)
                    return elapsed_fb, fb_desc, True # A æ‹¿å›çƒæ¬Š
                else:
                    # åŒä¸Šï¼Œoff_team ç²å¾—é˜²å®ˆç±ƒæ¿ï¼Œè¦–ç‚ºæ–°å›åˆé–‹å§‹
                    AttributionSystem.record_possession(off_team)
                    # å¿«æ”»å¤±æ•— (è¢« A å®ˆä½/æŠ“æ¿) -> A æ‹¿å›çƒæ¬Š
                    return elapsed_fb, fb_desc, True

            # 3. è™•ç†ç›´æ¥å‰å ´åˆ†æ”¯ (Skip Backcourt)
            elif res == 'steal_frontcourt':
                # ç›´æ¥é€²å…¥å‰å ´éšæ®µ (æ³¨æ„åƒæ•¸é †åºäº’æ›)
                # æ™‚é–“ç¹¼æ‰¿: å·²ç¶“éäº† elapsed_bc ç§’
                elapsed_fc, fc_res, fc_desc, ctx = self._run_frontcourt(def_team, off_team, elapsed_bc)
                
                if fc_res == 'shooting':
                    shoot_desc, shoot_keep = self._run_shooting(def_team, off_team, ctx)
                    # é€™è£¡ shoot_keep æ˜¯é‡å° def_team (ç¾åœ¨çš„é€²æ”»æ–¹) è€Œè¨€
                    # å¦‚æœ B æ¶åˆ°é€²æ”»ç±ƒæ¿ (True) -> ä¸‹ä¸€å›åˆ B ç¹¼çºŒæ”» -> possession éœ€åˆ‡æ›ç‚º B -> return False
                    # å¦‚æœ B é€²çƒ/è¢«æŠ“æ¿ (False) -> ä¸‹ä¸€å›åˆ A æ”» -> possession ç¶­æŒ A -> return True
                    return elapsed_bc + elapsed_fc, shoot_desc, not shoot_keep
                else:
                    # å‰å ´å¤±èª¤ (def_team å¤±èª¤) -> off_team æ‹¿å›çƒæ¬Š
                    # æ‰‹å‹•è£œ off_team çƒæ¬Š
                    AttributionSystem.record_possession(off_team) # <--- æ–°å¢é€™è¡Œ
                    # å‰å ´å¤±èª¤ (B å¤±èª¤) -> A æ‹¿å›çƒæ¬Š
                    return elapsed_bc + elapsed_fc, fc_desc, True

        # ============================================================
        # Phase 2: Frontcourt (å‰å ´)
        # ============================================================
        elapsed_fc, res, desc, ctx = self._run_frontcourt(off_team, def_team, elapsed_bc, is_oreb)
        total_elapsed = elapsed_bc + elapsed_fc
        
        if res != 'shooting': 
            return total_elapsed, desc, False

        # ============================================================
        # Phase 3: Shooting (æŠ•ç±ƒ)
        # ============================================================
        desc_shoot, keep = self._run_shooting(off_team, def_team, ctx)
        return total_elapsed, desc_shoot, keep

    def _run_backcourt(self, off_team: EngineTeam, def_team: EngineTeam, is_opening: bool):
        """
        (Spec 3) å¾Œå ´éšæ®µ
        æ›´æ–° v2.3: å¯¦ä½œé€Ÿåº¦ç¸½å’Œåˆ¤å®šçš„æ”»å®ˆè½‰æ›
        """
        bc_config = self.config.get('match_engine', {}).get('backcourt', {})
        params = bc_config.get('params', {})
        formulas = bc_config.get('formulas', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})

        # Calc Time
        off_sum = Calculator.get_team_attr_sum(off_team.on_court[:3], self._resolve_formula(formulas.get('off_sum', []), attr_pools), attr_pools)
        def_sum = Calculator.get_team_attr_sum(def_team.on_court[:3], self._resolve_formula(formulas.get('def_sum', []), attr_pools), attr_pools)
        
        if is_opening:
            final_time = params.get('opening_seconds', 2.0)
        else:
            base = rng.get_float(params.get('time_base_min', 1.0), params.get('time_base_max', 8.0))
            diff_mod = (def_sum - off_sum) * params.get('time_coeff', 0.008)
            
            # [New v2.4] é€Ÿåº¦æŠ˜æ‰£
            spd_formula = formulas.get('backcourt_speed', ['ath_speed'])
            spd_sum_off = Calculator.get_team_attr_sum(off_team.on_court[:3], spd_formula, attr_pools)
            avg_spd_off = spd_sum_off / 3.0 if spd_sum_off > 0 else 50.0
            spd_sum_def = Calculator.get_team_attr_sum(def_team.on_court[:3], spd_formula, attr_pools)
            avg_spd_def = spd_sum_def / 3.0 if spd_sum_def > 0 else 50.0
            
            discount_coeff = params.get('speed_discount_coeff', 0.1)
            discount_coeff_def = params.get('speed_discount_coeff_def', 0.5)
            discount_off = rng.get_float(0.0, avg_spd_off * discount_coeff)
            discount_def = rng.get_float(0.0, avg_spd_def * discount_coeff) * discount_coeff_def
            
            final_time = base + diff_mod - discount_off + discount_def
            
            # ç‰©ç†ä¸‹é™
            min_limit = params.get('min_time_limit', 0.5)
            final_time = max(min_limit, final_time)

        # 2. 8ç§’é•ä¾‹åˆ¤å®š (ä¿®æ”¹è¨˜éŒ„æ–¹æ³•)
        if final_time > params.get('violation_threshold', 8.0):
            # [Modified] æ”¹ç”¨å°ˆå±¬çš„ 8ç§’é•ä¾‹è¨˜éŒ„æ–¹æ³•
            AttributionSystem.record_8sec_violation(off_team)
            final_time = 8.0
            return final_time, 'turnover', f"{off_team.name} 8-sec Violation"
        
        # [Modified] æŠ„æˆªåˆ¤å®š
        if final_time > params.get('steal_threshold', 3.0):
            prob = params.get('steal_base_prob', 0.01) + (def_sum - off_sum) * params.get('steal_bonus_coeff', 0.001)
            
            if rng.decision(prob):
                stealer = AttributionSystem.determine_stealer(def_team, self.config)
                AttributionSystem.record_steal(stealer, off_team)
                
                # [New v2.4] æ”»å®ˆè½‰æ›åˆ¤å®š (Transition Decision)
                # 1. è¨ˆç®—é›™æ–¹å…¨éšŠé€Ÿåº¦ç¸½å’Œ
                spd_formula = formulas.get('team_speed_sum', ['ath_speed'])
                off_spd_sum = Calculator.get_team_attr_sum(off_team.on_court, spd_formula, attr_pools)
                def_spd_sum = Calculator.get_team_attr_sum(def_team.on_court, spd_formula, attr_pools)
                
                # 2. è¨ˆç®—è½‰æ›æ©Ÿç‡
                # å…¬å¼: 50% + (å®ˆæ–¹ç¸½å’Œ - æ”»æ–¹ç¸½å’Œ) / æ”»æ–¹ç¸½å’Œ
                base_prob = params.get('transition_base_prob', 0.50)
                ratio = 0.0
                if off_spd_sum > 0:
                    ratio = (def_spd_sum - off_spd_sum) / off_spd_sum
                
                transition_prob = base_prob + ratio
                
                # 3. åˆ¤å®šåˆ†æ”¯
                if rng.decision(transition_prob):
                    # è§¸ç™¼å¿«æ”»
                    return final_time, 'steal_fastbreak', f"{def_team.name} Steal & Fastbreak"
                else:
                    # è§¸ç™¼é™£åœ°æˆ° (ç›´æ¥é€²å‰å ´)
                    return final_time, 'steal_frontcourt', f"{def_team.name} Steal & Transition"

        # å¿«æ”»åˆ¤å®šï¼šéœ€åŒæ™‚æ»¿è¶³ã€Œæ™‚é–“é–€æª»ã€èˆ‡ã€Œæ©Ÿç‡æª¢å®šã€
        # 1. æª¢æŸ¥æ™‚é–“æ˜¯å¦å¤ å¿«
        if final_time < params.get('fastbreak_threshold', 1.0):
            # 2. å–å¾—è§¸ç™¼æ©Ÿç‡ (é è¨­ 0.5)
            fb_prob = params.get('fastbreak_trigger_prob', 0.5)
            
            # 3. é€²è¡Œæ©Ÿç‡éª°å­ (rng.random() æœƒå›å‚³ 0.0 ~ 1.0 ä¹‹é–“çš„æµ®é»æ•¸)
            if rng.decision(fb_prob):
                return self._run_fastbreak(off_team, def_team, final_time)
        
        return final_time, 'frontcourt', "Advance"

    def _run_frontcourt(self, off_team: EngineTeam, def_team: EngineTeam, elapsed_bc: float, is_oreb: bool = False):
        """(Spec 4) å‰å ´éšæ®µ [Update v2.4 é€Ÿåº¦æŠ˜æ‰£ & 24ç§’é•ä¾‹]"""
        # 1. è®€å–è¨­å®šæª”åƒæ•¸
        fc_config = self.config.get('match_engine', {}).get('frontcourt', {})
        params = fc_config.get('params', {})
        formulas = fc_config.get('formulas', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})
        
        ctx = {'quality': 0.0, 'spacing': 0.0}
        
        # 2. æ™‚é–“è¨ˆç®— (Time Calculation)
        # è¨ˆç®—åŸºæ–¼æ™ºå•†èˆ‡å‚³å°çš„æ™‚é–“ç¸®æ¸›é‡
        red_attr = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(formulas.get('time_reduction', []), attr_pools), attr_pools)
        reduction = (red_attr / 1000.0) * 0.5
        min_time = max(4.0, 4.0 - reduction)
        
        # è¨ˆç®—æœ¬å›åˆå‰©é¤˜å¯ç”¨çš„é€²æ”»æ™‚é–“ä¸Šé™ (24ç§’ - å¾Œå ´å·²ç”¨æ™‚é–“)
        # ç¢ºä¿ä¸Šé™è‡³å°‘æ¯”ä¸‹é™å¤§ 1.0 ç§’ï¼Œé¿å…éš¨æ©ŸéŒ¯èª¤
        # ä¿®æ”¹æ™‚é–“ä¸Šé™é‚è¼¯
        if is_oreb:
            # é€²æ”»ç±ƒæ¿ï¼šä¸Šé™å›ºå®š 14 ç§’ (ä¸”ä¸å—å¾Œå ´æ™‚é–“å½±éŸ¿ï¼Œå› ç‚ºæ²’å›å¾Œå ´)
            max_time = 14.0
            # ä¸‹é™ä¹Ÿè¦ç¢ºä¿åˆç†
            min_time = min(min_time, 13.0) 
        else:
            # ä¸€èˆ¬é€²æ”»ï¼š24 - å¾Œå ´æ™‚é–“
            max_time = max(min_time + 1.0, 24.0 - elapsed_bc)
        
        # åˆæ­¥éš¨æ©Ÿç”¢ç”ŸèŠ±è²»æ™‚é–“
        elapsed = rng.get_float(min_time, max_time)
        
        # [New v2.4] é€Ÿåº¦æŠ˜æ‰£ (Speed Discount)
        # è¨ˆç®—é€²æ”»æ–¹å ´ä¸Š 5 äººçš„é€Ÿåº¦ç¸½å’Œ
        spd_formula = formulas.get('frontcourt_speed', ['ath_speed'])
        spd_sum_off = Calculator.get_team_attr_sum(off_team.on_court, spd_formula, attr_pools)
        avg_spd_off = spd_sum_off / 5.0 if spd_sum_off > 0 else 50.0
        spd_sum_def = Calculator.get_team_attr_sum(def_team.on_court, spd_formula, attr_pools)
        avg_spd_def = spd_sum_def / 5.0 if spd_sum_def > 0 else 50.0
        
        # è¨ˆç®—æŠ˜æ‰£ç§’æ•¸ (é€Ÿåº¦è¶Šå¿«ï¼ŒèŠ±è²»æ™‚é–“è¶Šå°‘)
        discount_coeff = params.get('speed_discount_coeff', 0.1)
        discount_off = rng.get_float(0.0, avg_spd_off * discount_coeff)
        discount_def = rng.get_float(0.0, avg_spd_def * discount_coeff)
        
        # æ‡‰ç”¨æŠ˜æ‰£
        elapsed -= discount_off
        elapsed += discount_def
        
        # ç¢ºä¿ç‰©ç†æ™‚é–“ä¸‹é™ (ä¸èƒ½ä½æ–¼ 1.0 ç§’)
        abs_min = params.get('absolute_min_time', 1.0)
        elapsed = max(abs_min, elapsed)
        
        # 3. 24ç§’é•ä¾‹åˆ¤å®š (24-Sec Violation)
        # è‹¥ (å¾Œå ´æ™‚é–“ + å‰å ´æ™‚é–“) è¶…é 24 ç§’ï¼Œå‰‡åˆ¤å®šé•ä¾‹
        violation_limit = params.get('violation_threshold', 24.0)
        if (elapsed_bc + elapsed) > violation_limit:
            AttributionSystem.record_24sec_violation(off_team)
            elapsed = 24.0
            return elapsed, 'turnover', f"{off_team.name} 24ç§’é€²æ”»é•ä¾‹", ctx

        # 4. è¨ˆç®—å‡ºæ‰‹å“è³ª (Quality)
        # æ™‚é–“èŠ±è²»è¶Šå°‘ï¼Œå“è³ªè¶Šé«˜ (ä»£è¡¨è·‘å‡ºç©ºæª”æˆ–æµæš¢é…åˆ)
        if elapsed < 7.0: 
            ctx['quality'] = (7.0 - elapsed) * 0.01
        
        # 5. ç©ºé–“èˆ‡è·‘ä½åˆ¤å®š (Spacing)
        off_sp = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(formulas.get('spacing_off', []), attr_pools), attr_pools)
        def_sp = Calculator.get_team_attr_sum(def_team.on_court, self._resolve_formula(formulas.get('spacing_def', []), attr_pools), attr_pools) or 1
        
        # è¨ˆç®—ç©ºé–“åŠ æˆ (-1.0 ~ 1.0)
        sp_bonus = max(-1.0, min(1.0, (off_sp - def_sp)/def_sp + rng.get_float(-0.1, 0.1)))
        ctx['spacing'] = sp_bonus

        # 6. å°é˜»åˆ¤å®š (Block - Spec 4.3)
        # è‹¥ç©ºé–“æ“æ“  (sp_bonus <= 0.5)ï¼Œå°é˜»æ©Ÿç‡æå‡
        if sp_bonus <= 0.5:
            # --- Config Loading ---
            blk_config = fc_config.get('block', {})
            blk_params = blk_config.get('params', {})
            blk_formulas = blk_config.get('formulas', {})

            # --- éšæ®µä¸€ï¼šè§¸ç™¼åˆ¤å®š (Attempt Check) ---
            trigger_off_keys = self._resolve_formula(blk_formulas.get('trigger_off', ['off_move']), attr_pools)
            trigger_def_keys = self._resolve_formula(blk_formulas.get('trigger_def', ['def_contest', 'talent_defiq']), attr_pools)
            
            # è¨ˆç®—åœ˜éšŠè§¸ç™¼å€¼ (Team Sum)
            trig_off_val = Calculator.get_team_attr_sum(off_team.on_court, trigger_off_keys, attr_pools)
            trig_def_val = Calculator.get_team_attr_sum(def_team.on_court, trigger_def_keys, attr_pools)
            
            # è¨ˆç®—æ©Ÿç‡
            # åŸºç¤æ©Ÿç‡ 1%
            base_prob = blk_params.get('base_prob', 0.01)
            # å±¬æ€§ä¿®æ­£: (é˜²å®ˆ - é€²æ”») * 0.0001 (æ¯100é»å·®å€¼+1%)
            attr_mod = (trig_def_val - trig_off_val) * 0.0001
            # ç©ºé–“æ‡²ç½°: ç©ºé–“æ“æ“ æ™‚å¤§å¹…æå‡å°è“‹ç‡
            spacing_penalty = blk_params.get('spacing_penalty_prob', 0.05) if sp_bonus < 0 else 0.0
            
            attempt_prob = max(0.0, base_prob + attr_mod + spacing_penalty)
            
            if rng.decision(attempt_prob):
                # --- éšæ®µäºŒï¼šå°æŠ—åˆ¤å®š (Success Check) ---
                
                # 1. æ±ºå®šè§’è‰²
                # é æ¸¬å‡ºæ‰‹è€… (Shooter)
                shooter = AttributionSystem.determine_shooter(off_team, False, self.config)
                # æ±ºå®šå°ä½é˜²å®ˆè€… (Blocker) - ä¾æ“š Spec 6.6 å°è“‹æ­¸å±¬è¦å‰‡
                blocker = AttributionSystem.get_position_matchup(shooter, def_team)
                
                # 2. è¨ˆç®—å°æŠ—èƒ½åŠ› (Power)
                power_off_keys = self._resolve_formula(blk_formulas.get('power_off', ['ath_strength', 'ath_jump', 'talent_offiq', 'height']), attr_pools)
                power_def_keys = self._resolve_formula(blk_formulas.get('power_def', ['ath_strength', 'ath_jump', 'def_contest', 'talent_defiq', 'height']), attr_pools)
                
                p_off = Calculator.get_player_attr_sum(shooter, power_off_keys, attr_pools)
                p_def = Calculator.get_player_attr_sum(blocker, power_def_keys, attr_pools)
                
                # 3. è¨ˆç®—æˆåŠŸç‡
                # Spec: Ratio = Off / Def. æ•¸å€¼è¶Šä½é˜²å®ˆå„ªå‹¢è¶Šå¤§.
                # è½‰æ›ç‚ºæ©Ÿç‡: Def / (Off + Def)
                # è‹¥ Off=500, Def=500 -> 50% æ©Ÿç‡è“‹æ‰
                success_prob = p_def / (p_off + p_def) if (p_off + p_def) > 0 else 0.5
                
                if rng.decision(success_prob):
                    # å°è“‹æˆåŠŸ -> å¤±èª¤
                    AttributionSystem.record_block(blocker, shooter)
                    return elapsed, 'turnover', f"{def_team.name} {blocker.name} å°é˜»æˆåŠŸ (Block {shooter.name})", ctx
                else:
                    # å°è“‹å¤±æ•— -> é€²æ”»æ–¹å¼·è¡Œå‡ºæ‰‹ (ç¹¼çºŒæµç¨‹)
                    # å¯ä»¥åœ¨ ctx ä¸­æ¨™è¨˜ 'contested'ï¼Œå½±éŸ¿å¾ŒçºŒå‘½ä¸­ç‡æˆ–çŠ¯è¦ç‡ (Optional)
                    ctx['is_contested'] = True

        # 7. æŠ„æˆªåˆ¤å®š (Steal - Spec 4.4 Full Implementation)
        # è®€å–è¨­å®š
        stl_config = fc_config.get('steal', {})
        stl_params = stl_config.get('params', {})
        stl_formulas = stl_config.get('formulas', {})

        # 1. è§£æå±¬æ€§å…¬å¼ (Spec: Off_Ball vs Def_Steal)
        # é è¨­å€¼å°æ‡‰ YAML: off_dribble+off_handle+off_pass+off_iq-height
        off_keys = self._resolve_formula(stl_formulas.get('off_attr', []), attr_pools)
        # é è¨­å€¼å°æ‡‰ YAML: speed+def_disrupt+def_iq-height
        def_keys = self._resolve_formula(stl_formulas.get('def_attr', []), attr_pools)

        # 2. è¨ˆç®—åœ˜éšŠå±¬æ€§ç¸½å’Œ
        # é€™è£¡ä½¿ç”¨åœ˜éšŠç¸½å’Œä¾†ä»£è¡¨ç•¶ä¸‹é˜²å®ˆå£“è¿«åŠ›èˆ‡é€²æ”»ç©©å®šåº¦
        off_val = Calculator.get_team_attr_sum(off_team.on_court, off_keys, attr_pools)
        def_val = Calculator.get_team_attr_sum(def_team.on_court, def_keys, attr_pools)

        # 3. è¨ˆç®—æœ€çµ‚æ©Ÿç‡
        base_prob = stl_params.get('base_prob', 0.01)       # åŸºç¤ 1%
        coeff = stl_params.get('stat_diff_coeff', 0.001)    # ä¿‚æ•¸ 0.1%
        
        # å…¬å¼: 1% + (Def_Steal - Off_Ball) * ä¿‚æ•¸
        final_prob = max(0.001, base_prob + (def_val - off_val) * coeff)

        if rng.decision(final_prob):
            # æ±ºå®šæŠ„æˆªè€… (Spec 6.5)
            stealer = AttributionSystem.determine_stealer(def_team, self.config)
            # è¨˜éŒ„æŠ„æˆªèˆ‡å¤±èª¤ (Spec 6.7)
            AttributionSystem.record_steal(stealer, off_team)
            return elapsed, 'turnover', f"{def_team.name} {stealer.name} å‰å ´æŠ„æˆª", ctx

        # 8. é€²å…¥æŠ•ç±ƒéšæ®µ
        return elapsed, 'shooting', "æŠ•ç±ƒå‡ºæ‰‹", ctx

    def _run_fastbreak(self, off_team: EngineTeam, def_team: EngineTeam, elapsed: float) -> Tuple[float, str, str]:
        """
        (Spec 3.5) å¿«æ”»åˆ¤å®š (Fastbreak)
        ä¾æ“šè¦æ ¼æ›¸ v2.4 å®Œæ•´å¯¦ä½œï¼šåƒèˆ‡è€…ç¯©é¸ -> æˆåŠŸç‡è¨ˆç®— -> çŠ¯è¦åˆ¤å®š -> å››ç¨®çµæœçµç®—
        """
        fb_config = self.config.get('match_engine', {}).get('backcourt', {}).get('fastbreak', {})
        params = fb_config.get('params', {})
        formulas = fb_config.get('formulas', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})
        
        # 1. åƒèˆ‡è€…ç¯©é¸ (Participants)
        # é€²æ”»è€… (Runner): å–å ´ä¸Š (é€Ÿåº¦ + é‹çƒ) æœ€é«˜è€…
        runner_keys = self._resolve_formula(formulas.get('runner_selection', ['ath_speed', 'off_dribble']), attr_pools)
        runner = max(off_team.on_court, key=lambda p: Calculator.get_player_attr_sum(p, runner_keys, attr_pools))
        
        # é˜²å®ˆè€… (Chaser): å–å ´ä¸Š (é€Ÿåº¦ + é˜²å®ˆæ™ºå•†) æœ€é«˜è€…
        chaser_keys = self._resolve_formula(formulas.get('chaser_selection', ['ath_speed', 'talent_defiq']), attr_pools)
        chaser = max(def_team.on_court, key=lambda p: Calculator.get_player_attr_sum(p, chaser_keys, attr_pools))
        
        # 2. é€²çƒæˆåŠŸç‡ (Success Rate)
        # åŸºç¤æˆåŠŸç‡: éš¨æ©Ÿ 0.3 ~ 1.0
        base_rate = rng.get_float(params.get('base_success_min', 0.3), params.get('base_success_max', 1.0))
        
        # å±¬æ€§ä¿®æ­£: (Off_Stat - Def_Stat) * 0.5%
        off_power = Calculator.get_player_attr_sum(runner, self._resolve_formula(formulas.get('off_power', []), attr_pools), attr_pools)
        def_power = Calculator.get_player_attr_sum(chaser, self._resolve_formula(formulas.get('def_power', []), attr_pools), attr_pools)
        diff_mod = (off_power - def_power) * params.get('stat_diff_coeff', 0.005)
        
        final_success_rate = min(1.0, base_rate + diff_mod)
        is_success = rng.decision(final_success_rate)
        
        # [Phase 2] è¨˜éŒ„å¿«æ”»äº‹ä»¶ (ç„¡è«–çµæœå¦‚ä½•éƒ½è¨˜éŒ„å˜—è©¦)
        AttributionSystem.record_fastbreak_event(off_team, runner, is_success)

        # 3. çŠ¯è¦åˆ¤å®š (Foul Check)
        # æ ¸å¿ƒå±¬æ€§: é€²æ”»æ™ºå•† vs é˜²å®ˆæ™ºå•†
        off_iq = Calculator.get_player_attr_sum(runner, self._resolve_formula(formulas.get('foul_off_iq', ['talent_offiq']), attr_pools), attr_pools)
        def_iq = Calculator.get_player_attr_sum(chaser, self._resolve_formula(formulas.get('foul_def_iq', ['talent_defiq']), attr_pools), attr_pools)
        
        # çŠ¯è¦æ©Ÿç‡: 1% + (Off_IQ - Def_IQ) * 1%
        foul_base = params.get('foul_base_prob', 0.01)
        foul_coeff = params.get('foul_iq_coeff', 0.01)
        foul_prob = max(0.001, foul_base + (off_iq - def_iq) * foul_coeff)
        
        is_foul = rng.decision(foul_prob)

        # 4. æœ€çµ‚çµæœçµç®— (Outcome)
        log_desc = ""
        res_type = ""

        if is_success:
            # --- æƒ…æ³ A & B: å¿«æ”»é€²çƒ ---
            AttributionSystem.record_score(off_team, runner, 2, False)
            AttributionSystem.update_plus_minus(off_team, def_team, 2)
            
            if is_foul:
                # [æƒ…æ³ B] é€²ç®—åŠ ç½° (And-1)
                AttributionSystem.record_foul(chaser)
                self._check_and_handle_foul_out(def_team, chaser)
                made = self._run_free_throw(off_team, def_team, runner, 1)
                log_desc = f"{off_team.name} {runner.name} å¿«æ”»é€²ç®—åŠ ç½° (And-1, FT {made}/1)"
                res_type = 'score'
            else:
                # [æƒ…æ³ A] å¿«æ”»å¾—åˆ†
                log_desc = f"{off_team.name} {runner.name} å¿«æ”»å¾—åˆ†"
                res_type = 'score'
        else:
            # --- æƒ…æ³ C & D: å¿«æ”»å¤±æ•— ---
            if is_foul:
                # [æƒ…æ³ C] é˜»æ“‹/æ‰“æ‰‹çŠ¯è¦ (ç½°çƒ 2 æ¬¡)
                AttributionSystem.record_foul(chaser)
                self._check_and_handle_foul_out(def_team, chaser)
                made = self._run_free_throw(off_team, def_team, runner, 2)
                log_desc = f"{off_team.name} {runner.name} å¿«æ”»é­çŠ¯è¦ (FT {made}/2)"
                # é›–ç„¶æ²’é€²çƒï¼Œä½†æœ‰ç½°çƒç”¢å‡ºï¼Œè¦–åŒå¾—åˆ†æµç¨‹çµæŸï¼Œå›å‚³ score é¡å‹ä»¥è§¸ç™¼æ”»å®ˆäº¤æ›
                res_type = 'score' 
            else:
                # [æƒ…æ³ D] é˜²å®ˆæˆåŠŸ (è¦–ç‚ºå¤±èª¤/è¢«æ“‹ä¸‹)
                # æ­¸å±¬é˜²å®ˆç±ƒæ¿çµ¦è¿½é˜²è€… (æˆ–å¯è¦–ç‚ºç«é‹ï¼Œæ­¤è™•ä¾ Spec ç°¡åŒ–ç‚ºé˜²å®ˆæˆåŠŸ)
                AttributionSystem.record_rebound(chaser, False)
                log_desc = f"{off_team.name} {runner.name} å¿«æ”»å¤±æ•— (è¢« {chaser.name} æ“‹ä¸‹)"
                res_type = 'turnover'

        return elapsed, res_type, log_desc

    def _run_shooting(self, off_team: EngineTeam, def_team: EngineTeam, ctx: Dict) -> Tuple[str, bool]:
        """
        [Spec 5] æŠ•ç±ƒçµç®—
        """
        sht_config = self.config.get('match_engine', {}).get('shooting', {})
        params = sht_config.get('params', {})
        formulas = sht_config.get('formulas', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})

        # 1. Type (æ±ºå®šæ˜¯ 2åˆ† æˆ– 3åˆ†)
        # é€™éƒ¨åˆ†æ¶‰åŠéš¨æ©Ÿåˆ¤å®šï¼Œä¿ç•™åœ¨ Core ä¸­
        range_sum = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(formulas.get('range_attr', []), attr_pools), attr_pools) or 1
        threshold = 1.0 / (range_sum / 100.0)
        is_3pt = rng.get_float(0.0, 1.0) > threshold
        points = 3 if is_3pt else 2

        # 2. Shooter (æ±ºå®šå‡ºæ‰‹è€…)
        shooter = AttributionSystem.determine_shooter(off_team, is_3pt, self.config)

        # 3. Hit Rate (å‘½ä¸­ç‡è¨ˆç®—) - [Refactored] å®Œå…¨å‘¼å« Calculator
        hit_rate = Calculator.calculate_shooting_rate(
          off_players=off_team.on_court,  # é€²æ”»å…¨éšŠ (ç”¨æ–¼å°æŠ—)
          def_players=def_team.on_court,  # é˜²å®ˆå…¨éšŠ (ç”¨æ–¼å°æŠ—)
          shooter=shooter,                # å‡ºæ‰‹è€… (ç”¨æ–¼æŠ€å·§åŠ æˆ)
          config=self.config,
          spacing_factor=ctx.get('spacing', 0.0),
          quality_bonus=ctx.get('quality', 0.0),
          is_3pt=is_3pt
        )
        
        is_hit = rng.decision(hit_rate)

        # 4. Foul (çŠ¯è¦åˆ¤å®š)
        off_iq = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(formulas.get('foul_off_iq', []), attr_pools), attr_pools)
        def_iq = Calculator.get_team_attr_sum(def_team.on_court, self._resolve_formula(formulas.get('foul_def_iq', []), attr_pools), attr_pools) or 1
        foul_prob = max(0.01, (off_iq - def_iq) / def_iq)
        is_foul = rng.decision(foul_prob)
        
        log = ""
        keep = False

        if is_hit:
            AttributionSystem.record_score(off_team, shooter, points, is_3pt)
            # [New] æ›´æ–° +/-
            AttributionSystem.update_plus_minus(off_team, def_team, points)
            
            log = f"{off_team.name} {shooter.name} {points}pt Good"
            
            # Assist
            ast_config = sht_config.get('assist', {})
            ast_formulas = ast_config.get('formulas', {})
            team_stat = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(ast_formulas.get('team_stat', []), attr_pools), attr_pools)
            luck_stat = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(ast_formulas.get('luck_stat', []), attr_pools), attr_pools) or 1
            
            ast_prob = (team_stat / (1.0/luck_stat)) * params.get('assist_prob_coeff', 0.1)
            
            if rng.decision(ast_prob):
                passer = AttributionSystem.determine_assist_provider(off_team, shooter, self.config)
                if passer:
                    AttributionSystem.record_assist(passer)
                    log += f" (Ast {passer.name})"
            
            if is_foul:
                fouler = rng.choice(def_team.on_court)
                AttributionSystem.record_foul(fouler)
                # [Update] å‚³å…¥ def_team ä»¥è¨ˆç®— +/-
                self._run_free_throw(off_team, def_team, shooter, 1)
                log += " (And-1)"
                # [æ–°å¢] æª¢æŸ¥æ˜¯å¦çŠ¯æ»¿é›¢å ´
                self._check_and_handle_foul_out(def_team, fouler)
        else:
            AttributionSystem.record_attempt(shooter, is_3pt)
            log = f"{off_team.name} {shooter.name} {points}pt Miss"
            
            if is_foul:
                fouler = rng.choice(def_team.on_court)
                AttributionSystem.record_foul(fouler)
                ft_count = 3 if is_3pt else 2
                # [Update] å‚³å…¥ def_team ä»¥è¨ˆç®— +/-
                made = self._run_free_throw(off_team, def_team, shooter, ft_count)
                log += f" (Foul {made}/{ft_count})"
                # [æ–°å¢] æª¢æŸ¥æ˜¯å¦çŠ¯æ»¿é›¢å ´
                self._check_and_handle_foul_out(def_team, fouler)
            else:
                # Rebound
                reb_config = sht_config.get('rebound', {})
                reb_formulas = reb_config.get('formulas', {})
                
                off_reb_attr = Calculator.get_team_attr_sum(off_team.on_court, self._resolve_formula(reb_formulas.get('off_attr', []), attr_pools), attr_pools)
                def_reb_attr = Calculator.get_team_attr_sum(def_team.on_court, self._resolve_formula(reb_formulas.get('def_attr', []), attr_pools), attr_pools)
                
                dr_prob = 0.10 + (def_reb_attr / (off_reb_attr + def_reb_attr or 1))
                
                if rng.decision(dr_prob):
                    rebounder = AttributionSystem.determine_rebounder(off_team, def_team, True, self.config)
                    AttributionSystem.record_rebound(rebounder, False)
                    log += f" (Reb {rebounder.name})"
                    keep = False
                else:
                    rebounder = AttributionSystem.determine_rebounder(off_team, def_team, False, self.config)
                    AttributionSystem.record_rebound(rebounder, True)
                    log += f" (Off Reb {rebounder.name})"
                    keep = True

        return log, keep

    def _run_free_throw(self, team: EngineTeam, def_team: EngineTeam, shooter: EnginePlayer, count: int) -> int:
        """
        [Update] æ–°å¢ def_team åƒæ•¸ä»¥æ”¯æ´ +/- è¨ˆç®—
        """
        made = 0
        ft_config = self.config.get('match_engine', {}).get('shooting', {}).get('ft', {})
        params = ft_config.get('params', {})
        formulas = ft_config.get('formulas', {})
        attr_pools = self.config.get('match_engine', {}).get('attr_pools', {})
        
        base = rng.get_float(params.get('base_min', 0.40), params.get('base_max', 0.95))
        bonus_formula = self._resolve_formula(formulas.get('bonus_attrs', ['talent_luck', 'shot_touch']), attr_pools)
        attr_sum = Calculator.get_player_attr_sum(shooter, bonus_formula, attr_pools)
        
        prob = min(0.99, max(0.01, base + attr_sum * params.get('attr_coeff', 0.0001)))

        for _ in range(count):
            if rng.decision(prob):
                AttributionSystem.record_free_throw(team, shooter, True)
                # [New] æ›´æ–° +/-
                AttributionSystem.update_plus_minus(team, def_team, 1)
                made += 1
            else:
                AttributionSystem.record_free_throw(team, shooter, False)
        return made
    def _check_and_handle_foul_out(self, team: EngineTeam, player: EnginePlayer):
        """
         æª¢æŸ¥ä¸¦è™•ç†çŠ¯æ»¿é›¢å ´
        é‚è¼¯ï¼š
        1. è‹¥çŠ¯è¦æ•¸é”æ¨™ï¼Œå¼·åˆ¶å¾ on_court ç§»é™¤ã€‚
        2. å°‡è©²çƒå“¡å‰©é¤˜çš„ target_seconds æŒ‰æ¯”ä¾‹åˆ†é…çµ¦å…¶ä»–æœªçŠ¯æ»¿çƒå“¡ã€‚
        3. å¾ bench æŒ‘é¸æ›¿è£œä¸Šå ´ã€‚
        """
        # [Correction] ç›´æ¥è®€å– .foulsï¼Œé¿å… getattr é è¨­å€¼ 0 å°è‡´çš„é‚è¼¯å¤±æ•ˆ
        # EnginePlayer ä½¿ç”¨ __slots__ï¼Œç›´æ¥å­˜å–æ¯” getattr å¿«ä¸”å®‰å…¨
        current_fouls = player.fouls
        
        if current_fouls >= self.foul_limit:
            player.is_fouled_out = True 
            self.pbp_logs.append(f"{team.name} {player.name} Fouled Out ({current_fouls})")
            
            # 1. å¾å ´ä¸Šç§»é™¤
            if player in team.on_court:
                team.on_court.remove(player)
            
            # =================================================================
            # [æ–°å¢é‚è¼¯] æ™‚é–“é‡æ–°åˆ†é… (Redistribute Minutes)
            # =================================================================
            # è¨ˆç®—è©²çƒå“¡åŸæœ¬é è¨ˆé‚„è¦æ‰“å¤šä¹…
            remaining_seconds = max(0.0, player.target_seconds - player.seconds_played)
            
            # å°‡çŠ¯æ»¿çƒå“¡çš„ç›®æ¨™æ™‚é–“é–å®šç‚ºã€Œå·²ä¸Šå ´æ™‚é–“ã€ï¼Œç¢ºä¿ç³»çµ±ä¸å†åˆ†é…æ™‚é–“çµ¦ä»–
            player.target_seconds = player.seconds_played
            
            if remaining_seconds > 0:
                # [ä¿®æ­£] Spec 2.6 é‚è¼¯: C->PF->SF->SG->PG å„å–å‰3åï¼Œå…±15å€‹ slot
                # æ’é™¤å·²çŠ¯æ»¿è€…
                valid_players = [p for p in (team.on_court + team.bench) if not p.is_fouled_out]
                
                if valid_players:
                    # æ‰¾å‡ºé€™ 15 å€‹ slot çš„æ­¸å±¬è€…
                    slots = []
                    positions = ["C", "PF", "SF", "SG", "PG"]
                    top_k = 3
                    
                    for pos in positions:
                        # è©²ä½ç½®è©•åˆ†å‰ K å
                        sorted_by_pos = sorted(valid_players, key=lambda p: p.pos_scores.get(pos, 0), reverse=True)
                        slots.extend(sorted_by_pos[:top_k])
                    
                    # å¹³å‡åˆ†é…çµ¦é€™äº› slot
                    if slots:
                        time_per_slot = remaining_seconds / len(slots)
                        for receiver in slots:
                            receiver.target_seconds += time_per_slot
                        
                    # è¨˜éŒ„æ—¥èªŒä»¥ä¾¿é™¤éŒ¯
                    # self.pbp_logs.append(f"Debug: Redistributed {remaining_seconds:.1f}s among {len(valid_recipients)} players")
            # =================================================================

            # 2. å°‹æ‰¾æ›¿è£œ (æ’é™¤åŒæ¨£çŠ¯æ»¿çš„çƒå“¡)
            candidates = [
                p for p in team.bench 
                if not p.is_fouled_out
            ]
            
            if not candidates:
                # æ¥µç«¯ä¿è­·ï¼šè‹¥æ¿å‡³å…¨çŠ¯æ»¿ï¼Œå¼·åˆ¶è®“åŸçƒå“¡ç¹¼çºŒæ‰“ä»¥é˜² Crashï¼Œä¸¦è¨˜éŒ„è­¦å‘Š
                # æ³¨æ„ï¼šé›–ç„¶å‰é¢æŠŠæ™‚é–“åˆ†é…æ‰äº†ï¼Œä½†ç‚ºäº†ä¸è®“ç¨‹å¼å´©æ½°ï¼Œé‚„æ˜¯å¾—è®“ä»–ä¸Š
                team.on_court.append(player)
                self.pbp_logs.append(f"WARNING: No available subs for {team.name}, {player.name} stays on court.")
                return

            # 3. æŒ‘é¸æœ€ä½³æ›¿è£œ (å„ªå…ˆåŒä½ç½®ï¼Œå…¶æ¬¡æœ€é«˜åˆ†)
            sub = None
            target_pos = getattr(player, 'position', 'C')
            
            pos_candidates = [p for p in candidates if p.pos_scores.get(target_pos, 0) > 0]
            if pos_candidates:
                sub = max(pos_candidates, key=lambda p: p.pos_scores.get(target_pos, 0))
            else:
                sub = max(candidates, key=lambda p: sum(p.pos_scores.values()))
            
            # 4. åŸ·è¡Œæ›¿æ›
            team.bench.remove(sub)
            sub.position = target_pos # ç¹¼æ‰¿ä½ç½®
            team.on_court.append(sub)
            
            # å°‡çŠ¯æ»¿çƒå“¡ç§»è‡³æ¿å‡³
            team.bench.append(player)
            
            self.pbp_logs.append(f"Substitution: {sub.name} replaces {player.name} (Foul Out)")
```

---

### ğŸ“„ File: `app\services\match_engine\service.py`

```python
# app/services/match_engine/service.py

from app.models.player import Player
# [ä¿®æ­£] Team å®šç¾©åœ¨ app.models.team
from app.models.team import Team
from app.services.match_engine.structures import EngineTeam, EnginePlayer

class DBToEngineAdapter:
    """
    è² è²¬å°‡è³‡æ–™åº«æ¨¡å‹ (SQLAlchemy Models) è½‰æ›ç‚º æ¯”è³½å¼•æ“æ¨¡å‹ (Dataclasses)
    """
    
    @staticmethod
    def convert_player(db_player: Player) -> EnginePlayer:
        # è§£æ JSON stats
        stats = db_player.detailed_stats or {}
        phy = stats.get('physical', {})
        off = stats.get('offense', {})
        def_ = stats.get('defense', {})
        men = stats.get('mental', {})

        # å˜—è©¦å¾ contract ç²å–è§’è‰²ï¼Œè‹¥ç„¡å‰‡é è¨­ Bench
        role = 'Bench'
        if db_player.contract:
            role = db_player.contract.role

        # ç°¡å–®è©•ç´šæ¨å°
        grade = "B" 
        if db_player.rating:
            if db_player.rating >= 950: grade = "SSR"
            elif db_player.rating >= 900: grade = "SS"
            elif db_player.rating >= 800: grade = "S"
            elif db_player.rating >= 700: grade = "A"
            elif db_player.rating >= 600: grade = "B"
            elif db_player.rating >= 400: grade = "C"
            else: grade = "G"

        return EnginePlayer(
            id=str(db_player.id),
            name=db_player.name,
            nationality=db_player.nationality,
            position=db_player.position,
            role=role,
            grade=grade,
            height=float(db_player.height),
            age=db_player.age,
            
            # --- å±¬æ€§å°æ‡‰ (Mapping) ---
            ath_stamina=float(phy.get('stamina', 50)),
            ath_strength=float(phy.get('strength', 50)),
            ath_speed=float(phy.get('speed', 50)),
            ath_jump=float(phy.get('jumping', 50)),
            talent_health=float(phy.get('health', 50)),
            
            shot_touch=float(off.get('touch', 50)),
            shot_release=float(off.get('release', 50)),
            shot_accuracy=float(off.get('accuracy', 50)),
            shot_range=float(off.get('range', 50)),
            
            off_pass=float(off.get('passing', 50)),
            off_dribble=float(off.get('dribble', 50)),
            off_handle=float(off.get('handle', 50)),
            off_move=float(off.get('move', 50)),
            
            def_rebound=float(def_.get('rebound', 50)),
            def_boxout=float(def_.get('boxout', 50)),
            def_contest=float(def_.get('contest', 50)),
            def_disrupt=float(def_.get('disrupt', 50)),
            
            talent_offiq=float(men.get('off_iq', 50)),
            talent_defiq=float(men.get('def_iq', 50)),
            talent_luck=float(men.get('luck', 50)),
            
            attr_sum=db_player.rating or 0
        )

    @staticmethod
    def convert_team(db_team: Team) -> EngineTeam:
        roster = [DBToEngineAdapter.convert_player(p) for p in db_team.players]
        return EngineTeam(
            id=str(db_team.id),
            name=db_team.name,
            roster=roster
        )
```

---

### ğŸ“„ File: `app\services\match_engine\structures.py`

```python
# app/services/match_engine/structures.py

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any

# [Optimization] ä½¿ç”¨ slots=True
# åŸç†ï¼šPython é è¨­ä½¿ç”¨ __dict__ å­—å…¸å„²å­˜ç‰©ä»¶å±¬æ€§ï¼Œé€™æœƒæ¶ˆè€—å¤§é‡è¨˜æ†¶é«”ã€‚
# slots=True å‘Šè¨´ç›´è­¯å™¨é å…ˆåˆ†é…å›ºå®šçš„è¨˜æ†¶é«”ç©ºé–“çµ¦é€™äº›å±¬æ€§ã€‚
# æ•ˆç›Šï¼šè¨˜æ†¶é«”ä½”ç”¨æ¸›å°‘ç´„ 40-50%ï¼Œå±¬æ€§å­˜å–é€Ÿåº¦æå‡ç´„ 20%ã€‚
# å°æ–¼ 1 å„„å ´æ¨¡æ“¬ (æ¶‰åŠæ•¸åå„„æ¬¡å±¬æ€§è®€å–) è‡³é—œé‡è¦ã€‚

@dataclass(slots=True)
class EnginePlayer:
    """
    æ¯”è³½å¼•æ“å°ˆç”¨çƒå“¡ç‰©ä»¶ (Level 4 - Phase 2 Ready)
    åŒ…å«åŸºæœ¬è³‡è¨Šã€èƒ½åŠ›å±¬æ€§ã€ä»¥åŠå®Œæ•´çš„æ¯”è³½çµ±è¨ˆæ•¸æ“šã€‚
    """
    # --- 1. è­˜åˆ¥èˆ‡åŸºæœ¬è³‡è¨Š ---
    id: str
    name: str
    nationality: str # æ–°å¢åœ‹ç±æ¬„ä½ (Spec v3.4)
    position: str  # ç•¶å‰å ´ä¸Šä½ç½® (PG, SG, SF, PF, C)
    role: str      # åˆç´„è§’è‰² (Star, Starter, etc.) - ç”¨æ–¼è¨ˆç®—ä¸Šå ´æ™‚é–“æ¬Šé‡
    grade: str     # ç­‰ç´š (SSR, S, etc.) - ç”¨æ–¼ Phase 2 æ•¸æ“šåˆ†æ
    height: float  # èº«é«˜ (cm)
    age: int # å¹´é½¡
    
    # --- 2. é«”åŠ›ç³»çµ± (Spec 2) ---
    current_stamina: float = 100.0
    stamina_coeff: float = 1.0  # ç•¶å‰èƒ½åŠ›ä¿®æ­£ä¿‚æ•¸ (é«”åŠ›ä½æ–¼ 80 é–‹å§‹è¡°é€€)
    
    # --- 3. ä¸Šå ´æ™‚é–“ç®¡ç† (Spec 1.4 & 2.6) ---
    target_seconds: float = 0.0 # ç›®æ¨™ä¸Šå ´ç§’æ•¸ (ç”± Minutes Distribution è¨ˆç®—)
    seconds_played: float = 0.0 # å·²ä¸Šå ´ç§’æ•¸
    is_fouled_out: bool = False # æ˜¯å¦çŠ¯æ»¿é›¢å ´
    
    # --- 4. å±¬æ€§ç·©å­˜ (Spec 2.3) ---
    # ç‚ºäº†æ•ˆèƒ½ï¼Œæˆ‘å€‘å°‡ DB ä¸­çš„å·¢ç‹€çµæ§‹ (physical.strength) å±•å¹³ç‚ºå–®å±¤å±¬æ€§ã€‚
    
    # ä¸å¯è¨“ç·´å±¬æ€§ (Untrainable)
    ath_stamina: float = 0.0
    ath_strength: float = 0.0
    ath_speed: float = 0.0
    ath_jump: float = 0.0
    talent_health: float = 0.0
    shot_touch: float = 0.0
    shot_release: float = 0.0
    talent_offiq: float = 0.0
    talent_defiq: float = 0.0
    talent_luck: float = 0.0
    
    # å¯è¨“ç·´å±¬æ€§ (Trainable)
    shot_accuracy: float = 0.0
    shot_range: float = 0.0
    off_pass: float = 0.0
    off_dribble: float = 0.0
    off_handle: float = 0.0
    off_move: float = 0.0
    def_rebound: float = 0.0
    def_boxout: float = 0.0
    def_contest: float = 0.0
    def_disrupt: float = 0.0 # æŠ„æˆª
    
    # å±¬æ€§ç¸½å’Œ (ç”¨æ–¼ Phase 2 é©—è­‰ "èƒ½åŠ›èˆ‡è¡¨ç¾ç›¸é—œæ€§")
    attr_sum: int = 0
    
    # --- 5. ä½ç½®è©•åˆ†ç·©å­˜ (Spec 1.1) ---
    # å„²å­˜è©²çƒå“¡åœ¨ 5 å€‹ä½ç½®çš„é©æ€§åˆ†æ•¸ï¼Œé¿å…é‡è¤‡è¨ˆç®—
    pos_scores: Dict[str, float] = field(default_factory=dict)
    
    # --- 6. çµ±è¨ˆæ•¸æ“š (Spec 7.2 Output Data) ---
    # é€™äº›æ¬„ä½å°‡æ§‹æˆ Box Scoreï¼Œç”¨æ–¼ Phase 2 çš„å¤§æ•¸æ“šåˆ†æ
    
    # åŸºç¤æ•¸æ“š
    stat_pts: int = 0   # å¾—åˆ†
    stat_reb: int = 0   # ç¸½ç±ƒæ¿
    stat_ast: int = 0   # åŠ©æ”»
    stat_stl: int = 0   # æŠ„æˆª
    stat_blk: int = 0   # é˜»æ”»
    stat_tov: int = 0   # å€‹äººå¤±èª¤
    fouls: int = 0      # çŠ¯è¦æ¬¡æ•¸
    stat_plus_minus: int = 0 # æ­£è² å€¼ (+/-)
    
    # æŠ•ç±ƒç´°é …
    stat_fgm: int = 0   # æŠ•ç±ƒå‘½ä¸­ (å«2åˆ†èˆ‡3åˆ†)
    stat_fga: int = 0   # æŠ•ç±ƒå‡ºæ‰‹
    stat_3pm: int = 0   # ä¸‰åˆ†å‘½ä¸­
    stat_3pa: int = 0   # ä¸‰åˆ†å‡ºæ‰‹
    stat_ftm: int = 0   # ç½°çƒå‘½ä¸­
    stat_fta: int = 0   # ç½°çƒå‡ºæ‰‹
    
    # é€²éšæ•¸æ“š
    stat_orb: int = 0   # é€²æ”»ç±ƒæ¿
    stat_drb: int = 0   # é˜²å®ˆç±ƒæ¿
    
    # [Phase 2 æ–°å¢] å¿«æ”»æ•¸æ“š
    # ç”¨æ–¼é©—è­‰ "é€Ÿåº¦" å±¬æ€§æ˜¯å¦æ­£ç¢ºè½‰åŒ–ç‚ºå¿«æ”»å¾—åˆ†
    stat_fb_made: int = 0    # å¿«æ”»é€²çƒæ•¸
    stat_fb_attempt: int = 0 # å¿«æ”»å˜—è©¦æ•¸
    
    # [Phase 2 æ–°å¢] é«”åŠ›åˆ†æ
    # è¨˜éŒ„æ¯”è³½çµæŸæ™‚çš„å‰©é¤˜é«”åŠ›ï¼Œç”¨æ–¼åˆ†æé«”åŠ›æ¶ˆè€—èˆ‡ä¸Šå ´æ™‚é–“çš„é—œä¿‚
    stat_remaining_stamina: float = 0.0

@dataclass(slots=True)
class EngineTeam:
    """
    æ¯”è³½å¼•æ“å°ˆç”¨çƒéšŠç‰©ä»¶
    """
    id: str
    name: str
    roster: List[EnginePlayer]
    
    # å‹•æ…‹é™£å®¹ç®¡ç†
    on_court: List[EnginePlayer] = field(default_factory=list) # å ´ä¸Š 5 äºº
    bench: List[EnginePlayer] = field(default_factory=list)    # æ¿å‡³çƒå“¡
    best_five: List[Optional[EnginePlayer]] = field(default_factory=list) # æœ€å¼· 5 äºº
    
    # åœ˜éšŠçµ±è¨ˆ (Spec 7.3)
    score: int = 0
    stat_tov: int = 0 # åœ˜éšŠå¤±èª¤ (å¦‚ 8ç§’é•ä¾‹/24ç§’é•ä¾‹)
    
    # [New v2.4] é•ä¾‹çµ±è¨ˆ
    stat_violation_8s: int = 0
    stat_violation_24s: int = 0
    
    # [Phase 2 æ–°å¢] é€²éšåœ˜éšŠæ•¸æ“š
    stat_possessions: int = 0 # å›åˆæ•¸ (ç”¨æ–¼è¨ˆç®— Pace)
    stat_possession_seconds: float = 0.0 # ç´¯ç©é€²æ”»æ™‚é–“ (ç§’)
    stat_possession_history: List[float] = field(default_factory=list) # è¨˜éŒ„æ¯ä¸€å›åˆçš„æ™‚é–“ (List)
    stat_fb_made: int = 0     # åœ˜éšŠå¿«æ”»é€²çƒ
    stat_fb_attempt: int = 0  # åœ˜éšŠå¿«æ”»å˜—è©¦

@dataclass(slots=True)
class MatchState:
    """
    æ¯”è³½ç‹€æ…‹è¿½è¹¤
    """
    quarter: int = 1
    time_remaining: float = 720.0
    game_time_elapsed: float = 0.0
    possession: str = "" # ç•¶å‰æ“æœ‰çƒæ¬Šçš„çƒéšŠ ID
    is_over: bool = False
  
@dataclass(slots=True)
class MatchResult:
    """
    æ¯”è³½çµæœè¼¸å‡º (Spec 7.1)
    é€™æ˜¯ Phase 2 æ•¸æ“šåˆ†æçš„ä¸»è¦è¼¸å…¥ä¾†æºã€‚
    """
    game_id: str          # å”¯ä¸€è­˜åˆ¥ç¢¼
    home_team_id: str
    away_team_id: str
    home_score: int
    away_score: int
    is_ot: bool           # æ˜¯å¦æœ‰å»¶é•·è³½
    total_quarters: int   # ç¸½ç¯€æ•¸
    pbp_log: List[str]    # æ–‡å­—è½‰æ’­ç´€éŒ„
    
    # [Phase 2 æ–°å¢] ç’°å¢ƒèˆ‡ç¯€å¥æ•¸æ“š
    # é€™äº›æ•¸æ“šå°æ–¼é©—è­‰ "æ¯”è³½å¼•æ“æ˜¯å¦ç¬¦åˆç¾ä»£ç±ƒçƒç¯€å¥" è‡³é—œé‡è¦
    pace: float = 0.0           # ç¯€å¥ (Possessions per 48 min)
    home_possessions: int = 0   # ä¸»éšŠç¸½å›åˆæ•¸
    away_possessions: int = 0   # å®¢éšŠç¸½å›åˆæ•¸
    
    # è©³ç´°çš„å›åˆæ™‚é–“ç´€éŒ„ (List)
    home_possession_history: List[float] = field(default_factory=list)
    away_possession_history: List[float] = field(default_factory=list)
    # å¹³å‡å›åˆæ™‚é–“ (ç§’)
    home_avg_seconds_per_poss: float = 0.0
    away_avg_seconds_per_poss: float = 0.0
    
    # å¿«æ”»çµ±è¨ˆ (ç”¨æ–¼é©—è­‰ Phase 4.4 ç¯€å¥èˆ‡ç’°å¢ƒ)
    home_fb_made: int = 0
    home_fb_attempt: int = 0
    away_fb_made: int = 0
    away_fb_attempt: int = 0
    
    # [New v2.4] é•ä¾‹çµ±è¨ˆ (Team Level)
    home_violation_8s: int = 0
    home_violation_24s: int = 0
    away_violation_8s: int = 0
    away_violation_24s: int = 0
```

---

### ğŸ“„ File: `app\services\__init__.py`

```python
# app/services/__init__.py
```

---

### ğŸ“„ File: `app\services\player_generator.py`

```python
# app/services/player_generator.py
import random
import math
import re
from app import db
# [ä¿®æ­£] Contract æ‡‰è©²å¾ app.models.contract åŒ¯å…¥
from app.models.player import Player
from app.models.contract import Contract
from app.models.system import NameLibrary
from app.utils.game_config_loader import GameConfigLoader

# ==========================================
# ASBL Player Generator Service
# Specification: v3.3 (Name Strategy Configurable)
# Features: 
#   - Multi-language Name Generation (Strategy A/B/C)
#   - Config-driven strategy mapping
#   - Dynamic Validation
# ==========================================

class PlayerGenerator:
    
    # -------------------------------------------------------------------------
    # éœæ…‹å¿«å–å€ (Static Cache)
    # -------------------------------------------------------------------------
    # çµæ§‹: 
    # _names_cache = {
    #    'en': {
    #       'surname': [{'content': 'Smith', 'weight': 10}, ...],
    #       'given_name': [{'content': 'John', 'weight': 20}, ...],
    #       'all': [...] # æ··åˆåˆ—è¡¨ (for Strategy A)
    #    },
    #    'zh': ...
    # }
    _names_cache = {} 
    _config_cache = {}
    _is_initialized = False

    # [Spec v2.6] å±¬æ€§æ˜ å°„è¡¨
    ATTR_MAPPING = {
        # Untrainable (å¤©è³¦)
        "ath_stamina":   ("physical", "stamina"),
        "ath_strength":  ("physical", "strength"),
        "ath_speed":     ("physical", "speed"),
        "ath_jump":      ("physical", "jumping"),
        "talent_health": ("physical", "health"),
        "shot_touch":    ("offense", "touch"),
        "shot_release":  ("offense", "release"),
        "talent_offiq":  ("mental", "off_iq"),
        "talent_defiq":  ("mental", "def_iq"),
        "talent_luck":   ("mental", "luck"),
        # Trainable (æŠ€è¡“)
        "shot_accuracy": ("offense", "accuracy"),
        "shot_range":    ("offense", "range"),
        "off_pass":      ("offense", "passing"),
        "off_dribble":   ("offense", "dribble"),
        "off_handle":    ("offense", "handle"),
        "off_move":      ("offense", "move"),
        "def_rebound":   ("defense", "rebound"),
        "def_boxout":    ("defense", "boxout"),
        "def_contest":   ("defense", "contest"),
        "def_disrupt":   ("defense", "disrupt")
    }

    @classmethod
    def initialize_class(cls):
        """
        [ç³»çµ±åˆå§‹åŒ–]
        åœ¨ä¼ºæœå™¨å•Ÿå‹•æ™‚å‘¼å«ï¼Œå°‡è³‡æ–™èˆ‡è¨­å®šè¼‰å…¥è¨˜æ†¶é«”ã€‚
        åŒ…å«å°‡ YAML å­—ä¸²è¦å‰‡ç·¨è­¯ç‚º Python ç‰©ä»¶çš„é‚è¼¯ã€‚
        """
        if cls._is_initialized:
            return

        #print("[PlayerGenerator] Initializing cache for High Performance Mode...")

        # 1. è¼‰å…¥å§“ååº« (ä¿ç•™ Weight è³‡è¨Š)
        # ä½¿ç”¨ yield_per å„ªåŒ–å¤§é‡æ•¸æ“šè®€å–
        all_names = db.session.query(NameLibrary).yield_per(10000)
        
        cls._names_cache = {}
        
        # [v3.4 Update] ç”¨æ–¼è¨ˆç®—èªç³»æ¬Šé‡çš„è¨ˆæ•¸å™¨
        lang_counts = {}
        
        for row in all_names:
            lang = row.language
            cat = row.category
            
            if lang not in cls._names_cache:
                cls._names_cache[lang] = {'surname': [], 'given_name': [], 'all': []}
                lang_counts[lang] = 0 # åˆå§‹åŒ–è¨ˆæ•¸
            
            item = {'content': row.content, 'weight': row.weight}
            
            # åˆ†é¡å„²å­˜
            if cat in cls._names_cache[lang]:
                cls._names_cache[lang][cat].append(item)
            
            # åŒæ™‚å­˜å…¥ 'all' (ä¾› Strategy A ä½¿ç”¨)
            cls._names_cache[lang]['all'].append(item)
            
            # [v3.4 Update] ç´¯åŠ è©²èªç³»çš„è³‡æ–™ç­†æ•¸
            lang_counts[lang] += 1

        # [v3.4 Update] é å…ˆè¨ˆç®—èªç³»åˆ†ä½ˆæ¬Šé‡ï¼Œé¿å…åœ¨ generate æ™‚é‡è¤‡è¨ˆç®—
        # çµæ§‹: {'langs': ['en', 'zh', ...], 'weights': [1050, 300, ...]}
        cls._config_cache['lang_distribution'] = {
            'langs': list(lang_counts.keys()),
            'weights': list(lang_counts.values())
        }

        # 2. é è¼‰å…¥ Config (åŸºç¤)
        cls._config_cache['grades'] = GameConfigLoader.get('generation.grades')
        cls._config_cache['grade_weights'] = GameConfigLoader.get('generation.grade_weights')
        cls._config_cache['untrainable_keys'] = GameConfigLoader.get('generation.attributes.untrainable')
        cls._config_cache['trainable_keys'] = GameConfigLoader.get('generation.attributes.trainable')
        cls._config_cache['height_modifiers'] = GameConfigLoader.get('generation.height_modifiers')
        cls._config_cache['weighted_bonus_keys'] = GameConfigLoader.get('generation.weighted_bonus_keys')
        
        # 2.1 è¼‰å…¥å§“åç”Ÿæˆç­–ç•¥ (New Spec v3.3)
        cls._config_cache['name_strategies'] = GameConfigLoader.get('name_generation.strategies')
        
        # 3. é è¼‰å…¥èº«é«˜èˆ‡ä½ç½®åƒæ•¸ (æ¶ˆé™¤ Hardcode)
        cls._config_cache['height_dist'] = GameConfigLoader.get('generation.height_distribution')
        
        # 3.1 ä½ç½®çŸ©é™£å„ªåŒ–
        raw_pos_matrix = GameConfigLoader.get('generation.position_matrix')
        cls._config_cache['pos_matrix_optimized'] = []
        for entry in raw_pos_matrix:
            cls._config_cache['pos_matrix_optimized'].append({
                'threshold': entry['max_height'],
                'roles': list(entry['weights'].keys()),
                'weights': list(entry['weights'].values())
            })

        # 3.2 ä½ç½®æª¢æ ¸è¦å‰‡ç·¨è­¯ (Rule Compiler)
        # å°‡ YAML ä¸­çš„ "sum(a, b, c) > ..." å­—ä¸²è§£æç‚º Python list ['a', 'b', 'c']
        raw_validation = GameConfigLoader.get('generation.position_validation')
        cls._config_cache['pos_validation_compiled'] = {}
        
        for pos, rule in raw_validation.items():
            condition_str = rule.get('condition', 'none')
            if condition_str == 'none':
                cls._config_cache['pos_validation_compiled'][pos] = None
            else:
                # ä½¿ç”¨ Regex æå– sum(...) ä¸­çš„å…§å®¹
                # å‡è¨­æ ¼å¼ç¸½æ˜¯ sum(key1, key2...) > ...
                match = re.search(r"sum\((.*?)\)", condition_str)
                if match:
                    keys_str = match.group(1)
                    # è½‰ç‚º list: ['def_rebound', 'def_boxout', 'def_contest']
                    keys = [k.strip() for k in keys_str.split(',')]
                    cls._config_cache['pos_validation_compiled'][pos] = keys
                else:
                    # Fallback: è‹¥è§£æå¤±æ•—ï¼Œè¦–ç‚ºç„¡é™åˆ¶ï¼Œé¿å… Crash
                    print(f"[Warning] Failed to parse validation rule for {pos}: {condition_str}")
                    cls._config_cache['pos_validation_compiled'][pos] = None

        # 4. é è¼‰å…¥å„ç­‰ç´šè¦å‰‡
        cls._config_cache['rules_by_grade'] = {}
        for g in cls._config_cache['grades']:
            cls._config_cache['rules_by_grade'][g] = {
                'untrainable': GameConfigLoader.get(f'generation.untrainable_rules.{g}'),
                'trainable_cap': GameConfigLoader.get(f'generation.trainable_caps.{g}'),
                'salary_factor': GameConfigLoader.get(f'generation.salary_factors.{g}'),
                'contract': GameConfigLoader.get(f'generation.contracts.{g}'),
                'age_offset': GameConfigLoader.get(f'generation.age_rules.offsets.{g}')
            }

        cls._is_initialized = True
        #print(f"[PlayerGenerator] Cache initialized. Validation Rules Compiled.")

    # =========================================================================
    # 1. å§“åç”Ÿæˆ (Name Generation) - v3.3 Update
    # ===================================================================================
    
    @staticmethod
    def _pick_weighted(items, k=1):
        """[Helper] æ ¹æ“š weight å±¬æ€§é€²è¡ŒåŠ æ¬Šéš¨æ©ŸæŠ½å–"""
        if not items: return []
        population = [x['content'] for x in items]
        weights = [x['weight'] for x in items]
        return random.choices(population, weights=weights, k=k)

    @classmethod
    def _get_strategy_for_lang(cls, lang):
        """å¾ Config ä¸­æŸ¥æ‰¾è©²èªç³»å°æ‡‰çš„ç­–ç•¥"""
        strategies = cls._config_cache['name_strategies']
        if lang in strategies.get('western', []):
            return 'A'
        elif lang in strategies.get('east_asian', []):
            return 'B'
        elif lang in strategies.get('indigenous', []):
            return 'C'
        return 'A' # Default fallback

    @classmethod
    def _generate_name_data(cls):
        """
        ç”Ÿæˆå§“åèˆ‡åœ‹ç±
        Return: (full_name, nationality_code)
        """
        if not cls._is_initialized: cls.initialize_class()

        # [v3.4 Update] æ±ºå®šèªç³»é‚è¼¯è®Šæ›´
        # å¾ã€Œèªç³»å‡ç­‰ã€æ”¹ç‚ºã€Œä¾è³‡æ–™åº«ç­†æ•¸æ¬Šé‡ã€éš¨æ©ŸæŠ½å–
        dist = cls._config_cache.get('lang_distribution')
        
        if not dist or not dist['langs']:
            return "Unknown Player", "en"
            
        # ä½¿ç”¨ random.choices é€²è¡ŒåŠ æ¬ŠæŠ½å– (O(1) after initialization)
        selected_lang = random.choices(
            dist['langs'], 
            weights=dist['weights'], 
            k=1
        )[0]
        
        strategy = cls._get_strategy_for_lang(selected_lang)
        lang_data = cls._names_cache[selected_lang]
        full_name = ""

        # 2. ä¾èªç³»åŸ·è¡Œç­–ç•¥
        if strategy == 'A': # æ­ç¾èªç³» (Western)
            # è¦å‰‡: ä¸åˆ† categoryï¼Œä¾ç…§æ¬Šé‡éš¨æ©ŸæŠ½å– 3 å€‹å…§å®¹çµ„åˆï¼Œç”¨é–“éš”è™Ÿåˆ†éš”
            parts = cls._pick_weighted(lang_data['all'], k=3)
            full_name = "ãƒ»".join(parts)

        elif strategy == 'B': # æ±äºèªç³» (East Asian)
            # è¦å‰‡: 
            # 1. æŠ½å§“æ° (category='surname')
            # 2. æŠ½åå­—1 (category='given_name')
            # 3. åˆ¤å®šåå­—2 (70% æ©Ÿç‡å†æŠ½ä¸€å€‹ given_name)
            # çµ„åˆ: å§“ + å1 [+ å2]
            
            surnames = lang_data.get('surname', [])
            given_names = lang_data.get('given_name', [])
            
            # é˜²å‘†ï¼šè‹¥è³‡æ–™ä¸è¶³ï¼Œé€€å›åˆ° 'all' æŠ½å–
            if not surnames: surnames = lang_data['all']
            if not given_names: given_names = lang_data['all']

            sn = cls._pick_weighted(surnames, k=1)[0]
            gn1 = cls._pick_weighted(given_names, k=1)[0]
            
            full_name = sn + gn1
            
            # 70% æ©Ÿç‡é›™å­—å
            if random.random() < 0.7:
                gn2 = cls._pick_weighted(given_names, k=1)[0]
                full_name += gn2

        elif strategy == 'C': # å°ç£åŸä½æ°‘èªç³» (Indigenous)
            # è¦å‰‡: éš¨æ©ŸæŠ½å– 2 å€‹ã€Œä¸é‡è¤‡ã€çš„å…§å®¹ï¼Œç”¨é–“éš”è™Ÿæ‹¼æ¥
            pool = lang_data['all']
            if len(pool) < 2:
                parts = cls._pick_weighted(pool, k=len(pool)) # è³‡æ–™ä¸è¶³å°±å…¨æ‹¿
            else:
                # æŠ½å–ä¸é‡è¤‡é‚è¼¯
                # ç”±æ–¼ random.choices æ˜¯å–å¾Œæ”¾å›ï¼Œé€™è£¡æ‰‹å‹•è™•ç†ä¸é‡è¤‡
                selected = []
                temp_pool = list(pool) # Copy
                
                while len(selected) < 2 and temp_pool:
                    # é‡æ–°è¨ˆç®—æ¬Šé‡ä¸¦æŠ½å–
                    pick_list = cls._pick_weighted(temp_pool, k=1)
                    if not pick_list: break
                    
                    val = pick_list[0]
                    selected.append(val)
                    
                    # å¾æš«å­˜æ± ç§»é™¤å·²é¸ä¸­çš„ (é¿å…é‡è¤‡)
                    # æ³¨æ„ï¼šé€™è£¡å‡è¨­ content æ˜¯å”¯ä¸€çš„ï¼Œæˆ–è€…ç§»é™¤ç¬¬ä¸€å€‹åŒ¹é…é …
                    temp_pool = [x for x in temp_pool if x['content'] != val]
                
                parts = selected
                
            full_name = "ãƒ»".join(parts)
        
        return full_name, selected_lang

    # =========================================================================
    # 2. å¤©è³¦ç”Ÿæˆ (Untrainable Stats)
    # =========================================================================
    @classmethod
    def _generate_untrainable_stats(cls, grade):
        keys = cls._config_cache['untrainable_keys']
        rule = cls._config_cache['rules_by_grade'][grade]['untrainable']
        
        stat_min, stat_max = rule["stat_min"], rule["stat_max"]
        sum_min, sum_max = rule["sum_min"], rule["sum_max"]
        
        while True:
            stats = {k: stat_min for k in keys}
            current_sum = sum(stats.values())
            target_sum = random.randint(sum_min, sum_max)
            remaining = target_sum - current_sum
            
            valid_keys = list(keys)
            while remaining > 0 and valid_keys:
                k = random.choice(valid_keys)
                space = stat_max - stats[k]
                if space <= 0:
                    valid_keys.remove(k)
                    continue
                
                step = random.randint(1, min(remaining, space, 10))
                stats[k] += step
                remaining -= step
            
            if remaining == 0:
                return stats

    # =========================================================================
    # 3. èº«é«˜èˆ‡ä½ç½® (Height & Position) - Fully Configurable
    # =========================================================================
    @classmethod
    def _generate_height(cls):
        conf = cls._config_cache['height_dist']
        mean, std_dev = conf['mean'], conf['std_dev']
        min_h, max_h = conf['min'], conf['max']
        
        while True:
            u1, u2 = random.random(), random.random()
            z = math.sqrt(-2.0 * math.log(max(u1, 1e-12))) * math.cos(2.0 * math.pi * u2)
            height = int(round(mean + z * std_dev))
            if min_h <= height <= max_h:
                return height

    @classmethod
    def _pick_position(cls, h):
        for rule in cls._config_cache['pos_matrix_optimized']:
            if h <= rule['threshold']:
                return random.choices(rule['roles'], weights=rule['weights'], k=1)[0]
        return "C"

    # =========================================================================
    # 4. å¯è¨“ç·´èƒ½åŠ›ç”Ÿæˆ (Trainable Stats)
    # =========================================================================
    
    @classmethod
    def _check_position_validation(cls, stats, pos):
        """
        [Spec 2.4.2] ä½ç½®æª¢æ ¸æ©Ÿåˆ¶ (Dynamic)
        ä¸å†ä½¿ç”¨ Hardcodeï¼Œè€Œæ˜¯è®€å–åˆå§‹åŒ–æ™‚ç·¨è­¯å¥½çš„ Key List
        """
        # 1. å–å¾—è©²ä½ç½®çš„é—œéµå±¬æ€§åˆ—è¡¨ (List of keys)
        core_keys = cls._config_cache['pos_validation_compiled'].get(pos)
        
        # è‹¥ç„¡è¦å‰‡ (å¦‚ SF)ï¼Œç›´æ¥é€šé
        if not core_keys:
            return True
            
        # 2. è¨ˆç®—æ ¸å¿ƒç¸½å’Œ
        # ä½¿ç”¨ Generator Expression é€²è¡ŒåŠ ç¸½ï¼Œæ•ˆèƒ½æ¥µä½³
        core_sum = sum(stats[k] for k in core_keys)
        
        # 3. è¨ˆç®—ç¸½å’Œ
        total_sum = sum(stats.values())
        
        # 4. åˆ¤å®š: æ ¸å¿ƒ > (ç¸½å’Œ - æ ¸å¿ƒ) => æ ¸å¿ƒ > å…¶ä»–
        return core_sum > (total_sum - core_sum)

    @staticmethod
    def _safe_distribute(stats, target_keys, points_to_add):
        """[Helper] å®‰å…¨åˆ†é…é»æ•¸ï¼ŒåŒ…å«é˜²çˆ†æ©Ÿåˆ¶ (Max 99)"""
        if points_to_add <= 0: return
        valid_keys = list(target_keys)
        while points_to_add > 0 and valid_keys:
            k = random.choice(valid_keys)
            capacity = 99 - stats[k]
            if capacity <= 0:
                valid_keys.remove(k)
                continue
            stats[k] += 1
            points_to_add -= 1

    @classmethod
    def _distribute_bonus_points(cls, stats, bonus, bonus_type, bonus_config=None):
        """[Spec 2.4.3] åŸ·è¡ŒåŠ é»é‚è¼¯ (Revised)"""
        if bonus <= 0: return stats
        
        all_keys = list(stats.keys())
        
        if bonus_type == 'flat':
            per_stat = bonus // len(all_keys)
            for k in all_keys:
                stats[k] = min(99, stats[k] + per_stat)
                
        elif bonus_type == 'weighted':
            ratio_min = bonus_config.get('key_ratio_min', 0.5) if bonus_config else 0.5
            ratio_max = bonus_config.get('key_ratio_max', 1.0) if bonus_config else 1.0
            
            ratio = random.uniform(ratio_min, ratio_max)
            key_pool = int(bonus * ratio)
            general_pool = bonus - key_pool
            
            high_p_keys = cls._config_cache['weighted_bonus_keys']['high_priority']
            
            cls._safe_distribute(stats, high_p_keys, key_pool)
            cls._safe_distribute(stats, all_keys, general_pool)
                    
        return stats

    @classmethod
    def _generate_trainable_stats(cls, grade, height, position):
        keys = cls._config_cache['trainable_keys']
        cap = cls._config_cache['rules_by_grade'][grade]['trainable_cap']
        
        # 1. å–å¾—èº«é«˜ä¿®æ­£è¦å‰‡
        mod_rules = cls._config_cache['height_modifiers']
        # å€é–“åˆ¤æ–·é‚è¼¯ (å¯ä»¥é€²ä¸€æ­¥å„ªåŒ–ç‚º Config é©…å‹•ï¼Œä½†æ­¤è™•ç‚ºæ•ˆèƒ½ç†±é»ï¼Œä¸”å€é–“è®Šå‹•æ©Ÿç‡ä½)
        if 160 <= height <= 169: rule = mod_rules['160-169']
        elif 170 <= height <= 179: rule = mod_rules['170-179']
        elif 180 <= height <= 189: rule = mod_rules['180-189']
        elif 190 <= height <= 209: rule = mod_rules['190-209']
        elif 210 <= height <= 219: rule = mod_rules['210-219']
        elif 220 <= height <= 230: rule = mod_rules['220-230']
        else: rule = mod_rules['190-209']

        trials = rule.get('trials', 1)
        selection = rule.get('selection', 'none')
        bonus = rule.get('bonus_points', 0)
        bonus_type = rule.get('bonus_type', 'none')

        candidates = []

        # 2. åŸ·è¡Œ Trials (åˆ†éšæ®µé‡éª°)
        for _ in range(trials):
            while True:
                temp_stats = {k: random.randint(1, 99) for k in keys}
                if sum(temp_stats.values()) > cap:
                    continue
                # [Dynamic Check]
                if not cls._check_position_validation(temp_stats, position):
                    continue
                candidates.append(temp_stats)
                break
        
        # 3. é¸æ“‡æœ€ä½³/æœ€å·®
        final_stats = candidates[0]
        if selection == 'max':
            final_stats = max(candidates, key=lambda x: sum(x.values()))
        elif selection == 'min':
            final_stats = min(candidates, key=lambda x: sum(x.values()))
            
        # 4. æ‡‰ç”¨èº«é«˜çå‹µ
        final_stats = cls._distribute_bonus_points(final_stats, bonus, bonus_type, rule)
        
        return final_stats

    # =========================================================================
    # ä¸»æµç¨‹ (Main Workflow)
    # =========================================================================
    @classmethod
    def generate_payload(cls, specific_grade=None):
        if not cls._is_initialized: cls.initialize_class()

        # 1. Name & Nationality (Updated)
        name, nationality = cls._generate_name_data()

        # 2. Grade
        if specific_grade:
            grade = specific_grade
        else:
            grade = random.choices(
                cls._config_cache['grades'], 
                weights=cls._config_cache['grade_weights'], 
                k=1
            )[0]

        # 3. Untrainable
        untrainable = cls._generate_untrainable_stats(grade)

        # 4. Height & Position
        height = cls._generate_height()
        position = cls._pick_position(height)

        # 5. Trainable
        trainable = cls._generate_trainable_stats(grade, height, position)

        # 6. Age
        age_base = 18
        age_offset = cls._config_cache['rules_by_grade'][grade]['age_offset']
        age = age_base + random.randint(0, age_offset)

        # 7. Derived Data
        raw_stats = {**untrainable, **trainable}
        total_sum = sum(raw_stats.values())
        
        salary_factor = cls._config_cache['rules_by_grade'][grade]['salary_factor']
        salary = int(round(total_sum * salary_factor))
        
        contract_rule = cls._config_cache['rules_by_grade'][grade]['contract']

        # 8. Assembly
        detailed_stats = {"physical": {}, "offense": {}, "defense": {}, "mental": {}}
        for cfg_key, (cat, db_key) in cls.ATTR_MAPPING.items():
            if cfg_key in raw_stats:
                detailed_stats[cat][db_key] = raw_stats[cfg_key]

        return {
            "name": name,
            "nationality": nationality, # æ–°å¢åœ‹ç±
            "grade": grade,
            "age": age,
            "height": height,
            "position": position,
            "rating": total_sum,
            "salary": salary,
            "contract_rule": contract_rule,
            "detailed_stats": detailed_stats,
            "raw_stats": raw_stats
        }

    # ====================================================
    # å·¥å…·æ–¹æ³•
    # ====================================================
    @staticmethod
    def to_flat_dict(payload):
        flat = {
            "name": payload['name'],
            "nationality": payload['nationality'], # [Update] åŠ å…¥èªç³»æ¬„ä½
            "grade": payload['grade'],
            "age": payload['age'],
            "height": payload['height'],
            "position": payload['position'],
            "rating": payload['rating'],
            "salary": payload['salary'],
            "contract_years": payload['contract_rule']['years'],
            "contract_role": payload['contract_rule']['role']
        }
        for cat, stats in payload['detailed_stats'].items():
            for k, v in stats.items():
                flat[f"{cat}_{k}"] = v
        return flat

    @classmethod
    def save_to_db(cls, payload, user_id=None, team_id=None):
        player = Player(
            name=payload['name'],
            nationality=payload['nationality'], # [Update] å„²å­˜åœ‹ç±
            age=payload['age'],
            height=payload['height'],
            position=payload['position'],
            grade=payload['grade'], 
            rating=payload['rating'],
            detailed_stats=payload['detailed_stats'],
            user_id=user_id,
            team_id=team_id,
            training_points=0
        )
        db.session.add(player)
        db.session.flush()

        contract_data = None
        if team_id:
            rule = payload['contract_rule']
            contract = Contract(
                player_id=player.id,
                team_id=team_id,
                salary=payload['salary'],
                years=rule['years'],
                years_left=rule['years'],
                role=rule['role']
            )
            db.session.add(contract)
            contract_data = rule

        return player, contract_data
```

---

### ğŸ“„ File: `app\services\team_creator.py`

```python
# app/services/team_creator.py

from collections import Counter
from typing import List, Dict, Any
from app.services.player_generator import PlayerGenerator
from app.utils.game_config_loader import GameConfigLoader

class TeamCreator:
    """
    ASBL é–‹éšŠé™£å®¹ç”Ÿæˆæœå‹™ (Pure Logic Version)
    åªè² è²¬ç”Ÿæˆç¬¦åˆè¦å‰‡çš„çƒå“¡è³‡æ–™çµæ§‹ï¼Œä¸æ¶‰åŠè³‡æ–™åº«å¯«å…¥ã€‚
    å°æ‡‰è¦æ ¼æ›¸: Player System Specification v3.5 (Updated)
    """

    @classmethod
    def create_valid_roster(cls, max_attempts: int = 1000000) -> List[Dict[str, Any]]:
        """
        [Spec 5] ç”Ÿæˆç¬¦åˆæª¢æ ¸æ¢ä»¶çš„ 15 äººåå–®
        é‚è¼¯: 
          1. ä¾æ“šç­‰ç´šåˆ†ä½ˆç”Ÿæˆçƒå“¡
          2. [Spec 5.4] é‡å°æ¯ä¸€ä½ç”Ÿæˆçš„çƒå“¡é€²è¡Œã€Œä¸‹é™æª¢æ ¸ã€ï¼Œä¸åˆæ ¼å‰‡å–®å…µé‡éª°
          3. [Spec 5.2] é‡å°æ•´éšŠé€²è¡Œã€Œä½ç½®æª¢æ ¸ã€èˆ‡ã€Œåˆ†å±¤è¦†è“‹æª¢æ ¸ã€ï¼Œä¸åˆæ ¼å‰‡æ•´éšŠé‡éª°
        Returns:
            List[Dict]: åŒ…å« 15 å€‹çƒå“¡ Payload çš„åˆ—è¡¨
        """
        # 1. å¾åƒæ•¸æª”è®€å–è¨­å®š
        comp_rules = GameConfigLoader.get('team_creation.composition_count')
        val_rules = GameConfigLoader.get('team_creation.validation')
        
        # [Spec 5.4] è®€å–é–‹éšŠç‰¹æ®Šè¦å‰‡åƒæ•¸
        min_ratio = GameConfigLoader.get('team_creation.initial_team_min_ratio', 0.5)
        trainable_caps = GameConfigLoader.get('generation.trainable_caps')
        trainable_attrs = GameConfigLoader.get('generation.attributes.trainable')

        attempts = 0
        while attempts < max_attempts:
            attempts += 1
            roster = []

            # 2. ä¾æ“šç­‰ç´šåˆ†ä½ˆç”Ÿæˆçƒå“¡
            # æ³¨æ„: Python 3.7+ å­—å…¸ä¿æŒæ’å…¥é †åº
            for grade, count in comp_rules.items():
                # å–å¾—è©²ç­‰ç´šçš„èƒ½åŠ›ä¸Šé™ï¼Œç”¨æ–¼è¨ˆç®—ä¸‹é™é–€æª»
                grade_cap = trainable_caps.get(grade, 9999)
                lower_bound = grade_cap * min_ratio

                for _ in range(count):
                    # å–®å…µç”Ÿæˆè¿´åœˆ (é‡å°ä¸‹é™æª¢æ ¸)
                    player_payload = cls._generate_qualified_player(
                        grade, 
                        lower_bound, 
                        trainable_attrs
                    )
                    roster.append(player_payload)

            # 3. åŸ·è¡Œæ•´éšŠé™£å®¹æª¢æ ¸ (ä½ç½®æ•¸é‡ + åˆ†å±¤è¦†è“‹)
            if cls._validate_roster_positions(roster, val_rules):
                return roster
        
        raise Exception(f"Failed to generate a valid team after {max_attempts} attempts. Please check config constraints.")

    @classmethod
    def _generate_qualified_player(cls, grade: str, lower_bound: float, trainable_attrs: List[str], max_single_attempts: int = 50000) -> Dict[str, Any]:
        """
        [Spec 5.4] ç”Ÿæˆä¸¦æª¢æ ¸å–®ä¸€çƒå“¡æ˜¯å¦ç¬¦åˆé–‹éšŠä¸‹é™
        è‹¥ç”Ÿæˆçš„çƒå“¡èƒ½åŠ›ç¸½å’Œä½æ–¼ lower_boundï¼Œå‰‡è¦–ç‚ºç„¡æ•ˆ(å¤ªå¼±)ï¼Œé‡æ–°ç”Ÿæˆã€‚
        """
        for _ in range(max_single_attempts):
            # å‘¼å«ç´”ç²¹çš„ç”Ÿæˆå™¨
            payload = PlayerGenerator.generate_payload(specific_grade=grade)
            
            # è§£æå±¬æ€§ä¾†æº
            # PlayerGenerator å¯èƒ½å°‡æ•¸å€¼æ”¾åœ¨ 'raw_stats' (æ‰å¹³) æˆ– 'attributes' (å·¢ç‹€)
            stats_source = {}
            
            if 'raw_stats' in payload:
                # å„ªå…ˆä½¿ç”¨ raw_statsï¼Œå› ç‚ºé€™æ˜¯æœ€å®Œæ•´çš„æ‰å¹³åŒ–æ•¸æ“š
                stats_source = payload['raw_stats']
            else:
                # Fallback: å˜—è©¦è§£æ attributes çµæ§‹
                attrs = payload.get('attributes', {})
                if 'trainable' in attrs:
                    # è‹¥çµæ§‹ç‚º {'attributes': {'trainable': {...}}}
                    stats_source = attrs['trainable']
                else:
                    # è‹¥çµæ§‹ç‚º {'attributes': {...æ‰å¹³...}}
                    stats_source = attrs

            # è¨ˆç®—å¯è¨“ç·´èƒ½åŠ›ç¸½å’Œ
            total_score = sum(stats_source.get(attr, 0) for attr in trainable_attrs)

            # æª¢æ ¸ä¸‹é™
            if total_score >= lower_bound:
                return payload
        
        # è‹¥é€£çºŒå¤šæ¬¡éƒ½å¤±æ•—ï¼Œé€šå¸¸ä»£è¡¨æ•¸æ“šè®€å–éŒ¯èª¤ (total_score=0) æˆ–ä¸‹é™è¨­å®šä¸åˆç†
        raise Exception(f"Failed to generate a qualified player for grade {grade} (Target > {lower_bound}). Last Score: {total_score}")

    @staticmethod
    def _validate_roster_positions(roster: List[Dict[str, Any]], rules: Dict[str, Any]) -> bool:
        """
        [Spec 5.2] æª¢æ ¸æ•´éšŠä½ç½®åˆ†ä½ˆ
        åŒ…å«åŸºç¤æ•¸é‡æª¢æ ¸èˆ‡åˆ†å±¤ä½ç½®è¦†è“‹æª¢æ ¸ (High Tier / Mid Tier)
        """
        # çµ±è¨ˆä½ç½®æ•¸é‡
        positions = [p['position'] for p in roster]
        counts = Counter(positions)
        
        # 1. C (ä¸­é‹’) æ•¸é‡è‡³å°‘ min_c
        if counts['C'] < rules.get('min_c', 2):
            return False
        
        # 2. PG (æ§çƒå¾Œè¡›) æ•¸é‡è‡³å°‘ min_pg
        if counts['PG'] < rules.get('min_pg', 2):
            return False
        
        # 3. å¾Œè¡›çµ„ (PG + SG) ç¸½æ•¸è‡³å°‘ min_guards
        guard_count = counts['PG'] + counts['SG']
        if guard_count < rules.get('min_guards', 4):
            return False
        
        # 4. å‰é‹’çµ„ (PF + SF) ç¸½æ•¸è‡³å°‘ min_forwards
        forward_count = counts['PF'] + counts['SF']
        if forward_count < rules.get('min_forwards', 4):
            return False
        
        # 5. [Updated v3.5] åˆ†å±¤ä½ç½®è¦†è“‹æª¢æ ¸ (Tiered Coverage)
        # æ”¯æ´å¤šçµ„è¦†è“‹è¦å‰‡ (ä¾‹å¦‚: é«˜éšçµ„è¦†è“‹5ä½ç½®, ä¸­éšçµ„è¦†è“‹5ä½ç½®)
        coverage_rules = rules.get('coverage_rules', [])
        
        # å…¼å®¹èˆŠç‰ˆè¨­å®š (è‹¥ config åªæœ‰ high_tier_coverage å­—å…¸)
        if not coverage_rules and 'high_tier_coverage' in rules:
            old_rule = rules['high_tier_coverage']
            if old_rule.get('enabled', False):
                coverage_rules = [{
                    'target_grades': old_rule.get('target_grades', []),
                    'required_positions': old_rule.get('required_positions', [])
                }]

        # åŸ·è¡Œæ‰€æœ‰è¦†è“‹è¦å‰‡æª¢æŸ¥
        for rule in coverage_rules:
            target_grades = set(rule.get('target_grades', []))
            required_positions = set(rule.get('required_positions', []))
            
            if not target_grades or not required_positions:
                continue

            # ç¯©é¸å‡ºç¬¦åˆè©²è¦å‰‡ç­‰ç´šçš„çƒå“¡
            tier_positions = {
                p['position'] for p in roster 
                if p.get('grade') in target_grades
            }
            
            # æª¢æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰å¿…è¦ä½ç½® (issubset: required æ˜¯å¦è¢« tier_positions åŒ…å«)
            if not required_positions.issubset(tier_positions):
                return False
            
        return True
```

---

### ğŸ“„ File: `app\utils\game_config_loader.py`

```python
# app/utils/game_config_loader.py
import yaml
import os
from dotenv import load_dotenv

# è¼‰å…¥ .env æª”æ¡ˆä¸­çš„ç’°å¢ƒè®Šæ•¸
load_dotenv()

class GameConfigLoader:
    """
    è² è²¬è®€å– config/game_config.yaml çš„å–®ä¾‹é¡åˆ¥ã€‚
    å„ªå…ˆé †åº:
    1. ç’°å¢ƒè®Šæ•¸ 'GAME_CONFIG_PATH'
    2. å°ˆæ¡ˆæ ¹ç›®éŒ„ä¸‹çš„ config/game_config.yaml (è‡ªå‹•æ¨å°)
    """
    _config = None

    @classmethod
    def load(cls):
        """
        è¼‰å…¥è¨­å®šæª” (Singleton æ¨¡å¼)
        """
        if cls._config is None:
            config_path = None
            
            # 1. å„ªå…ˆå˜—è©¦å¾ç’°å¢ƒè®Šæ•¸è®€å–è·¯å¾‘
            env_path = os.getenv('GAME_CONFIG_PATH')
            if env_path:
                # æ”¯æ´ç›¸å°è·¯å¾‘èˆ‡çµ•å°è·¯å¾‘
                if os.path.isabs(env_path):
                    potential_path = env_path
                else:
                    potential_path = os.path.abspath(env_path)
                
                if os.path.exists(potential_path):
                    config_path = potential_path
                else:
                    print(f"[Warning] .env è¨­å®šçš„ GAME_CONFIG_PATH ({env_path}) æ‰¾ä¸åˆ°æª”æ¡ˆï¼Œå°‡å˜—è©¦è‡ªå‹•æœå°‹ã€‚")

            # 2. è‹¥ç’°å¢ƒè®Šæ•¸æœªè¨­å®šæˆ–æ‰¾ä¸åˆ°ï¼Œä½¿ç”¨é è¨­ç›¸å°è·¯å¾‘æœå°‹
            if not config_path:
                # å®šä½åˆ° app/utils/game_config_loader.py
                current_dir = os.path.dirname(os.path.abspath(__file__))
                # å¾€ä¸Šå…©å±¤: app/utils -> app -> root
                project_root = os.path.dirname(os.path.dirname(current_dir))
                
                # é è¨­è·¯å¾‘: root/config/game_config.yaml
                default_path = os.path.join(project_root, 'config', 'game_config.yaml')
                
                if os.path.exists(default_path):
                    config_path = default_path
                else:
                    # æœ€å¾Œå˜—è©¦: ç•¶å‰å·¥ä½œç›®éŒ„ (CWD) ä¸‹çš„ config
                    cwd_path = os.path.join(os.getcwd(), 'config', 'game_config.yaml')
                    if os.path.exists(cwd_path):
                        config_path = cwd_path

            # 3. æœ€çµ‚æª¢æŸ¥
            if not config_path or not os.path.exists(config_path):
                raise FileNotFoundError(
                    "Game config file not found. \n"
                    "Please set 'GAME_CONFIG_PATH' in .env or ensure 'config/game_config.yaml' exists in project root."
                )

            # 4. è®€å– YAML
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    cls._config = yaml.safe_load(f)
            except yaml.YAMLError as e:
                raise ValueError(f"Error parsing YAML config at {config_path}: {e}")

        return cls._config

    @classmethod
    def get(cls, key_path=None, default=None):
        """
        å–å¾—è¨­å®šå€¼ï¼Œæ”¯æ´é»è™Ÿè·¯å¾‘å­˜å–ã€‚
        Example: GameConfigLoader.get('match_engine.backcourt.params.time_coeff', 0.01)
        """
        try:
            cfg = cls.load()
        except Exception as e:
            print(f"[Error] Failed to load config: {e}")
            return default

        if not key_path:
            return cfg
        
        keys = key_path.split('.')
        val = cfg
        
        for k in keys:
            if isinstance(val, dict):
                val = val.get(k)
                if val is None:
                    return default
            else:
                return default
            
        return val

    @classmethod
    def reload(cls):
        """å¼·åˆ¶é‡æ–°è®€å– (ç”¨æ–¼ç†±æ›´æˆ–æ¸¬è©¦)"""
        cls._config = None
        return cls.load()
```

---

### ğŸ“„ File: `app\__init__.py`

```python
# app/__init__.py
import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from config import Config

# åˆå§‹åŒ– SQLAlchemy
db = SQLAlchemy()
# åˆå§‹åŒ– Migrate
migrate = Migrate()

def create_app(config_class=Config):
    """
    å»ºç«‹ Flask æ‡‰ç”¨ç¨‹å¼å¯¦ä¾‹ (Factory Pattern)
    """
    app = Flask(__name__)
    app.config.from_object(config_class)

    # åˆå§‹åŒ–æ“´å……å¥—ä»¶
    db.init_app(app)
    migrate.init_app(app, db)

    # è¨»å†Š Blueprints (è·¯ç”±)
    # 1. ä¸»è·¯ç”± (é€šç”¨å…¥å£)
    from app.routes import main
    app.register_blueprint(main)
    
    # 2. åŠŸèƒ½æ¨¡çµ„è·¯ç”±
    from app.routes.auth import auth_bp
    from app.routes.team import team_bp
    from app.routes.game import game_bp
    
    app.register_blueprint(auth_bp)
    app.register_blueprint(team_bp)
    app.register_blueprint(game_bp)

    # å°å…¥ Models ä»¥ä¾¿ SQLAlchemy (å’Œ Migrate) èƒ½è¿½è¹¤åˆ°
    from app import models

    return app
```

---

### ğŸ“„ File: `config\game_config.yaml`

```yaml
# config/game_config.yaml
# =============================================================================
# ASBL éŠæˆ²æ ¸å¿ƒè¨­å®šæª” (Final Version - Commented)
# å°æ‡‰è¦æ ¼æ›¸: 
#   - Player System Specification v3.4 (2026/01/25 Update)
#   - Match Engine Specification v2.4 (2026/01/23 Update)
# è·¯å¾‘ config/game_config.yaml
# =============================================================================

# [Spec v3.3] å§“åç”Ÿæˆç­–ç•¥è¨­å®š
# å°‡èªç³»åˆ†é¡ç§»è‡³è¨­å®šæª”ï¼Œæ–¹ä¾¿æ“´å……
name_generation:
  strategies:
    # ç­–ç•¥ A: æ­ç¾èªç³» (Western) - éš¨æ©ŸæŠ½3å€‹å­—çµ„åˆï¼Œç”¨é–“éš”è™Ÿåˆ†éš”
    western: ['en', 'es', 'pt', 'ru', 'de', 'fr', 'it']
    
    # ç­–ç•¥ B: æ±äºèªç³» (East Asian) - å§“+å(1-2å­—)ï¼Œç„¡åˆ†éš”ç¬¦
    east_asian: ['zh', 'ja', 'ko']
    
    # ç­–ç•¥ C: åŸä½æ°‘èªç³» (Indigenous) - éš¨æ©ŸæŠ½2å€‹ä¸é‡è¤‡å­—çµ„åˆï¼Œç”¨é–“éš”è™Ÿåˆ†éš”
    indigenous: ['tw_aboriginal']

system: # ç³»çµ±è¨­å®š
  season_days: 91 # è³½å­£å¤©æ•¸
  games_per_season: 70 # è³½å­£æ¯”è³½æ•¸
  
  # æ´»èºç©å®¶åˆ¤å®šå¤©æ•¸ (ä¾‹å¦‚: 7å¤©å…§æœ‰ç™»å…¥è¦–ç‚ºæ´»èº)
  active_user_threshold_days: 7
  
  # åˆå§‹çƒéšŠè¨­å®š
  initial_team_settings:
    funds: 300000           # åˆå§‹è³‡é‡‘ 30è¬
    reputation: 0           # åˆå§‹è²æœ› 0
    scout_chances: 100      # åˆå§‹çƒæ¢æ¬¡æ•¸ 100
    roster_limit: 40        # çƒå“¡äººæ•¸ä¸Šé™

  # å­£å¾Œè³½è¨­å®š (Playoff Configuration)
  playoff:
    series_length:
      round_1: 3  # 16å¼·è³½ (æ‰“æ»¿3å ´)
      round_2: 3  # 8å¼·è³½ (æ‰“æ»¿3å ´)
      round_3: 3  # 4å¼·è³½ (æ‰“æ»¿3å ´)
      finals: 5   # ç¸½å† è»è³½ (æ‰“æ»¿5å ´)
    
    # ç”¨æ–¼ç¨‹å¼é‚è¼¯åˆ¤æ–·æ˜¯å¦è¦å¼·åˆ¶æ‰“æ»¿ (True=æ‰“æ»¿, False=æ¶å‹åˆ¶)
    force_full_series: False 

# =============================================================================
# 1. çƒå“¡ç”Ÿæˆè¨­å®š (Player Generation)
# å°æ‡‰è¦æ ¼æ›¸: Player System v3.2
# =============================================================================
generation:
  # [Spec v3.1 Section 2.2.1] ç­‰ç´šèˆ‡æ©Ÿç‡
  grades: ["SSR", "SS", "S", "A", "B", "C", "G"]
  grade_weights: [0.005, 0.025, 0.07, 0.14, 0.22, 0.26, 0.28]
  
  # [Spec v3.1 Section 4.1.1] è–ªè³‡ä¿‚æ•¸
  # è¨ˆç®—å…¬å¼: çƒå“¡è–ªè³‡ = (20é …å±¬æ€§ç¸½å’Œ) * è©²ç­‰ç´šä¿‚æ•¸
  # ç”¨é€”: æ±ºå®šçƒå“¡èº«åƒ¹ï¼Œç­‰ç´šè¶Šé«˜ï¼Œæ¯ä¸€é»èƒ½åŠ›å€¼æ›ç®—çš„è–ªæ°´è¶Šé«˜
  salary_factors:
    SSR: 3.0
    SS: 2.5
    S: 2.0
    A: 1.6
    B: 1.3
    C: 1.1
    G: 1.0

  # [Spec v3.1 Section 2.5] å¹´é½¡ç”Ÿæˆè¦å‰‡
  # ç”¨é€”: æ±ºå®šæ–°ç§€çš„åˆå§‹å¹´é½¡ï¼ŒSSR æœ€å¹´è¼•(æ½›åŠ›æœ€å¤§)ï¼ŒG ç´šå¹³å‡å¹´é½¡è¼ƒå¤§
  age_rules:
    base: 18
    offsets: {SSR: 0, SS: 1, S: 2, A: 3, B: 4, C: 5, G: 6}

  # [Spec v3.1 Section 4.1.2] åˆå§‹åˆç´„è¦å‰‡
  # ç”¨é€”: ç”Ÿæˆçƒå“¡æ™‚è‡ªå‹•è³¦äºˆçš„åˆç´„é•·åº¦èˆ‡è§’è‰²å®šä½
  contracts:
    SSR: {years: 4, role: "Star"}
    SS:  {years: 4, role: "Star"}
    S:   {years: 4, role: "Starter"}
    A:   {years: 2, role: "Rotation"}
    B:   {years: 2, role: "Rotation"}
    C:   {years: 1, role: "Role"}
    G:   {years: 1, role: "Bench"}

  # [Spec v3.1 Section 2.2.2 & 2.4] å±¬æ€§å®šç¾©
  attributes:
    untrainable: ["ath_stamina", "ath_strength", "ath_speed", "ath_jump", "shot_touch", "shot_release", "talent_offiq", "talent_defiq", "talent_health", "talent_luck"]
    trainable: ["shot_accuracy", "shot_range", "def_rebound", "def_boxout", "def_contest", "def_disrupt", "off_move", "off_dribble", "off_pass", "off_handle"]

  # [Spec v3.1 Section 2.2.2] å¤©è³¦ç”Ÿæˆè¦å‰‡ (Untrainable)
  untrainable_rules:
    G:   {sum_min: 10,  sum_max: 400, stat_min: 1, stat_max: 99}
    C:   {sum_min: 399, sum_max: 600, stat_min: 1, stat_max: 99}
    B:   {sum_min: 599, sum_max: 700, stat_min: 1, stat_max: 99}
    A:   {sum_min: 699, sum_max: 800, stat_min: 10, stat_max: 99}
    S:   {sum_min: 799, sum_max: 900, stat_min: 20, stat_max: 99}
    SS:  {sum_min: 900, sum_max: 950, stat_min: 30, stat_max: 99}
    SSR: {sum_min: 951, sum_max: 990, stat_min: 91, stat_max: 99}

  # [Spec v3.1 Section 2.4.1] æŠ€è¡“åå‘ç¸½ä¸Šé™ (Trainable Caps)
  # ç”¨é€”: é™åˆ¶å¯è¨“ç·´å±¬æ€§çš„åˆå§‹ç¸½å’Œï¼Œç­‰ç´šè¶Šä½ä¸Šé™è¶Šé«˜(å³æˆ°åŠ›)ï¼Œç­‰ç´šè¶Šé«˜ä¸Šé™è¶Šä½(éœ€åŸ¹é¤Š)
  trainable_caps:
    G: 800
    C: 700
    B: 650
    A: 600
    S: 550
    SS: 550
    SSR: 550

  # [Spec v3.1 Section 2.3.1] èº«é«˜ç”Ÿæˆåƒæ•¸ (New)
  # ç”¨é€”: å®šç¾© Box-Muller æ¼”ç®—æ³•çš„åƒæ•¸ï¼Œé¿å…å¯«æ­»åœ¨ç¨‹å¼ç¢¼ä¸­
  height_distribution:
    mean: 195
    std_dev: 10
    min: 160
    max: 230

  # [Spec v3.1 Section 2.3.2] ä½ç½®åˆ¤å®šçŸ©é™£ (New)
  # ç”¨é€”: å®šç¾©ä¸åŒèº«é«˜å€é–“çš„ä½ç½®æ©Ÿç‡åˆ†ä½ˆ
  # é‚è¼¯: ç¨‹å¼æœƒä¾åºæª¢æŸ¥ max_heightï¼Œç¬¦åˆå‰‡ä½¿ç”¨è©²çµ„æ¬Šé‡
  position_matrix:
    - max_height: 189
      weights: {PG: 60, SG: 40}
    - max_height: 199
      weights: {PG: 35, SG: 45, SF: 20}
    - max_height: 209
      weights: {PF: 50, SF: 20, C: 15, SG: 10, PG: 5}
    - max_height: 999 # 210+ (Catch-all)
      weights: {C: 45, PF: 30, SF: 10, SG: 10, PG: 5}

  # [Spec v3.1 Section 2.4.2] ä½ç½®æª¢æ ¸æ©Ÿåˆ¶ (Position Validation) [v3.1 new]
  # ç”¨é€”: ç¢ºä¿ç”Ÿæˆçš„èƒ½åŠ›å€¼åˆ†ä½ˆç¬¦åˆè©²ä½ç½®çš„ç‰¹å¾µï¼Œå¦å‰‡é‡éª°
  position_validation:
    C:
      condition: "sum(def_rebound, def_boxout, def_contest) > sum(others)"
      others_count: 7
    PF:
      condition: "sum(def_rebound, def_boxout, def_contest) > sum(others)"
      others_count: 7
    SG:
      condition: "sum(def_contest, def_disrupt, shot_range) > sum(others)"
      others_count: 7
    PG:
      condition: "sum(def_disrupt, off_dribble, off_handle, off_pass) > sum(others)"
      others_count: 6
    SF:
      condition: "none" # ç„¡é™åˆ¶

  # [Spec v3.1 Section 2.4.3] èº«é«˜ä¿®æ­£æ©Ÿåˆ¶ (Height Modifiers) [v3.1 new]
  # ç”¨é€”: æ ¹æ“šèº«é«˜å€é–“èª¿æ•´ç”Ÿæˆæ¬¡æ•¸èˆ‡æ•¸å€¼åŠ æˆ
  height_modifiers:
    "160-169":
      trials: 3
      selection: "max" # å–æœ€é«˜ç¸½åˆ†
      bonus_points: 30
      bonus_type: "weighted" # æ¬Šé‡åˆ†é… (PG é—œéµå±¬æ€§æ¬Šé‡è¼ƒé«˜)
      key_ratio_min: 0.5
      key_ratio_max: 1.0
    "170-179":
      trials: 2
      selection: "max"
      bonus_points: 20
      bonus_type: "weighted" # æ¬Šé‡åˆ†é… (PG é—œéµå±¬æ€§æ¬Šé‡è¼ƒé«˜)
      key_ratio_min: 0.5
      key_ratio_max: 1.0
    "180-189":
      trials: 1
      selection: "none"
      bonus_points: 10 # å…¨èƒ½åŠ›+1 = ç¸½å’Œ+10
      bonus_type: "flat" # å¹³å‡åˆ†é… (+1 per stat)
    "190-209":
      trials: 1
      selection: "none"
      bonus_points: 0
      bonus_type: "none"
    "210-219":
      trials: 2
      selection: "min" # å–æœ€ä½ç¸½åˆ†
      bonus_points: 0
      bonus_type: "none"
    "220-230":
      trials: 3
      selection: "min"
      bonus_points: 0
      bonus_type: "none"

  # [Spec v3.1 Section 2.4.3] æ¬Šé‡åˆ†é…è¦å‰‡ (Weighted Distribution Keys) [v3.1 new]
  # ç”¨é€”: å®šç¾©èº«é«˜è£œå„Ÿé»æ•¸åˆ†é…æ™‚ï¼Œå“ªäº›å±¬æ€§æ¬Šé‡è¼ƒé«˜ (é‡å° PG é—œéµå››é …)
  weighted_bonus_keys:
    high_priority: ["def_disrupt", "off_dribble", "off_handle", "off_pass"]
    low_priority: ["shot_accuracy", "shot_range", "def_rebound", "def_boxout", "def_contest", "off_move"]

# =============================================================================
# 2. åœ˜éšŠèˆ‡æ™‚é–“è¨­å®š (Team & Minutes)
# å°æ‡‰è¦æ ¼æ›¸: Player System v3.1 Section 5 & 6
# =============================================================================
team_creation:
  # [Spec v3.1 Section 5] é–‹éšŠé™£å®¹æª¢æ ¸æ¨™æº–
  composition_count: {SSR: 1, SS: 1, S: 1, A: 2, B: 3, C: 2, G: 5} # ç¸½å…± 15 äºº
  validation:
    min_c: 2       # æœ€å°‘ä¸­é‹’æ•¸
    min_pg: 2      # æœ€å°‘æ§è¡›æ•¸
    min_guards: 4  # PG+SG ç¸½æ•¸ä¸‹é™
    min_forwards: 4 # SF+PF ç¸½æ•¸ä¸‹é™
    
    # [Spec v3.5 Section 5.2] åˆ†å±¤ä½ç½®è¦†è“‹è¦å‰‡ (Updated)
    # ç¨‹å¼é‚è¼¯: éæ­·åˆ—è¡¨ä¸­çš„æ¯ä¸€æ¢è¦å‰‡ï¼Œæª¢æŸ¥ç¬¦åˆ target_grades çš„çƒå“¡é›†åˆæ˜¯å¦åŒ…å« required_positions
    coverage_rules:
      - name: "High Tier (SSR-A)"
        target_grades: ["SSR", "SS", "S", "A"]
        required_positions: ["C", "PF", "SF", "SG", "PG"]
      
      - name: "Mid Tier (B-C)"
        target_grades: ["B", "C"]
        required_positions: ["C", "PF", "SF", "SG", "PG"]

  # [Spec v3.2 Section 5.4] é–‹éšŠçƒå“¡ç‰¹æ®Šç”Ÿæˆè¦å‰‡ (New)
  # ç”¨é€”: åƒ…åœ¨é–‹éšŠæ™‚å•Ÿç”¨èƒ½åŠ›ä¸‹é™é™åˆ¶ï¼Œç¸®å°éš¨æ©Ÿç¯„åœ
  initial_team_min_ratio: 0.5 # ä¸‹é™ = ä¸Šé™ * 50%

minutes_distribution:
  # [Spec v3.1 Section 6] ä¸Šå ´æ™‚é–“åˆ†é…
  total_minutes: 240
  roles:
    Star:     {base: 30, min_w: -1, max_w: 5}
    Starter:  {base: 20, min_w: -2, max_w: 7}
    Rotation: {base: 10, min_w: 5,  max_w: 15}
    Role:     {base: 0,  min_w: 5,  max_w: 12}
    Bench:    {base: 0,  min_w: 0,  max_w: 10}

# =============================================================================
# 3. æ¯”è³½å¼•æ“è¨­å®š (Match Engine)
# å°æ‡‰è¦æ ¼æ›¸: Match Engine Specification v1.4
# =============================================================================
match_engine:
  # === å…¨åŸŸè¨­å®š (General Rules) ===
  general:
    quarter_length: 720            # æ¯ç¯€æ¯”è³½ç§’æ•¸ (12åˆ†é˜)
    ot_length: 300                 # å»¶é•·è³½ç§’æ•¸ (5åˆ†é˜)
    
    # [Spec v1.5 New] çŠ¯è¦èˆ‡æ›äººè¦å‰‡
    substitution:
      foul_limit: 6                # çŠ¯æ»¿é›¢å ´æ¬¡æ•¸
      stamina_threshold: 80.0      # ä½æ–¼æ­¤é«”åŠ›è§¸ç™¼æ›äºº
      clutch_time_threshold: 120   # [Spec v2.1] é—œéµæ™‚åˆ»å®šç¾© (æœ€å¾Œ2åˆ†é˜)
      
      # çŠ¯æ»¿é›¢å ´å¾Œçš„æ™‚é–“é‡åˆ†é…é‚è¼¯
      redistribution:
        method: "positional_top_k" # é‚è¼¯åç¨±: æ¯å€‹ä½ç½®å–å‰ K å
        top_k: 3                   # å–å‰ 3 å
        positions: ["C", "PF", "SF", "SG", "PG"] # éæ­·é †åº (å…± 15 å€‹ slot)
    
    # [Spec v2.1] é«”åŠ›ç³»çµ±åƒæ•¸ (æ›´æ–°)
    stamina_recovery_halftime: 20.0 # ä¸­å ´ä¼‘æ¯æ™‚é–“ (åˆ†é˜)
    stamina_recovery_quarter: 2.0   # ç¯€é–“ä¼‘æ¯æ™‚é–“ (åˆ†é˜)
    stamina_nerf_threshold: 80     # é«”åŠ›ä½æ–¼æ­¤æ•¸å€¼é–‹å§‹ï¼Œèƒ½åŠ›å€¼æœƒç·šæ€§è¡°é€€
    stamina_min_multiplier: 0.21   # é«”åŠ›è€—ç›¡(å‰©1)æ™‚ï¼Œèƒ½åŠ›å€¼å‰©ä¸‹çš„ç™¾åˆ†æ¯” (21%)
    stamina_drain_coeff: 3.0       # é«”åŠ›æ¶ˆè€—å…¬å¼çš„å€ç‡ä¿‚æ•¸ (æ•¸å€¼è¶Šå¤§æ¶ˆè€—è¶Šå¿«)

  # [Spec v2.1 Section 1.5] è³½å‰èº«é«˜ä¿®æ­£ (New)
  height_correction:
    bonus_threshold: 190 # BONUS_H
    nerf_threshold: 210  # NERF_H
    affected_attrs:
      speed_dribble:
        keys: ['ath_speed', 'off_dribble']
        coeff: 0.02
      handle_disrupt:
        keys: ['off_handle', 'def_disrupt']
        coeff: 0.01

  # [Spec v1.4 Section 2.3 & 2.4] é«”åŠ›è¨ˆç®—å…¬å¼æˆåˆ†
  stamina_system:
    drain_attrs: ['ath_stamina', 'talent_health']   # æ¶ˆè€—å…¬å¼: 3.0 * [1+(1-é«”èƒ½)] + (1-å¥åº·)
    recover_attrs: ['ath_stamina', 'talent_health'] # æ¢å¾©å…¬å¼: 1.0 + é«”èƒ½ - (1-å¥åº·)
    age_threshold: 20      # [New Spec v2.1]
    age_decay_rate: 0.01   # [New Spec v2.1]

  # [Spec 1.6 Section 1.5] é–‹å ´è·³çƒè¨­å®š (New)
  jump_ball:
    # åƒèˆ‡è€…ç¯©é¸å…¬å¼: èº«é«˜ + å½ˆè·³ + é€²æ”»æ™ºå•†
    participant_formula: ['height', 'ath_jump', 'talent_offiq']
    # ç²å‹æ©Ÿç‡è¨ˆç®—: ä¾æ“šæ•¸å€¼ç¸½å’Œæ¯”ä¾‹ (ç„¡é¡å¤–éš¨æ©Ÿä¿‚æ•¸ï¼Œç´”çœ‹æ•¸å€¼ä½”æ¯”)
    random_factor: 0.0 

  # [Spec v1.4 Section 1.1] ä½ç½®èƒ½åŠ›è©•åˆ† (Positional Scoring)
  # ç”¨é€”: æ±ºå®š Best 5 èˆ‡ è¼ªæ›¿é †åºï¼Œå®šç¾©æ¯å€‹ä½ç½®çœ‹é‡å“ªäº›å±¬æ€§
  positional_scoring:
    C:  ['height', 'ath_strength', 'def_rebound', 'def_boxout', 'def_contest']
    PF: ['height', 'ath_strength', 'def_rebound', 'def_boxout', 'def_contest', 'ath_jump', 'ath_speed']
    SF: ['all_stats', 'height'] 
    SG: ['shot_touch', 'shot_release', 'talent_offiq', 'talent_defiq', 'def_contest', 'def_disrupt', 'shot_range']
    PG: ['ath_speed', 'talent_offiq', 'def_disrupt', 'off_dribble', 'off_pass', 'off_handle', '-height'] # è² è™Ÿä»£è¡¨æ‰£åˆ†

  # [Spec v1.4 Section 5.1.A] å±¬æ€§æ± å®šç¾©
  # ç”¨é€”: å®šç¾©ã€Œé€²æ”»ç¸½å€¼ã€èˆ‡ã€Œé˜²å®ˆç¸½å€¼ã€åŒ…å«å“ªäº›å±¬æ€§
  attr_pools:
    off_14: ['ath_strength', 'ath_speed', 'ath_jump', 'shot_touch', 'shot_release', 'talent_offiq', 'talent_luck', 'shot_accuracy', 'shot_range', 'off_move', 'off_dribble', 'off_pass', 'off_handle', 'height']
    def_12: ['ath_strength', 'ath_speed', 'ath_jump', 'shot_touch', 'shot_release', 'talent_defiq', 'talent_luck', 'def_rebound', 'def_boxout', 'def_contest', 'def_disrupt', 'off_move'] # Def ç§»é™¤ height (ç”±å…¬å¼ç¨ç«‹è™•ç†æˆ–å±¬æ€§æ± ä¸å«), Spec 5.2.A Def_Total åŒ…å« height, é€™è£¡è£œä¸Š
    def_12_with_height: ['ath_strength', 'ath_speed', 'ath_jump', 'shot_touch', 'shot_release', 'talent_defiq', 'talent_luck', 'height', 'def_boxout', 'def_contest', 'def_disrupt', 'off_move']
    all_stats: [
      'ath_stamina', 'ath_strength', 'ath_speed', 'ath_jump', 
      'shot_touch', 'shot_release', 'talent_offiq', 'talent_defiq', 'talent_health', 'talent_luck',
      'shot_accuracy', 'shot_range', 'def_rebound', 'def_boxout', 'def_contest', 'def_disrupt', 
      'off_move', 'off_dribble', 'off_pass', 'off_handle', 'height'
    ]

  # === å¾Œå ´éšæ®µ (Backcourt Phase) [Spec v1.4 Section 3] ===
  backcourt:
    params:
      time_base_min: 3.5         # åŸºç¤éåŠå ´æ™‚é–“ä¸‹é™ (ç§’)
      time_base_max: 4.5         # åŸºç¤éåŠå ´æ™‚é–“ä¸Šé™ (ç§’)
      time_coeff: 0.008          # æ™‚é–“ä¿®æ­£ä¿‚æ•¸: (é˜²å®ˆç¸½å€¼ - é€²æ”»ç¸½å€¼) * 0.008
      violation_threshold: 8.0   # è¶…éæ­¤ç§’æ•¸ -> 8ç§’é•ä¾‹ (å¤±èª¤)
      steal_threshold: 3.0       # è¶…éæ­¤ç§’æ•¸ -> è§¸ç™¼å¾Œå ´æŠ„æˆªåˆ¤å®š
      fastbreak_threshold: 1.5   # ä½æ–¼æ­¤ç§’æ•¸ -> è§¸ç™¼å¿«æ”»åˆ¤å®š
      fastbreak_trigger_prob: 0.4 # [New] æ»¿è¶³æ™‚é–“é–€æª»å¾Œï¼Œå¯¦éš›è§¸ç™¼å¿«æ”»çš„æ©Ÿç‡ (50%)
      steal_base_prob: 0.01      # å¾Œå ´æŠ„æˆªåŸºç¤æ©Ÿç‡ (1%)
      steal_bonus_coeff: 0.001   # æŠ„æˆªæ©Ÿç‡åŠ æˆ: (é˜²å®ˆå·®å€¼) * 0.1%
      
      # [v2.3] æŠ„æˆªè½‰æ›è¨­å®š
      transition_base_prob: 0.50   # åŸºç¤æ©Ÿç‡ 50%
      
      # [New v2.4] é€Ÿåº¦æŠ˜æ‰£åƒæ•¸
      speed_discount_coeff: 0.1  # æŠ˜æ‰£ä¿‚æ•¸ (Random(0, AvgSpeed * coeff))
      speed_discount_coeff_def: 0.5  # é˜²å®ˆæ–¹æŠ˜æ‰£ä¿‚æ•¸ 
      min_time_limit: 0.5        # å¾Œå ´æ™‚é–“ç‰©ç†ä¸‹é™

    formulas:
      # [Spec 3.1] å±¬æ€§æ±  (å¢åŠ èº«é«˜æ‡²ç½°)
      off_sum: ['off_dribble', 'off_pass', 'talent_offiq', '-height']       # æ±ºå®šéåŠå ´é€Ÿåº¦çš„é€²æ”»å±¬æ€§
      def_sum: ['def_disrupt', 'def_contest', 'talent_defiq', '-height']    # æ±ºå®šéåŠå ´é˜»ç¤™çš„é˜²å®ˆå±¬æ€§
      # [Spec 3.4] æŠ„æˆªåˆ¤å®š (Def - Off)
      steal_off: ['off_dribble', 'off_pass', 'talent_offiq', '-height']     # è¢«æŠ„æˆªè€…çš„æŠµæŠ—å±¬æ€§
      steal_def: ['def_disrupt', 'def_contest', 'talent_defiq', '-height']  # æŠ„æˆªè€…çš„æ”»æ“Šå±¬æ€§
      # [v2.3] è½‰æ›åˆ¤å®šç”¨çš„é€Ÿåº¦ç¸½å’Œ (å…¨éšŠ)
      team_speed_sum: ['ath_speed']
      
      # [New v2.4] å¾Œå ´é€Ÿåº¦æŠ˜æ‰£è¨ˆç®—ç”¨ (3äºº)
      backcourt_speed: ['ath_speed']

    # [Spec v1.4 Section 3.5] å¿«æ”»åˆ¤å®š
    fastbreak:
      params:
        base_success_min: 0.3    # å¿«æ”»åŸºç¤æˆåŠŸç‡ä¸‹é™ (30%)
        base_success_max: 1.0    # å¿«æ”»åŸºç¤æˆåŠŸç‡ä¸Šé™ (100%)
        stat_diff_coeff: 0.005   # æˆåŠŸç‡ä¿®æ­£: (å±¬æ€§å·®) * 0.5%
        foul_base_prob: 0.01     # å¿«æ”»çŠ¯è¦åŸºç¤æ©Ÿç‡ (1%)
        foul_iq_coeff: 0.01      # çŠ¯è¦æ™ºå•†ä¿®æ­£: (IQå·®) * 1%

      formulas:
        runner_selection: ['ath_speed', 'off_dribble']   # æ±ºå®šèª°è·‘å¿«æ”» (è·‘æœ€å¿«è€…)
        chaser_selection: ['ath_speed', 'talent_defiq']  # æ±ºå®šèª°è¿½é˜² (è¿½æœ€å¿«è€…)
        
        # [Spec 3.5.A] å¿«æ”»ç¶œåˆèƒ½åŠ› (9é … vs 9é …)
        off_power: ['ath_strength', 'ath_speed', 'ath_jump', 'shot_touch', 'shot_release', 'talent_offiq', 'talent_luck', 'off_move', 'off_dribble', 'shot_accuracy']
        def_power: ['ath_strength', 'ath_speed', 'ath_jump', 'shot_touch', 'shot_release', 'talent_defiq', 'talent_luck', 'def_contest', 'def_disrupt']
        
        # [Spec 3.5.C] çŠ¯è¦åˆ¤å®š
        foul_off_iq: ['talent_offiq'] # é€²æ”»æ–¹ IQ
        foul_def_iq: ['talent_defiq'] # é˜²å®ˆæ–¹ IQ

  # === å‰å ´éšæ®µ (Frontcourt Phase) [Spec v1.4 Section 4] ===
  frontcourt:
    params:
      time_min_limit: 4.0        # å‰å ´é€²æ”»æ™‚é–“ä¸‹é™ (æœ€å¿«4ç§’å‡ºæ‰‹)
      time_quality_base: 7.0     # å“è³ªåŸºæº–ç§’æ•¸ (ä½æ–¼7ç§’é–‹å§‹æœ‰å‘½ä¸­åŠ æˆ)
      spacing_bonus_coeff: 0.1   # ç©ºé–“åŠ æˆæ¬Šé‡ (10%)
      
      # [New v2.4] é€Ÿåº¦æŠ˜æ‰£èˆ‡é•ä¾‹åƒæ•¸
      speed_discount_coeff: 0.01  # æŠ˜æ‰£ä¿‚æ•¸
      violation_threshold: 24.0  # 24ç§’é•ä¾‹ç¸½æ™‚é–“é–¾å€¼
      absolute_min_time: 0.4     # å‰å ´æ™‚é–“ç‰©ç†ä¸‹é™
    
    formulas:
      # [Spec 4.1] æ™‚é–“ä¸‹é™ä¿®æ­£ (åœ˜éšŠå±¬æ€§)
      time_reduction: ['ath_speed', 'talent_offiq', 'off_pass'] # é€™äº›å±¬æ€§è¶Šé«˜ï¼Œé€²æ”»æ™‚é–“ä¸‹é™è¶Šä½
      
      # [Spec 4.2] ç©ºé–“èˆ‡è·‘ä½
      spacing_off: ['off_move', 'talent_offiq'] # é€²æ”»æ–¹è£½é€ ç©ºé–“çš„å±¬æ€§
      spacing_def: ['off_move', 'talent_defiq'] # é˜²å®ˆæ–¹å£“ç¸®ç©ºé–“çš„å±¬æ€§
      
      # [New v2.4] å‰å ´é€Ÿåº¦æŠ˜æ‰£è¨ˆç®—ç”¨ (5äºº)
      frontcourt_speed: ['ath_speed']

    # [Spec v1.4 Section 4.3] å°è“‹åˆ¤å®š
    block:
      params:
        base_prob: 0.01             # åŸºç¤å°è“‹è§¸ç™¼ç‡ (1%)
        spacing_penalty_prob: 0.05  # ç•¶ç©ºé–“æ“æ“ (<0)æ™‚ï¼Œé¡å¤–å¢åŠ çš„å°è“‹ç‡ (5%)
      formulas:
        # éšæ®µä¸€: è§¸ç™¼ (èƒ½å¦æ‘¸åˆ°çƒ)
        trigger_off: ['off_move']                    # é€²æ”»è·‘ä½è¶Šé«˜ï¼Œè¶Šé›£è¢«å°è“‹
        trigger_def: ['def_contest', 'talent_defiq'] # é˜²å®ˆå¹²æ“¾è¶Šé«˜ï¼Œè¶Šå®¹æ˜“è§¸ç™¼å°è“‹
        # éšæ®µäºŒ: å°æŠ— (Power Ratio - ç¡¬ç¢°ç¡¬)
        power_off: ['ath_strength', 'ath_jump', 'talent_offiq', 'height']
        power_def: ['ath_strength', 'ath_jump', 'def_contest', 'talent_defiq', 'height']

    # [Spec v1.4 Section 4.4] å‰å ´æŠ„æˆª
    steal:
      params:
        base_prob: 0.01          # åŸºç¤å‰å ´æŠ„æˆªç‡ (1%)
        stat_diff_coeff: 0.001   # æ©Ÿç‡åŠ æˆä¿‚æ•¸ (0.1%)
      formulas:
        off_attr: ['off_dribble', 'off_handle', 'off_pass', 'talent_offiq', '-height']      # æŒçƒè€…çš„è­·çƒå±¬æ€§
        def_attr: ['ath_speed', 'def_disrupt', 'talent_defiq', '-height']   # é˜²å®ˆè€…çš„æŠ„æˆªå±¬æ€§

  # === æŠ•ç±ƒèˆ‡çµç®— (Shooting & Scoring) [Spec v2.1 Section 5] ===
  shooting:
    params:
      base_rate_2pt: 0.40         # [Spec 5.1] å…©åˆ†çƒåŸºç¤å‘½ä¸­ç‡ (40%) - v1.7
      base_rate_3pt: 0.20         # [Spec 5.1] ä¸‰åˆ†çƒåŸºç¤å‘½ä¸­ç‡ (20%) - v1.7
      spacing_weight: 0.1         # ç©ºé–“åŠ æˆä¿‚æ•¸ (å…¬å¼ä¸­çš„ * 0.1)
      assist_prob_coeff: 0.1      # [Spec 5.5] åŠ©æ”»æ©Ÿç‡ä¿‚æ•¸ (å…¬å¼ä¸­çš„ * 0.1)
      multiplier_3pt: 1.2         # [Spec 5.2.A] 3åˆ†çƒç‰¹æ®ŠåŠ æˆå€ç‡
      
      # [New] æŠ€å·§åŠ æˆåƒæ•¸
      # å…¬å¼: * (1 + (å±¬æ€§ç¸½å’Œ / divisor))
      skill_bonus_divisor: 800.0 
    
    formulas:
      # [Spec 5.2.A] å‘½ä¸­ç‡ç¸½å’Œ (åŒ…å« height)
      off_total: 'off_14'         # å¼•ç”¨ attr_pools.off_14 (å« height)
      def_total: 'def_12_with_height' # å¼•ç”¨ attr_pools.def_12_with_height
      
      # [New] æŠ€å·§åŠ æˆå±¬æ€§æ± 
      # å®šç¾©å“ªäº›å±¬æ€§æœƒå½±éŸ¿åŸºç¤å‘½ä¸­ç‡çš„é¡å¤–åŠ æˆ
      skill_bonus_attrs: ['shot_accuracy', 'shot_range', 'off_move']
      
      # 3åˆ†çƒç‰¹æ®ŠåŠ æˆå±¬æ€§ (é€™äº›å±¬æ€§åœ¨3åˆ†åˆ¤å®šæ™‚æœƒ x multiplier_3pt)
      bonus_3pt_attrs: ['shot_accuracy', 'shot_range', 'off_move']
      
      # [Spec 5.2] çŠ¯è¦åˆ¤å®š (IQ vs IQ)
      foul_off_iq: ['talent_offiq']
      foul_def_iq: ['talent_defiq']
      
      # [Spec 5.3] ä¸‰åˆ†çƒåˆ¤å®š
      range_attr: ['shot_range']  # å°„ç¨‹è¶Šé«˜ï¼Œä¸‰åˆ†çƒæ©Ÿç‡è¶Šé«˜

    # [Spec v1.4 Section 5.4] ç±ƒæ¿åˆ¤å®š
    rebound:
      params:
        def_base_rate: 0.10       # é˜²å®ˆç±ƒæ¿åŸºç¤å„ªå‹¢ (10%)
      formulas:
        off_attr: ['talent_offiq', 'def_rebound', 'def_boxout', 'height'] # é€²æ”»ç±ƒæ¿å±¬æ€§
        def_attr: ['talent_defiq', 'def_rebound', 'def_boxout', 'height'] # é˜²å®ˆç±ƒæ¿å±¬æ€§

    # [Spec v1.4 Section 5.2 & 5.3] ç½°çƒ
    ft:
      params:
        base_min: 0.40            # ç½°çƒåŸºç¤å‘½ä¸­ç‡ä¸‹é™
        base_max: 0.95            # ç½°çƒåŸºç¤å‘½ä¸­ç‡ä¸Šé™
        attr_coeff: 0.0001        # å±¬æ€§ä¿®æ­£ä¿‚æ•¸ (100é»å±¬æ€§ç´„ +1%)
      formulas:
        bonus_attrs: ['talent_luck', 'shot_touch'] # ç½°çƒçœ‹é‹æ°£èˆ‡æ‰‹æ„Ÿ

    # [Spec v1.4 Section 5.5] åŠ©æ”»
    assist:
      formulas:
        team_stat: ['talent_offiq', 'off_handle', 'off_pass', 'off_move'] # åˆ¤å®šæ˜¯å¦ç™¼ç”ŸåŠ©æ”»çš„åœ˜éšŠå±¬æ€§
        luck_stat: ['talent_luck']                                         # å½±éŸ¿åŠ©æ”»ä¿‚æ•¸çš„é‹æ°£å±¬æ€§
        distribution: ['off_handle', 'off_pass']                           # ç”¨æ–¼æ±ºå®šæ˜¯èª°å‚³å‡ºåŠ©æ”»çš„æ¬Šé‡

  # === æ•¸æ“šæ­¸å±¬æ¬Šé‡ (Data Attribution) [Spec v1.4 Section 6] ===
  attribution:
    params:
      shot_star_bonus: 1.5        # Star çƒå“¡å‡ºæ‰‹æ¬Šé‡åŠ æˆ (1.5å€)
      shot_starter_bonus: 1.2     # Starter çƒå“¡å‡ºæ‰‹æ¬Šé‡åŠ æˆ (1.2å€)
      rebound_height_weight: 1.5  # èº«é«˜/å½ˆè·³/ç±ƒæ¿/å¡ä½çš„åŠ æ¬Šå€ç‡ (1.5å€)
    
    formulas:
      # [Spec 6.1] æŠ•ç±ƒæ­¸å±¬ (å¼•ç”¨ Off_Total, é¡å¤–åŠ æˆç”±ç¨‹å¼é‚è¼¯åˆ¤æ–· 3åˆ†/2åˆ†)
      shot_weight_base: 'off_14'  # åŸºç¤å‡ºæ‰‹æ¬Šé‡çœ‹é€²æ”»ç¸½å€¼
      shot_3pt_bonus: ['shot_release', 'shot_range', 'off_move'] # è‹¥æ˜¯ä¸‰åˆ†çƒå›åˆï¼Œé€™äº›å±¬æ€§æ¬Šé‡åŠ å€

      # [Spec 6.3] ç±ƒæ¿æ­¸å±¬
      rebound_base: ['ath_strength', 'ath_speed', 'off_move']    # åŸºç¤æ¬Šé‡
      rebound_bonus: ['ath_jump', 'def_rebound', 'def_boxout']   # åŠ æ¬Šæ¬Šé‡ (æœƒä¹˜ä¸Š height_weight)
      rebound_iq_off: ['talent_offiq']                           # é€²æ”»ç±ƒæ¿é¡å¤–çœ‹ IQ
      rebound_iq_def: ['talent_defiq']                           # é˜²å®ˆç±ƒæ¿é¡å¤–çœ‹ IQ

      # [Spec 6.4] åŠ©æ”»æ­¸å±¬
      assist_weight: ['off_handle', 'off_pass', 'talent_offiq']  # èª°æœ€å®¹æ˜“æ‹¿åˆ°åŠ©æ”»

      # [Spec 6.5] æŠ„æˆªæ­¸å±¬
      steal_weight: ['def_disrupt', 'talent_defiq', 'ath_speed', 'def_contest'] # èª°æœ€å®¹æ˜“æ‹¿åˆ°æŠ„æˆª
```

---

### ğŸ“„ File: `frontend\src\App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
```

---

### ğŸ“„ File: `frontend\src\App.tsx`

```tsx
import React, { useState, useEffect } from 'react';
import { 
  Users, Trophy, Calendar, ClipboardList, Search, 
  ShoppingBag, Repeat, MessageSquare, BookOpen, 
  LogOut, User as UserIcon
} from 'lucide-react';

// --- å‹åˆ¥å®šç¾© ---
interface UserState {
  id: number;
  username: string;
  teamId: number;
}

interface TeamDashboard {
  id: number;
  name: string;
  funds: number;
  reputation: number;
  arena_name: string;
  fanpage_name: string;
  scout_chances: number;
  player_count: number;
  roster_limit: number;
  season_wins: number;
  season_losses: number;
  rank: number;
  total_teams: number;
  owner: string;
}

// --- å…ƒä»¶ï¼šSidebar ---
const Sidebar = ({ activeTab, setActiveTab }: { activeTab: string, setActiveTab: (t: string) => void }) => {
  const menuItems = [
    { id: 'dashboard', label: 'é¦–é ', icon: <Users size={18} /> },
    { id: 'players', label: 'çƒå“¡', icon: <Users size={18} /> },
    { id: 'teams', label: 'çƒéšŠ', icon: <Trophy size={18} /> },
    { id: 'scouts', label: 'çƒæ¢', icon: <Search size={18} /> },
    { id: 'schedules', label: 'è³½ç¨‹', icon: <Calendar size={18} /> },
    { id: 'tactics', label: 'æˆ°è¡“', icon: <ClipboardList size={18} /> },
    { id: 'market', label: 'å¸‚å ´', icon: <ShoppingBag size={18} /> },
    { id: 'trades', label: 'äº¤æ›', icon: <Repeat size={18} /> },
    { id: 'community', label: 'ç¤¾ç¾¤', icon: <MessageSquare size={18} /> },
    { id: 'guide', label: 'æŒ‡å—', icon: <BookOpen size={18} /> },
  ];

  return (
    <aside className="w-64 bg-asbl-panel border-r border-black/20 flex flex-col p-4 text-[#1f093a] hidden md:flex">
      <div className="text-xs font-bold tracking-wider mb-2 text-[#2b0c60] uppercase">é¸å–®</div>
      <nav className="flex-1 space-y-1">
        {menuItems.map((item) => (
          <button
            key={item.id}
            onClick={() => setActiveTab(item.id)}
            className={`w-full flex items-center gap-3 px-3 py-2.5 rounded-lg text-sm font-medium transition-all
              ${activeTab === item.id 
                ? 'bg-white/40 border border-black/20 text-[#14043a] font-bold shadow-sm' 
                : 'bg-white/20 border border-transparent hover:bg-white/30 hover:border-black/10'
              }`}
          >
            {item.icon}
            {item.label}
          </button>
        ))}
      </nav>
    </aside>
  );
};

// --- å…ƒä»¶ï¼šHeader ---
const Header = ({ user, onLogout }: { user: UserState, onLogout: () => void }) => {
  const [time, setTime] = useState(new Date());
  const [playerStats, setPlayerStats] = useState({ active: 0, total: 0 });

  useEffect(() => {
    const timer = setInterval(() => setTime(new Date()), 1000);
    return () => clearInterval(timer);
  }, []);

  useEffect(() => {
    const fetchStats = async () => {
      try {
        const res = await fetch('/api/system/stats');
        if (res.ok) {
          const data = await res.json();
          setPlayerStats({
            active: data.active_users,
            total: data.total_users
          });
        }
      } catch (error) {
        console.error("Failed to fetch system stats:", error);
      }
    };
    fetchStats();
    const statsTimer = setInterval(fetchStats, 60000);
    return () => clearInterval(statsTimer);
  }, []);

  return (
    <header className="h-[88px] bg-header-gradient px-6 flex items-center justify-between shadow-md relative z-10">
      {/* Left: Logo */}
      <div className="flex items-center gap-4">
        <div className="w-11 h-11 bg-white/20 rounded-lg border border-white/40 flex items-center justify-center overflow-hidden backdrop-blur-sm">
          <span className="text-2xl">ğŸ€</span>
        </div>
        <div className="flex flex-col">
          <h1 className="text-2xl font-black tracking-wide uppercase bg-gold-text bg-clip-text text-transparent drop-shadow-sm" 
              style={{ WebkitTextStroke: '0.5px rgba(0,0,0,0.4)' }}>
            ASBL
          </h1>
          <span className="text-[10px] font-bold text-gray-800 tracking-wider -mt-1 opacity-70">
            BASKETBALL MANAGER
          </span>
        </div>
      </div>

      {/* Middle: Info */}
      <div className="hidden md:flex flex-col items-center text-sm text-gray-900 gap-0.5">
        <div>
          <span className="opacity-70 mr-2">æ—¥æœŸ:</span>
          <span className="font-bold">{time.toLocaleDateString('zh-TW')}</span>
        </div>
        <div>
          <span className="opacity-70 mr-2">æ™‚é–“:</span>
          <span className="font-bold font-mono">{time.toLocaleTimeString('zh-TW', { hour12: false })}</span>
        </div>
        <div className="text-xs">
          <span className="opacity-70 mr-2">æ´»èº/ç¸½æ•¸:</span>
          <span className="font-bold text-blue-900">
            {playerStats.active} / {playerStats.total}
          </span>
        </div>
      </div>

      {/* Right: User */}
      <div className="flex items-center gap-4">
        <div className="flex items-center gap-3 bg-white/20 px-3 py-1.5 rounded-full border border-white/30 backdrop-blur-sm">
          <div className="w-7 h-7 rounded-full bg-gray-800 text-white flex items-center justify-center text-xs font-bold border border-white/50">
            {user.username.charAt(0).toUpperCase()}
          </div>
          <span className="text-sm font-bold text-gray-900">{user.username}</span>
        </div>
        <button onClick={onLogout} className="bg-gray-900 hover:bg-gray-800 text-white text-xs px-3 py-2 rounded-lg transition-colors flex items-center gap-2">
          <LogOut size={14} />
          ç™»å‡º
        </button>
      </div>
    </header>
  );
};

// --- é é¢ï¼šDashboard (é¦–é ) ---
const Dashboard = ({ teamId, username }: { teamId: number, username: string }) => {
  const [data, setData] = useState<TeamDashboard | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const res = await fetch(`/api/team/${teamId}/dashboard`);
        if (res.ok) {
          setData(await res.json());
        }
      } catch (e) {
        console.error(e);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [teamId]);

  if (loading) return <div className="p-6 text-white">è¼‰å…¥ä¸­...</div>;
  if (!data) return <div className="p-6 text-white">ç„¡æ³•è®€å–çƒéšŠè³‡æ–™</div>;

  const stats = [
    { label: "çƒéšŠåç¨±", value: data.name },
    { label: "çƒéšŠè³‡é‡‘", value: `$${data.funds.toLocaleString()}` },
    { label: "çƒéšŠè²æœ›", value: data.reputation },
    { label: "å ´é¤¨åç¨±", value: data.arena_name || "æœªå‘½å" },
    { label: "ç²‰çµ²åœ˜", value: data.fanpage_name || "æœªå‘½å" },
    { label: "çƒæ¢æ¬¡æ•¸", value: data.scout_chances },
    { label: "çƒå“¡äººæ•¸", value: `${data.player_count} / ${data.roster_limit}` },
    { label: "è¯è³½æˆ°ç¸¾", value: `${data.season_wins}å‹ - ${data.season_losses}æ•— (ç¬¬${data.rank}å)` },
  ];

  return (
    <div className="space-y-6 animate-in fade-in duration-500">
      <div className="bg-asbl-panel/20 border border-asbl-panel p-6 rounded-2xl backdrop-blur-sm">
        <h2 className="text-2xl font-bold text-gray-900 mb-4 flex items-center gap-2">
          æ­¡è¿å›ä¾†ï¼Œ{username}ï¼
        </h2>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          {stats.map((stat, idx) => (
            <div key={idx} className="bg-white/40 border border-white/50 p-4 rounded-xl shadow-sm hover:bg-white/60 transition-colors">
              <div className="text-xs text-gray-600 mb-1">{stat.label}</div>
              <div className="text-lg font-bold text-gray-900 truncate">{stat.value}</div>
            </div>
          ))}
        </div>
      </div>

      {/* å¿«é€Ÿæ“ä½œå€ */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="bg-white/30 border border-white/40 p-6 rounded-2xl shadow-sm">
          <h3 className="font-bold text-gray-800 mb-3">çƒéšŠå‹•æ…‹</h3>
          <ul className="space-y-2 text-sm text-gray-700">
            <li className="flex items-center gap-2">
              <span className="w-2 h-2 rounded-full bg-green-500"></span>
              ç³»çµ±åˆå§‹åŒ–å®Œæˆï¼ŒçƒéšŠå·²å»ºç«‹ã€‚
            </li>
            <li className="flex items-center gap-2">
              <span className="w-2 h-2 rounded-full bg-blue-500"></span>
              åˆå§‹ 15 äººåå–®å·²ç”Ÿæˆã€‚
            </li>
          </ul>
        </div>
      </div>
    </div>
  );
};

// --- é é¢ï¼šAuth (ç™»å…¥/è¨»å†Š) ---
const AuthPage = ({ onLogin }: { onLogin: (user: UserState) => void }) => {
  const [isLogin, setIsLogin] = useState(true);
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    team_name: '' // Optional
  });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    const endpoint = isLogin ? '/api/auth/login' : '/api/auth/register';
    
    try {
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });

      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.error || 'æ“ä½œå¤±æ•—');
      }

      // ç™»å…¥/è¨»å†ŠæˆåŠŸ
      onLogin({
        id: data.user_id,
        username: isLogin ? data.username : formData.username,
        teamId: data.team_id
      });

    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-asbl-bg p-4">
      <div className="w-full max-w-md bg-white/10 backdrop-blur-md border border-white/20 p-8 rounded-2xl shadow-2xl">
        <div className="text-center mb-8">
          <h1 className="text-3xl font-black text-white mb-2">ASBL</h1>
          <p className="text-gray-300 text-sm">BASKETBALL MANAGER</p>
        </div>

        <div className="flex mb-6 bg-black/20 p-1 rounded-lg">
          <button
            onClick={() => setIsLogin(true)}
            className={`flex-1 py-2 rounded-md text-sm font-bold transition-all ${isLogin ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-400 hover:text-white'}`}
          >
            ç™»å…¥
          </button>
          <button
            onClick={() => setIsLogin(false)}
            className={`flex-1 py-2 rounded-md text-sm font-bold transition-all ${!isLogin ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-400 hover:text-white'}`}
          >
            è¨»å†Š
          </button>
        </div>

        {error && (
          <div className="bg-red-500/20 border border-red-500/50 text-red-200 text-sm p-3 rounded-lg mb-4 text-center">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-xs font-bold text-gray-300 mb-1">ä½¿ç”¨è€…åç¨±</label>
            <input
              type="text"
              required
              className="w-full bg-black/20 border border-white/10 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-asbl-pink transition-all"
              placeholder="Manager Name"
              value={formData.username}
              onChange={e => setFormData({...formData, username: e.target.value})}
            />
          </div>

          {!isLogin && (
            <>
              <div>
                <label className="block text-xs font-bold text-gray-300 mb-1">é›»å­ä¿¡ç®±</label>
                <input
                  type="email"
                  required
                  className="w-full bg-black/20 border border-white/10 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-asbl-pink transition-all"
                  placeholder="email@example.com"
                  value={formData.email}
                  onChange={e => setFormData({...formData, email: e.target.value})}
                />
              </div>
              <div>
                <label className="block text-xs font-bold text-gray-300 mb-1">çƒéšŠåç¨± (é¸å¡«)</label>
                <input
                  type="text"
                  className="w-full bg-black/20 border border-white/10 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-asbl-pink transition-all"
                  placeholder="é è¨­ç‚º Team_{ID}"
                  value={formData.team_name}
                  onChange={e => setFormData({...formData, team_name: e.target.value})}
                />
              </div>
            </>
          )}

          <div>
            <label className="block text-xs font-bold text-gray-300 mb-1">å¯†ç¢¼</label>
            <input
              type="password"
              required
              className="w-full bg-black/20 border border-white/10 rounded-lg px-4 py-2.5 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-asbl-pink transition-all"
              placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
              value={formData.password}
              onChange={e => setFormData({...formData, password: e.target.value})}
            />
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-gradient-to-r from-asbl-pink to-asbl-violet hover:opacity-90 text-white font-bold py-3 rounded-xl shadow-lg transform active:scale-95 transition-all disabled:opacity-50 disabled:cursor-not-allowed mt-4"
          >
            {loading ? 'è™•ç†ä¸­...' : (isLogin ? 'é€²å…¥éŠæˆ²' : 'å»ºç«‹çƒéšŠ')}
          </button>
        </form>
      </div>
    </div>
  );
};

// --- ä¸»ç¨‹å¼å…¥å£ ---
function App() {
  const [user, setUser] = useState<UserState | null>(null);
  const [activeTab, setActiveTab] = useState('dashboard');

  // æª¢æŸ¥ LocalStorage æ˜¯å¦æœ‰ç™»å…¥ç‹€æ…‹ (ç°¡æ˜“æŒä¹…åŒ–)
  useEffect(() => {
    const savedUser = localStorage.getItem('asbl_user');
    if (savedUser) {
      setUser(JSON.parse(savedUser));
    }
  }, []);

  const handleLogin = (userData: UserState) => {
    setUser(userData);
    localStorage.setItem('asbl_user', JSON.stringify(userData));
  };

  const handleLogout = () => {
    setUser(null);
    localStorage.removeItem('asbl_user');
  };

  if (!user) {
    return <AuthPage onLogin={handleLogin} />;
  }

  return (
    <div className="min-h-screen bg-asbl-bg text-gray-900 font-sans selection:bg-asbl-pink selection:text-white">
      <Header user={user} onLogout={handleLogout} />
      <div className="flex min-h-[calc(100vh-88px)]">
        <Sidebar activeTab={activeTab} setActiveTab={setActiveTab} />
        
        <main className="flex-1 bg-asbl-main p-6 overflow-y-auto">
          {activeTab === 'dashboard' && <Dashboard teamId={user.teamId} username={user.username} />}
          {activeTab === 'players' && <div className="text-center mt-20 text-gray-600">çƒå“¡åˆ—è¡¨é–‹ç™¼ä¸­...</div>}
          {activeTab === 'scouts' && <div className="text-center mt-20 text-gray-600">çƒæ¢ä¸­å¿ƒé–‹ç™¼ä¸­...</div>}
          {/* å…¶ä»–é é¢... */}
        </main>
      </div>
    </div>
  );
}

export default App;
```

---

### ğŸ“„ File: `frontend\src\index.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

---

### ğŸ“„ File: `frontend\src\main.tsx`

```tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
```

---

### ğŸ“„ File: `frontend\eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
```

---

### ğŸ“„ File: `frontend\index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>frontend</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

---

### ğŸ“„ File: `frontend\package.json`

```json
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.90.21",
    "axios": "^1.13.5",
    "clsx": "^2.1.1",
    "lucide-react": "^0.564.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.13.0",
    "tailwind-merge": "^3.4.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.24",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.17",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.48.0",
    "vite": "^7.3.1"
  }
}
```

---

### ğŸ“„ File: `frontend\postcss.config.js`

```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

---

### ğŸ“„ File: `frontend\README.md`

```markdown
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
```

---

### ğŸ“„ File: `frontend\tailwind.config.js`

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // èƒŒæ™¯è‰²ç³»
        'asbl-bg': '#0b1220',      // ç¶²é æ·±è‰²åº•
        'asbl-panel': '#C084FC',   // å´é‚Šæ¬„åº•è‰² (èˆŠç‰ˆè®Šæ•¸)
        'asbl-main': '#BFA8FF',    // ä¸»å…§å®¹å€åº•è‰² (èˆŠç‰ˆè®Šæ•¸)
        
        // æ¼¸å±¤è‰²ç³» (Header)
        'asbl-pink': '#FFA6C9',
        'asbl-blue': '#21B7D6',
        'asbl-violet': '#8B5CF6',

        // é‡‘è‰²å­—é«” (Brand)
        'gold-light': '#FFFFFF',
        'gold-main': '#F8E3B0',
        'gold-shadow': '#A67C00',
      },
      backgroundImage: {
        'header-gradient': 'linear-gradient(90deg, #FFA6C9 0%, #FFAACD 12%, #7ED3E3 22%, #21B7D6 35%, #1FB0D0 55%, #5DA9EF 65%, #7F6AF6 78%, #8B5CF6 100%)',
        'gold-text': 'linear-gradient(180deg, #FFFFFF 0%, #F8E3B0 55%, #A67C00 100%)',
      }
    },
  },
  plugins: [],
}
```

---

### ğŸ“„ File: `frontend\tsconfig.app.json`

```json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
```

---

### ğŸ“„ File: `frontend\tsconfig.json`

```json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
```

---

### ğŸ“„ File: `frontend\tsconfig.node.json`

```json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
```

---

### ğŸ“„ File: `frontend\vite.config.ts`

```typescript
// frontend/vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {
        target: 'http://127.0.0.1:5000',
        changeOrigin: true,
        secure: false,
      }
    }
  }
})
```

---

### ğŸ“„ File: `scripts\utils\project_exporter.py`

```python
# scripts/utils/project_exporter.py
# -*- coding: utf-8 -*-
"""
å°ˆæ¡ˆåç¨±ï¼šASBL-Basketball-Manager (ç±ƒçƒæ•¸æ“šéŠæˆ²)
æ¨¡çµ„åç¨±ï¼šå°ˆæ¡ˆä»£ç¢¼åŒ¯å‡ºå·¥å…· (Project Exporter) - Full Stack Version
åŠŸèƒ½æè¿°ï¼š
    æ•´åˆæª”æ¡ˆæ¨¹ç”Ÿæˆèˆ‡ä»£ç¢¼åˆä½µåŠŸèƒ½ï¼Œæ”¯æ´å‰å¾Œç«¯å®Œæ•´æ¶æ§‹ã€‚
    1. æƒæå°ˆæ¡ˆç›®éŒ„ï¼Œæ ¹æ“šè¨­å®šçš„å‰¯æª”åéæ¿¾æª”æ¡ˆ (åŒ…å« Python å¾Œç«¯èˆ‡ React/TS å‰ç«¯)ã€‚
    2. ç”Ÿæˆå°ˆæ¡ˆçµæ§‹æ¨¹ç‹€åœ– (è‡ªå‹•æ’é™¤ node_modules, venv ç­‰éæ ¸å¿ƒç›®éŒ„)ã€‚
    3. åˆä½µæ‰€æœ‰ç¬¦åˆæ¢ä»¶çš„æª”æ¡ˆå…§å®¹è‡³å–®ä¸€ Markdown æ–‡ä»¶ã€‚
    4. ç”¨æ–¼æä¾› LLM å®Œæ•´çš„å°ˆæ¡ˆä¸Šä¸‹æ–‡æˆ–é€²è¡Œä»£ç¢¼å‚™ä»½ã€‚

ä½¿ç”¨èªªæ˜ï¼š
    æ–¼å°ˆæ¡ˆæ ¹ç›®éŒ„åŸ·è¡Œï¼š
    python scripts/utils/project_exporter.py

    è¼¸å‡ºæª”æ¡ˆé è¨­ä½æ–¼ï¼šdocs/PROJECT_CONTEXT_YYYYMMDD_HHMMSS.md

ä½œè€…ï¼šMonica (AI Assistant)
æ—¥æœŸï¼š2026-02-06
"""

import os
import argparse
from pathlib import Path
from datetime import datetime
from typing import Set, List, Tuple, Optional

class ProjectExporter:
    """
    å°ˆæ¡ˆåŒ¯å‡ºå™¨é¡åˆ¥
    è² è²¬æƒæç›®éŒ„ã€ç”Ÿæˆæ¨¹ç‹€åœ–åŠåˆä½µæª”æ¡ˆå…§å®¹
    """

    # ==========================================
    # éœæ…‹é…ç½®åƒæ•¸ (Configuration)
    # ==========================================
    
    # è¼¸å‡ºç›®éŒ„
    OUTPUT_DIR: str = "docs/PROJECT_CONTEXT"
    
    # è¼¸å‡ºçš„æª”æ¡ˆå‰ç¶´
    OUTPUT_FILENAME_PREFIX: str = "PROJECT_CONTEXT"
    
    # è¦åŒ…å«çš„æª”æ¡ˆå‰¯æª”å (ç™½åå–®) - [å·²æ“´å……å‰ç«¯æ”¯æ´]
    TARGET_EXTENSIONS: Set[str] = {
        # Backend & Config
        '.py', '.env', '.md', '.yaml', '.yml', '.sql',
        # Frontend (React + TypeScript + Vite)
        '.ts', '.tsx',   # æ ¸å¿ƒé‚è¼¯èˆ‡çµ„ä»¶
        '.js', '.jsx',   # è¨­å®šæª”æˆ–èˆŠä»£ç¢¼
        '.json',         # tsconfig, package.json ç­‰è¨­å®š
        '.html',         # index.html å…¥å£
        '.css', '.scss'  # Tailwind æˆ–å…¨åŸŸæ¨£å¼
    }

    # [æ–°å¢] å¼·åˆ¶åŒ…å«çš„ç‰¹å®šæª”æ¡ˆåç¨± (ä¸è«–å‰¯æª”åç‚ºä½•)
    INCLUDE_FILES: Set[str] = {
        'requirements.txt',
        'Dockerfile',
        'Procfile'
    }
    
    # è¦æ’é™¤çš„ç›®éŒ„åç¨± (é»‘åå–®)
    EXCLUDE_DIRS: Set[str] = {
        # General / IDE
        '.git', '.idea', '.vscode',
        # Backend
        '__pycache__', '.venv', 'venv', 'env', '.pytest_cache', 'htmlcov',
        # Frontend / Build
        'node_modules', 'site-packages', 
        'build', 'dist', '.vite', 'coverage', 'public', # public é€šå¸¸æ”¾åœ–æª”ï¼Œä¸éœ€è®€å–ä»£ç¢¼
        # Output / Logs
        'docs', 'backup', 'output', 'data', 'reports', 'logs'
    }
    
    # è¦æ’é™¤çš„ç‰¹å®šæª”æ¡ˆåç¨± (é»‘åå–®)
    EXCLUDE_FILES: Set[str] = {
        '.DS_Store', 'Thumbs.db',
        # Lock files (é€šå¸¸å¤ªé•·ä¸”ç„¡åŠ©æ–¼ç†è§£é‚è¼¯)
        'poetry.lock', 'Pipfile.lock', 'yarn.lock', 'package-lock.json', 'pnpm-lock.yaml',
        'LICENSE', '.gitignore', 'favicon.ico', 'logo.png'
    }

    # ==========================================
    # æ ¸å¿ƒé‚è¼¯æ–¹æ³• (Core Logic)
    # ==========================================

    @staticmethod
    def run() -> None:
        """
        ä¸»åŸ·è¡Œå…¥å£
        """
        # 1. åˆå§‹åŒ–è·¯å¾‘
        # å‡è¨­æ­¤è…³æœ¬åœ¨ scripts/utils/ ä¸‹ï¼Œå›é€€å…©å±¤è‡³æ ¹ç›®éŒ„
        root_path = Path(__file__).resolve().parents[2] 
        
        # è§£æå‘½ä»¤åˆ—åƒæ•¸
        parser = argparse.ArgumentParser(description="ASBL å°ˆæ¡ˆä»£ç¢¼åŒ¯å‡ºå·¥å…·")
        parser.add_argument('--out', type=str, help='è‡ªå®šç¾©è¼¸å‡ºè·¯å¾‘ (å¯é¸)')
        args = parser.parse_args()

        # 2. æº–å‚™è¼¸å‡ºè·¯å¾‘
        output_file_path = ProjectExporter._get_output_path(root_path, args.out)
        
        print(f"ğŸš€ [ASBL] é–‹å§‹åŸ·è¡Œå°ˆæ¡ˆåŒ¯å‡º (Full Stack Mode)...")
        print(f"ğŸ“‚ å°ˆæ¡ˆæ ¹ç›®éŒ„: {root_path}")
        print(f"ğŸ¯ ç›®æ¨™å‰¯æª”å: {len(ProjectExporter.TARGET_EXTENSIONS)} ç¨®é¡å‹")
        print(f"ğŸ“„ å¼·åˆ¶åŒ…å«æª”æ¡ˆ: {ProjectExporter.INCLUDE_FILES}")
        print(f"ğŸš« æ’é™¤ç›®éŒ„: {ProjectExporter.EXCLUDE_DIRS}")

        # 3. æƒæå°ˆæ¡ˆä¸¦æ§‹å»ºè³‡æ–™
        # collected_files å„²å­˜ (ç›¸å°è·¯å¾‘, çµ•å°è·¯å¾‘) çš„åˆ—è¡¨
        tree_str, collected_files = ProjectExporter._scan_and_build_tree(root_path)

        # 4. å¯«å…¥æª”æ¡ˆ
        ProjectExporter._write_export_file(output_file_path, tree_str, collected_files, root_path)

        print(f"âœ… åŒ¯å‡ºå®Œæˆï¼")
        print(f"ğŸ“Š ç¸½è¨ˆè™•ç†æª”æ¡ˆ: {len(collected_files)} å€‹")
        print(f"ğŸ’¾ æª”æ¡ˆå·²å„²å­˜è‡³: {output_file_path}")

    @staticmethod
    def _get_output_path(root_path: Path, custom_out: Optional[str]) -> Path:
        """
        ç”Ÿæˆå¸¶æœ‰æ™‚é–“æˆ³è¨˜çš„è¼¸å‡ºè·¯å¾‘
        """
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        if custom_out:
            p = Path(custom_out)
            if p.is_dir() or custom_out.endswith(('/', '\\')):
                return p / f"{ProjectExporter.OUTPUT_FILENAME_PREFIX}_{ts}.md"
            return p
        
        # é è¨­è·¯å¾‘
        docs_dir = root_path / ProjectExporter.OUTPUT_DIR
        docs_dir.mkdir(parents=True, exist_ok=True)
        return docs_dir / f"{ProjectExporter.OUTPUT_FILENAME_PREFIX}_{ts}.md"

    @staticmethod
    def _scan_and_build_tree(root: Path) -> Tuple[str, List[Tuple[str, Path]]]:
        """
        æƒæç›®éŒ„ï¼ŒåŒæ™‚ç”Ÿæˆæ¨¹ç‹€åœ–å­—ä¸²èˆ‡æ”¶é›†ç¬¦åˆæ¢ä»¶çš„æª”æ¡ˆ
        """
        collected_files: List[Tuple[str, Path]] = []
        
        def _recursive_build(current_path: Path, prefix: str = '') -> str:
            """å…§éƒ¨éè¿´å‡½æ•¸"""
            try:
                # å–å¾—ç•¶å‰ç›®éŒ„ä¸‹çš„æ‰€æœ‰é …ç›®ï¼Œä¸¦æ’åº (ç›®éŒ„å„ªå…ˆï¼Œç„¶å¾Œæ˜¯æª”æ¡ˆå)
                entries = sorted(
                    current_path.iterdir(),
                    key=lambda p: (p.is_file(), p.name.lower())
                )
            except PermissionError:
                return ""

            # éæ¿¾æ‰æ’é™¤çš„ç›®éŒ„å’Œæª”æ¡ˆ
            valid_entries = []
            for e in entries:
                if e.name in ProjectExporter.EXCLUDE_FILES:
                    continue
                if e.is_dir() and e.name in ProjectExporter.EXCLUDE_DIRS:
                    continue
                
                # [ä¿®æ”¹] æª”æ¡ˆéæ¿¾é‚è¼¯ï¼šæª¢æŸ¥å‰¯æª”å OR å¼·åˆ¶åŒ…å«çš„æª”å
                if e.is_file():
                    is_valid_extension = e.suffix in ProjectExporter.TARGET_EXTENSIONS
                    is_included_file = e.name in ProjectExporter.INCLUDE_FILES
                    
                    if not (is_valid_extension or is_included_file):
                        continue
                
                valid_entries.append(e)

            lines = []
            count = len(valid_entries)
            
            for i, entry in enumerate(valid_entries):
                is_last = (i == count - 1)
                connector = 'â””â”€ ' if is_last else 'â”œâ”€ '
                
                if entry.is_dir():
                    lines.append(f"{prefix}{connector}{entry.name}/")
                    ext_prefix = f"{prefix}{'   ' if is_last else 'â”‚  '}"
                    subtree = _recursive_build(entry, ext_prefix)
                    if subtree: # åªæœ‰ç•¶å­ç›®éŒ„æœ‰å…§å®¹æ™‚æ‰åŠ å…¥ï¼Œé¿å…ç©ºç›®éŒ„ä½”ç‰ˆé¢
                        lines.append(subtree)
                else:
                    lines.append(f"{prefix}{connector}{entry.name}")
                    # æ”¶é›†æª”æ¡ˆè³‡è¨Š
                    rel_path = entry.relative_to(root)
                    collected_files.append((str(rel_path), entry))
            
            return '\n'.join(lines)

        # é–‹å§‹éè¿´
        tree_body = _recursive_build(root)
        full_tree = f"{root.name}/\n{tree_body}"
        return full_tree, collected_files

    @staticmethod
    def _write_export_file(output_path: Path, tree_str: str, files: List[Tuple[str, Path]], root_path: Path) -> None:
        """
        å°‡æ¨¹ç‹€åœ–èˆ‡æª”æ¡ˆå…§å®¹å¯«å…¥ç›®æ¨™æ–‡ä»¶
        """
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                # 1. å¯«å…¥æª”é ­èˆ‡å°ˆæ¡ˆè³‡è¨Š
                f.write(f"# \n\n")
                f.write(f"# ASBL Basketball Manager - å°ˆæ¡ˆå…¨æ™¯å¿«ç…§\n\n")
                f.write(f"- **ç”Ÿæˆæ™‚é–“**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"- **å°ˆæ¡ˆè·¯å¾‘**: `{root_path}`\n")
                f.write(f"- **åŒ…å«æ ¼å¼**: `{', '.join(sorted(ProjectExporter.TARGET_EXTENSIONS))}`\n")
                f.write(f"- **å¼·åˆ¶åŒ…å«**: `{', '.join(sorted(ProjectExporter.INCLUDE_FILES))}`\n")
                f.write(f"- **æª”æ¡ˆç¸½æ•¸**: {len(files)}\n\n")
                
                # 2. å¯«å…¥å°ˆæ¡ˆçµæ§‹æ¨¹
                f.write("## 1. å°ˆæ¡ˆçµæ§‹æ¨¹ (Project Tree)\n\n")
                f.write("```text\n")
                f.write(tree_str)
                f.write("\n```\n\n")
                
                f.write("---\n\n")
                f.write("## 2. æª”æ¡ˆå…§å®¹è©³æƒ… (File Contents)\n\n")

                # 3. éæ­·ä¸¦å¯«å…¥æª”æ¡ˆå…§å®¹
                for rel_path, full_path in files:
                    f.write(f"### ğŸ“„ File: `{rel_path}`\n\n")
                    
                    # æ ¹æ“šå‰¯æª”åæ±ºå®š Markdown çš„ä»£ç¢¼å€å¡Šèªè¨€æ¨™ç±¤ (Syntax Highlighting)
                    ext = full_path.suffix.lower().replace('.', '')
                    
                    # æ˜ å°„è¡¨
                    lang_map = {
                        'py': 'python',
                        'js': 'javascript',
                        'jsx': 'javascript',
                        'ts': 'typescript',
                        'tsx': 'tsx',
                        'json': 'json',
                        'html': 'html',
                        'css': 'css',
                        'scss': 'scss',
                        'yaml': 'yaml',
                        'yml': 'yaml',
                        'env': 'bash',
                        'md': 'markdown',
                        'txt': 'text',
                        'sql': 'sql'
                    }
                    
                    code_block_lang = lang_map.get(ext, '')
                    
                    # ç‰¹æ®Šè™•ç† requirements.txt
                    if full_path.name == 'requirements.txt':
                        code_block_lang = 'text'

                    f.write(f"```{code_block_lang}\n")
                    
                    try:
                        with open(full_path, 'r', encoding='utf-8') as infile:
                            content = infile.read()
                            # è™•ç†æª”æ¡ˆçµå°¾æ²’æœ‰æ›è¡Œçš„æƒ…æ³ï¼Œé¿å… Markdown æ ¼å¼è·‘æ‰
                            if content and not content.endswith('\n'):
                                content += '\n'
                            f.write(content)
                    except UnicodeDecodeError:
                        f.write(f"# [ERROR] ç„¡æ³•ä»¥ UTF-8 æ ¼å¼è®€å–æ­¤æª”æ¡ˆ (å¯èƒ½æ˜¯äºŒé€²åˆ¶æ–‡ä»¶)\n")
                    except Exception as e:
                        f.write(f"# [ERROR] è®€å–æª”æ¡ˆæ™‚ç™¼ç”Ÿç•°å¸¸: {str(e)}\n")
                        
                    f.write("```\n\n")
                    f.write("---\n\n")
                    
        except Exception as e:
            print(f"âŒ å¯«å…¥è¼¸å‡ºæª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")

if __name__ == '__main__':
    ProjectExporter.run()
```

---

### ğŸ“„ File: `scripts\utils\tree.py`

```python
# æª”æ¡ˆï¼šscripts/utils/tree.py

# ç”¨æ³•ï¼š
# - ç›´æ¥åŸ·è¡Œï¼špython scripts/utils/tree.py
#   â†’ åŒæ­¥åœ¨çµ‚ç«¯é¡¯ç¤ºä¸¦å¯«å…¥ docs/PROJECT_TREE_YYYYMMDD_HHMMSS.md
# - è‡ªè¨‚è¼¸å‡ºç›®éŒ„ï¼špython scripts/utils/tree.py --out tests/big_data/output
#   â†’ ç”¢å‡º docs/PROJECT_TREE_YYYYMMDD_HHMMSS.md
# - è‡ªè¨‚è¼¸å‡ºæª”åï¼špython scripts/utils/tree.py --out docs/TREE.md
#   â†’ ç”¢å‡º docs/TREE_YYYYMMDD_HHMMSS.md
# - èª¿æ•´æ’é™¤ç›®éŒ„ï¼špython scripts/utils/tree.py --exclude .git .venv __pycache__ .parquet

import os
import platform
import shutil
from pathlib import Path
from typing import Iterable, Set
from datetime import datetime

def clear_terminal() -> None:
    try:
        cols, _ = shutil.get_terminal_size(fallback=(80, 24))
    except Exception:
        cols = 80
    system = platform.system().lower()
    if "windows" in system:
        os.system("cls")
    else:
        os.system("clear")
    print("=" * cols)

DEFAULT_EXCLUDE_DIRS = {
    '.git', '__pycache__', '.tokens', '.venv', '.idea', '.vscode'
}
DEFAULT_EXCLUDE_FILES = {'.DS_Store'}

def build_tree(root: Path, prefix: str = '', exclude_dirs: Set[str] = None, exclude_files: Set[str] = None) -> str:
    exclude_dirs = exclude_dirs or set()
    exclude_files = exclude_files or set()
    entries = [
        e for e in sorted(root.iterdir(), key=lambda p: (p.is_file(), p.name.lower()))
        if e.name not in exclude_files and e.name not in exclude_dirs
    ]
    lines = []
    for i, e in enumerate(entries):
        is_last = (i == len(entries) - 1)
        connector = 'â””â”€ ' if is_last else 'â”œâ”€ '
        if e.is_dir():
            lines.append(f"{prefix}{connector}{e.name}/")
            ext_prefix = f"{prefix}{'   ' if is_last else 'â”‚  '}"
            subtree = build_tree(e, ext_prefix, exclude_dirs, exclude_files)
            if subtree:
                lines.append(subtree)
        else:
            lines.append(f"{prefix}{connector}{e.name}")
    return '\n'.join(lines)

def render_project_tree(exclude_dirs: Set[str], exclude_files: Set[str]) -> str:
    root = Path(__file__).resolve().parents[2]  # å°ˆæ¡ˆæ ¹ç›®éŒ„
    return f"{root.name}/\n" + build_tree(root, '', exclude_dirs, exclude_files)

def write_docs(doc_path: Path, tree_str: str):
    doc_path.parent.mkdir(parents=True, exist_ok=True)
    with doc_path.open('w', encoding='utf-8') as f:
        f.write("# å°ˆæ¡ˆæª”æ¡ˆæ¨¹ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰\n\n")
        f.write("```\n")
        f.write(tree_str)
        f.write("\n```\n")
    print(f"[OK] Wrote tree to {doc_path}")

def make_timestamped_path(out_arg: str) -> Path:
    """
    å°‡ä½¿ç”¨è€…å‚³å…¥çš„ --out åƒæ•¸è½‰æ›ç‚ºå¸¶æ™‚é–“æˆ³è¨˜çš„è¼¸å‡ºè·¯å¾‘ã€‚
    è¦å‰‡ï¼š
    - è‹¥ out_arg æ˜¯ç›®éŒ„ï¼ˆæˆ–ä»¥æ–œç·šçµå°¾ï¼‰ï¼Œè¼¸å‡ºç‚º <dir>/PROJECT_TREE_YYYYMMDD_HHMMSS.md
    - è‹¥ out_arg æ˜¯æª”æ¡ˆï¼Œè¼¸å‡ºç‚º <dir>/<stem>_YYYYMMDD_HHMMSS<suffix>
    - è‹¥æœªå¸¶ --outï¼Œé è¨­ç‚º docs/PROJECT_TREE_YYYYMMDD_HHMMSS.md
    """
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    if not out_arg:
        return Path(f"docs/PROJECT_TREE_{ts}.md")

    p = Path(out_arg)
    # è‹¥åƒæ•¸æœ«å°¾å¸¶è·¯å¾‘åˆ†éš”ç¬¦æˆ–è©²ç›®éŒ„å­˜åœ¨ï¼Œè¦–ç‚ºç›®éŒ„
    if out_arg.endswith(("/", "\\")) or (p.exists() and p.is_dir()):
        return p.joinpath(f"PROJECT_TREE_{ts}.md")
    # è‹¥çˆ¶å±¤ä¸å­˜åœ¨ï¼Œä½† out_arg æ²’æœ‰å‰¯æª”ååˆçœ‹èµ·ä¾†åƒè³‡æ–™å¤¾åï¼Œä¹Ÿç•¶ä½œç›®éŒ„è™•ç†
    if not p.suffix and (out_arg.endswith(("/", "\\")) or not p.parent.suffix):
        return p.joinpath(f"PROJECT_TREE_{ts}.md")
    # ä¸€èˆ¬æª”æ¡ˆæƒ…å¢ƒï¼šæ’å…¥æ™‚é–“æˆ³è¨˜åˆ°æª”å
    stem = p.stem
    suffix = p.suffix or ".md"
    parent = p.parent if p.parent.as_posix() != "" else Path(".")
    return parent.joinpath(f"{stem}_{ts}{suffix}")

def main():
    import argparse
    parser = argparse.ArgumentParser(description="è¼¸å‡ºå°ˆæ¡ˆæª”æ¡ˆæ¨¹ï¼šåŒæ­¥é¡¯ç¤ºæ–¼çµ‚ç«¯ä¸¦å¯«å…¥æ–‡ä»¶ï¼ˆè‡ªå‹•å¸¶å…¥æ—¥æœŸæ™‚é–“æˆ³è¨˜ï¼‰")
    parser.add_argument('--out', type=str, default='', help='è¼¸å‡ºæª”æ¡ˆæˆ–ç›®éŒ„ï¼ˆç•™ç©ºå‰‡è¼¸å‡ºè‡³ docs/PROJECT_TREE_YYYYMMDD_HHMMSS.mdï¼‰')
    parser.add_argument('--exclude', nargs='*', default=[], help='é¡å¤–æ’é™¤çš„ç›®éŒ„/æª”åï¼ˆä»¥åç¨±æ¯”å°ï¼‰')
    args = parser.parse_args()

    # åˆä½µæ’é™¤æ¸…å–®ï¼ˆç›®éŒ„èˆ‡æª”æ¡ˆåç¨±åŒåæ™‚ä¹Ÿæœƒè¢«æ’é™¤ï¼‰
    exclude_dirs = set(DEFAULT_EXCLUDE_DIRS)
    exclude_files = set(DEFAULT_EXCLUDE_FILES)
    for name in args.exclude:
        exclude_dirs.add(name)
        exclude_files.add(name)

    tree_str = render_project_tree(exclude_dirs, exclude_files)

    # 1) é¡¯ç¤ºåˆ°çµ‚ç«¯
    print(tree_str)

    # 2) ç”¢ç”Ÿå¸¶æ™‚é–“æˆ³è¨˜çš„è¼¸å‡ºè·¯å¾‘ä¸¦è¼¸å‡ºæˆæ–‡ä»¶
    out_path = make_timestamped_path(args.out)
    write_docs(out_path, tree_str)

if __name__ == '__main__':
    clear_terminal()
    main()
```

---

### ğŸ“„ File: `scripts\__init__.py`

```python
# app/routes/__init__.py
```

---

### ğŸ“„ File: `scripts\init_db.py`

```python
# scripts/init_db.py
import sys
import os

# å°‡å°ˆæ¡ˆæ ¹ç›®éŒ„åŠ å…¥ Python è·¯å¾‘ï¼Œé€™æ¨£æ‰èƒ½ import app
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app import create_app, db
from app.models import User, Team, Player, Contract

app = create_app()

def init_database():
    with app.app_context():
        # 1. åˆªé™¤èˆŠè¡¨ (é–‹ç™¼åˆæœŸç”¨ï¼Œæ­£å¼ä¸Šç·šå¾Œè¦å°å¿ƒï¼)

        # 2. å»ºç«‹æ–°è¡¨
        db.create_all()
        print("âœ… è³‡æ–™è¡¨å»ºç«‹æˆåŠŸï¼")
        
        # 3. æª¢æŸ¥æ˜¯å¦æˆåŠŸ
        from sqlalchemy import inspect
        inspector = inspect(db.engine)
        tables = inspector.get_table_names()
        print(f"ğŸ“Š ç›®å‰è³‡æ–™åº«ä¸­çš„è³‡æ–™è¡¨: {tables}")

if __name__ == '__main__':
    print("ğŸš€ é–‹å§‹åˆå§‹åŒ–è³‡æ–™åº«...")
    init_database()
```

---

### ğŸ“„ File: `scripts\terminal.py`

```python
# è·¯å¾‘: scripts/terminal.py
# ç”¨é€”: æ¸…é™¤çµ‚ç«¯ç•«é¢ï¼ˆWindows/macOS/Linuxï¼‰

import os
import platform
import shutil


def clear_terminal() -> None:
    """
    æ¸…é™¤ç›®å‰çµ‚ç«¯æ©Ÿç•«é¢ï¼Œä¸¦åœ¨åº•éƒ¨ç•«ä¸€æ¢åˆ†éš”ç·šã€‚

    è¡Œç‚ºèªªæ˜
    - æœƒåµæ¸¬ä½œæ¥­ç³»çµ±ï¼š
      - Windows: ä½¿ç”¨ 'cls'
      - å…¶ä»–ï¼ˆmacOS/Linux/Unix é¡ï¼‰: ä½¿ç”¨ 'clear'
    - å˜—è©¦å–å¾—çµ‚ç«¯å¤§å°ä»¥æ±ºå®šåˆ†éš”ç·šé•·åº¦ï¼›è‹¥å¤±æ•—å‰‡ä½¿ç”¨ 80 æ¬„å¯¬ã€‚

    åƒæ•¸
    - ç„¡

    å›å‚³
    - None

    å¯èƒ½ä¾‹å¤–
    - ä¸ä¸»å‹•æ‹‹å‡ºä¾‹å¤–ï¼›è‹¥ç³»çµ±å‘¼å«å¤±æ•—ï¼Œä»æœƒç¹¼çºŒä¸¦ä»¥é è¨­å¯¬åº¦å°å‡ºåˆ†éš”ç·šã€‚
    """
    try:
        cols, _ = shutil.get_terminal_size(fallback=(80, 24))
    except Exception:
        cols = 80
    system = platform.system().lower()
    if "windows" in system:
        os.system("cls")
    else:
        os.system("clear")
    print("=" * cols)
```

---

### ğŸ“„ File: `tests\match_bigdata_test\run_core_bigdata_test.py`

```python
# tests/match_bigdata_test/run_core_bigdata_test.py
# -*- coding: utf-8 -*-
"""
ASBL Core Bigdata Test Runner (Forensic Version v2.5)

[æ›´æ–°é‡é»]
1. å•Ÿç”¨ faulthandlerï¼šæ•æ‰ C-level Segfault/Crashã€‚
2. Flush éš”é›¢æ©Ÿåˆ¶ï¼šå­˜æª”å¤±æ•—åƒ…ä¸Ÿæ£„è©² Batchï¼Œä¸ä¸­æ–·ä¸»è¿´åœˆã€‚
3. æ•æ‰ BaseExceptionï¼šé˜²æ­¢ SystemExit ç­‰åº•å±¤ä¾‹å¤–é€ƒè„«ã€‚
4. è©³ç´°éŒ¯èª¤æ—¥èªŒï¼šç¢ºä¿æ‰€æœ‰ Warning éƒ½æœ‰å®Œæ•´ Tracebackã€‚
"""

from __future__ import annotations

import os
import sys
import traceback
import faulthandler # [New] å•Ÿç”¨åº•å±¤éŒ¯èª¤æ•æ‰

# å•Ÿç”¨ Fault Handlerï¼Œè‹¥ç™¼ç”Ÿ Segfault æœƒå°‡ Traceback å°åˆ° stderr
faulthandler.enable()

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, PROJECT_ROOT)

import argparse
import datetime as _dt
import gc
import time
import subprocess
from itertools import combinations
from typing import Any, Dict, List

import pandas as pd
import psutil
import yaml
from tqdm import tqdm

# å¼•ç”¨æ—¢æœ‰å¼•æ“ç¨‹å¼ç¢¼
from app.services.match_engine.core import MatchEngine
from app.services.match_engine.structures import EngineTeam, EnginePlayer
from app.services.match_engine.utils.rng import rng


DEFAULT_PARQUET = "tests/match_bigdata_test/team/team_players.parquet"
DEFAULT_OUTPUT_ROOT = "tests/match_bigdata_test/output"
MAX_RETRIES_PER_GAME = 100


def now_id() -> str:
    return _dt.datetime.now().strftime("%Y%m%d_%H%M%S")


def make_snapshot(output_dir: str) -> str:
    snapshot_dir = os.path.join(output_dir, "snapshot")
    os.makedirs(snapshot_dir, exist_ok=True)

    tool_path = os.path.join(PROJECT_ROOT, "tools", "code_merger.py")
    if os.path.exists(tool_path):
        try:
            subprocess.run([sys.executable, tool_path], cwd=PROJECT_ROOT, check=True)
            ctx_src = os.path.join(PROJECT_ROOT, "project_context.txt")
            if os.path.exists(ctx_src):
                with open(ctx_src, "rb") as rf, open(os.path.join(snapshot_dir, "project_context.txt"), "wb") as wf:
                    wf.write(rf.read())
        except Exception as e:
            print(f"[Warning] Snapshot creation failed: {e}")

    cfg_src = os.path.join(PROJECT_ROOT, "config", "game_config.yaml")
    if os.path.exists(cfg_src):
        with open(cfg_src, "rb") as rf, open(os.path.join(snapshot_dir, "game_config.yaml"), "wb") as wf:
            wf.write(rf.read())

    return snapshot_dir


def load_config() -> Dict[str, Any]:
    cfg_path = os.path.join(PROJECT_ROOT, "config", "game_config.yaml")
    with open(cfg_path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


STAT_20 = [
    "ath_stamina", "ath_strength", "ath_speed", "ath_jump",
    "shot_touch", "shot_release", "talent_offiq", "talent_defiq", "talent_health", "talent_luck",
    "shot_accuracy", "shot_range", "def_rebound", "def_boxout", "def_contest", "def_disrupt",
    "off_move", "off_dribble", "off_pass", "off_handle",
]


def build_engine_player(row: Dict[str, Any]) -> EnginePlayer:
    attr_sum = int(sum(int(row.get(k, 0) or 0) for k in STAT_20))
    return EnginePlayer(
        id=str(row["player_id"]),
        name=str(row["name"]),
        position=str(row["position"]),
        role=str(row.get("role", row.get("contract_role", "Bench"))),
        grade=str(row.get("grade", "G")),
        height=float(row.get("height", 195)),
        age=int(row.get("age", 25)), # <--- è®€å– age

        ath_stamina=float(row.get("ath_stamina", 0)),
        ath_strength=float(row.get("ath_strength", 0)),
        ath_speed=float(row.get("ath_speed", 0)),
        ath_jump=float(row.get("ath_jump", 0)),
        talent_health=float(row.get("talent_health", 0)),
        shot_touch=float(row.get("shot_touch", 0)),
        shot_release=float(row.get("shot_release", 0)),
        talent_offiq=float(row.get("talent_offiq", 0)),
        talent_defiq=float(row.get("talent_defiq", 0)),
        talent_luck=float(row.get("talent_luck", 0)),

        shot_accuracy=float(row.get("shot_accuracy", 0)),
        shot_range=float(row.get("shot_range", 0)),
        def_rebound=float(row.get("def_rebound", 0)),
        def_boxout=float(row.get("def_boxout", 0)),
        def_contest=float(row.get("def_contest", 0)),
        def_disrupt=float(row.get("def_disrupt", 0)),
        off_move=float(row.get("off_move", 0)),
        off_dribble=float(row.get("off_dribble", 0)),
        off_pass=float(row.get("off_pass", 0)),
        off_handle=float(row.get("off_handle", 0)),

        attr_sum=attr_sum,
    )


def load_teams(parquet_rel: str) -> Dict[str, EngineTeam]:
    df = pd.read_parquet(os.path.join(PROJECT_ROOT, parquet_rel))
    if "team_id" not in df.columns:
        raise ValueError("team_players.parquet ç¼ºå°‘ team_id")

    teams: Dict[str, EngineTeam] = {}
    for tid, g in df.groupby("team_id"):
        roster = [build_engine_player(rec) for rec in g.to_dict(orient="records")]
        teams[str(tid)] = EngineTeam(id=str(tid), name=str(tid), roster=roster)

    if len(teams) != 4:
        raise ValueError(f"é æœŸ 4 éšŠï¼Œå¯¦éš› {len(teams)}ï¼š{list(teams.keys())}")

    for tid, t in teams.items():
        if len(t.roster) != 15:
            raise ValueError(f"{tid} roster ä¸æ˜¯ 15 äººï¼š{len(t.roster)}")

    return teams


def clone_team(src: EngineTeam) -> EngineTeam:
    roster = []
    for p in src.roster:
        row = {
            "player_id": p.id,
            "name": p.name,
            "position": p.position,
            "role": p.role,
            "grade": p.grade,
            "height": p.height,
        }
        for k in STAT_20:
            row[k] = getattr(p, k)
        roster.append(build_engine_player(row))
    return EngineTeam(id=src.id, name=src.name, roster=roster)


def write_parquet(df: pd.DataFrame, path: str):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    df.to_parquet(path, index=False)


def concat_parquets(files: List[str], out_path: str):
    if not files:
        raise ValueError(f"æ²’æœ‰æª”æ¡ˆå¯åˆä½µï¼š{out_path}")
    
    dfs = []
    desc = f"Merging {os.path.basename(out_path)}"
    for fp in tqdm(files, desc=desc, leave=False, unit="file"):
        dfs.append(pd.read_parquet(fp))
    
    pd.concat(dfs, ignore_index=True).to_parquet(out_path, index=False)


def extract_box_rows(game_id: str, team: EngineTeam, opp_id: str) -> List[Dict[str, Any]]:
    rows = []
    for p in team.roster:
        rows.append({
            "game_id": game_id,
            "team_id": team.id,
            "opponent_team_id": opp_id,
            "player_id": p.id,
            "name": p.name,
            "grade": p.grade,
            "role": p.role,
            "position": p.position,
            "height": float(p.height),
            "attr_sum": int(p.attr_sum),

            "stat_pts": int(p.stat_pts),
            "stat_reb": int(p.stat_reb),
            "stat_ast": int(p.stat_ast),
            "stat_stl": int(p.stat_stl),
            "stat_blk": int(p.stat_blk),
            "stat_tov": int(p.stat_tov),
            "fouls": int(p.fouls),
            "stat_plus_minus": int(p.stat_plus_minus),

            "stat_fgm": int(p.stat_fgm),
            "stat_fga": int(p.stat_fga),
            "stat_3pm": int(p.stat_3pm),
            "stat_3pa": int(p.stat_3pa),
            "stat_ftm": int(p.stat_ftm),
            "stat_fta": int(p.stat_fta),

            "stat_orb": int(p.stat_orb),
            "stat_drb": int(p.stat_drb),

            "seconds_played": float(p.seconds_played),
            "current_stamina": float(p.current_stamina),
            "is_fouled_out": bool(p.is_fouled_out),

            "stat_fb_made": int(p.stat_fb_made),
            "stat_fb_attempt": int(p.stat_fb_attempt),
        })
    return rows


def extract_possession_rows(game_id: str, team: EngineTeam, opp_id: str) -> List[Dict[str, Any]]:
    rows = []
    for i, sec in enumerate(team.stat_possession_history):
        rows.append({
            "game_id": game_id,
            "team_id": team.id,
            "opponent_team_id": opp_id,
            "possession_index": int(i),
            "seconds": float(sec),
        })
    return rows


def calc_orating(points: int, poss: int) -> float:
    return (points / poss * 100.0) if poss > 0 else 0.0


def _team_strength(team: EngineTeam) -> int:
    return int(sum(int(p.attr_sum) for p in team.roster))


def _fmt_pct(x: float) -> str:
    return f"{x*100:.2f}%"

def _roster_stats_table(team: EngineTeam, box_df: pd.DataFrame) -> str:
    team_box = box_df[box_df['team_id'] == team.id]
    stats_agg = team_box.groupby('player_id').agg(
        G=('game_id', 'count'),
        PTS=('stat_pts', 'mean'),
        REB=('stat_reb', 'mean'),
        AST=('stat_ast', 'mean'),
        STL=('stat_stl', 'mean'),
        BLK=('stat_blk', 'mean'),
        TOV=('stat_tov', 'mean'),
        PF=('fouls', 'mean'),
        PM=('stat_plus_minus', 'mean'),
        FGM=('stat_fgm', 'mean'),
        FGA=('stat_fga', 'mean'),
        M3PM=('stat_3pm', 'mean'),
        M3PA=('stat_3pa', 'mean'),
        FTM=('stat_ftm', 'mean'),
        FTA=('stat_fta', 'mean'),
        ORB=('stat_orb', 'mean'),
        DRB=('stat_drb', 'mean'),
        FB_M=('stat_fb_made', 'mean'),
        FB_A=('stat_fb_attempt', 'mean'),
        REM_ST=('current_stamina', 'mean'),
        SEC=('seconds_played', 'mean')
    ).reset_index()

    stats_map = stats_agg.set_index('player_id').to_dict('index')

    header = (
        "| åç¨± | ä½ç½® | ç­‰ç´š | æ™‚é–“ | å¾—åˆ† | ç±ƒæ¿ | åŠ©æ”» | æŠ„æˆª | é˜»æ”» | å¤±èª¤ | çŠ¯è¦ | +/- | "
        "FG | 3PT | FT | OR/DR | å¿«æ”»(M/A) | é«”åŠ› | "
        "é«”èƒ½ | åŠ›é‡ | é€Ÿåº¦ | å½ˆè·³ | å¥åº· | æ‰‹æ„Ÿ | å‡ºæ‰‹ | æ”»æ™º | å®ˆæ™º | é‹æ°£ | "
        "æŠ•ç±ƒ | å°„ç¨‹ | å‚³çƒ | é‹çƒ | æ§çƒ | è·‘ä½ | ç±ƒæ¿ | å¡ä½ | å¹²æ“¾ | æŠ„æˆª |\n"
    )
    sep = "|---|---|---|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|\n"
    
    lines = [header, sep]
    
    for p in team.roster:
        s = stats_map.get(p.id, {})
        mpg = s.get('SEC', 0) / 60.0
        
        fg_str = f"{s.get('FGM',0):.1f}/{s.get('FGA',0):.1f}"
        tp_str = f"{s.get('M3PM',0):.1f}/{s.get('M3PA',0):.1f}"
        ft_str = f"{s.get('FTM',0):.1f}/{s.get('FTA',0):.1f}"
        reb_split = f"{s.get('ORB',0):.1f}/{s.get('DRB',0):.1f}"
        fb_str = f"{s.get('FB_M',0):.1f}/{s.get('FB_A',0):.1f}"
        
        line = (
            f"| {p.name} | {p.position} | {p.grade} | {mpg:.1f} | "
            f"**{s.get('PTS',0):.1f}** | {s.get('REB',0):.1f} | {s.get('AST',0):.1f} | {s.get('STL',0):.1f} | "
            f"{s.get('BLK',0):.1f} | {s.get('TOV',0):.1f} | {s.get('PF',0):.1f} | {s.get('PM',0):+.1f} | "
            f"{fg_str} | {tp_str} | {ft_str} | {reb_split} | {fb_str} | {s.get('REM_ST',0):.1f} | "
            f"{int(p.ath_stamina)} | {int(p.ath_strength)} | {int(p.ath_speed)} | {int(p.ath_jump)} | {int(p.talent_health)} | "
            f"{int(p.shot_touch)} | {int(p.shot_release)} | {int(p.talent_offiq)} | {int(p.talent_defiq)} | {int(p.talent_luck)} | "
            f"{int(p.shot_accuracy)} | {int(p.shot_range)} | {int(p.off_pass)} | {int(p.off_dribble)} | {int(p.off_handle)} | {int(p.off_move)} | "
            f"{int(p.def_rebound)} | {int(p.def_boxout)} | {int(p.def_contest)} | {int(p.def_disrupt)} |\n"
        )
        lines.append(line)
        
    return "".join(lines)

def _slice_bin(sec: float) -> int:
    if sec >= 24.0:
        return 23
    if sec < 0:
        return 0
    return int(sec)

def build_report(
    report_path: str,
    run_id: str,
    config: Dict[str, Any],
    teams_src: Dict[str, EngineTeam],
    matches_df: pd.DataFrame,
    team_df: pd.DataFrame,
    box_df: pd.DataFrame,
    poss_df: pd.DataFrame,
):
    now_str = _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    pbar = tqdm(total=13, desc="Analyzing & Reporting", unit="step")

    # 1) æ¦‚æ³
    total_games = int(matches_df.shape[0])
    ot_games = int(matches_df["is_ot"].sum())
    q_dist = matches_df["total_quarters"].value_counts().sort_index().to_dict()
    pbar.update(1)

    # 1.2) Config Snapshot
    me = config.get("match_engine", {})
    gen = me.get("general", {})
    sub = gen.get("substitution", {})
    shoot = me.get("shooting", {}).get("params", {})
    match_engine_yaml = yaml.safe_dump(me, allow_unicode=True, sort_keys=False)
    pbar.update(1)

    # 2) Roster Stats Preparation
    team_ids = sorted(list(teams_src.keys()))
    strengths = {tid: _team_strength(teams_src[tid]) for tid in team_ids}
    pbar.update(1)

    # 3) Win Rate & Diff
    h2h_stats = {} 
    matches_df['diff_abs'] = (matches_df['team_a_score'] - matches_df['team_b_score']).abs()
    
    win_counts = {tid: 0 for tid in team_ids}
    game_counts = {tid: 0 for tid in team_ids}
    
    for _, r in matches_df.iterrows():
        a, b = r['team_a_id'], r['team_b_id']
        sa, sb = r['team_a_score'], r['team_b_score']
        
        game_counts[a] += 1
        game_counts[b] += 1
        
        key_a = (a, b)
        key_b = (b, a)
        if key_a not in h2h_stats: h2h_stats[key_a] = [0, 0]
        if key_b not in h2h_stats: h2h_stats[key_b] = [0, 0]
        
        h2h_stats[key_a][1] += 1
        h2h_stats[key_b][1] += 1
        
        if sa > sb:
            win_counts[a] += 1
            h2h_stats[key_a][0] += 1
        elif sb > sa:
            win_counts[b] += 1
            h2h_stats[key_b][0] += 1
            
    bins = [0, 5, 10, 15, 20, 30, 40, 50, 999]
    labels = ["1-5", "6-10", "11-15", "16-20", "21-30", "31-40", "41-50", ">50"]
    diff_cats = pd.cut(matches_df['diff_abs'], bins=bins, labels=labels, right=False)
    diff_dist = diff_cats.value_counts().sort_index()
    
    diff_mean = matches_df['diff_abs'].mean()
    diff_std = matches_df['diff_abs'].std()
    pbar.update(1)

    # 4) Team Stats Aggregation
    t_agg = team_df.groupby("team_id").agg(
        G=("game_id", "count"),
        PTS=("points", "mean"),
        Opp_PTS=("opp_points", "mean"),
        Pace=("pace", "mean"),
        Poss=("possessions", "mean"),
        SecPerPoss=("sec_per_poss", "mean"),
        ORtg=("ortg", "mean"),
        DRtg=("drtg", "mean"),
        Net=("net", "mean"),
        FB_Att=("fb_attempt", "mean"),
        FB_Made=("fb_made", "mean"),
        Vio8=("violation_8s", "mean"),
        Vio24=("violation_24s", "mean"),
    ).reset_index()
    t_agg["FB%"] = t_agg.apply(lambda r: (r["FB_Made"] / r["FB_Att"]) if r["FB_Att"] > 0 else 0.0, axis=1)
    t_agg["FB_Freq"] = t_agg.apply(lambda r: (r["FB_Att"] / r["Poss"] * 100.0) if r["Poss"] > 0 else 0.0, axis=1)
    pbar.update(1)

    # 5) Player Correlation
    box_play = box_df.copy()
    box_play["mp"] = box_play["seconds_played"].astype(float) / 60.0
    box_play = box_play[box_play["mp"] > 5.0].copy()

    def summarize_skill(df: pd.DataFrame) -> pd.DataFrame:
        out = df.groupby("grade").agg(
            attr_sum=("attr_sum", "mean"),
            MPG=("mp", "mean"),
            PPG=("stat_pts", "mean"),
            RPG=("stat_reb", "mean"),
            APG=("stat_ast", "mean"),
            SPG=("stat_stl", "mean"),
            BPG=("stat_blk", "mean"),
            TO=("stat_tov", "mean"),
            PM=("stat_plus_minus", "mean"),
            FGM=("stat_fgm", "sum"),
            FGA=("stat_fga", "sum"),
            N=("player_id", "count"),
        ).reset_index()
        out["FG%"] = out.apply(lambda r: (r["FGM"] / r["FGA"]) if r["FGA"] > 0 else 0.0, axis=1)
        out["Pts/36"] = out.apply(lambda r: (r["PPG"] / r["MPG"] * 36.0) if r["MPG"] > 0 else 0.0, axis=1)
        out["Eff/36"] = out.apply(
            lambda r: ((r["PPG"] + r["RPG"] + r["APG"] + r["SPG"] + r["BPG"] - r["TO"]) / r["MPG"] * 36.0) if r["MPG"] > 0 else 0.0,
            axis=1
        )
        return out
    pbar.update(1)

    # 6) Stamina
    def stamina_bucket(s: float) -> str:
        if s >= 80: return "æ­£å¸¸ (80-100)"
        if s >= 60: return "ç¨å¾®ç–²ç´¯ (60-79)"
        if s >= 40: return "æœ‰é»ç–²ç´¯ (40-59)"
        if s >= 20: return "ç–²ç´¯ (20-39)"
        return "éå¸¸ç–²ç´¯ (1-19)"

    box_df["st_bucket"] = box_df["current_stamina"].astype(float).apply(stamina_bucket)
    pbar.update(1)

    # 7) Fouls
    avg_pf = float(box_df["fouls"].mean())
    max_pf = int(box_df["fouls"].max())
    fouled_out_cnt = int(box_df["is_fouled_out"].sum())
    pf_team_game = box_df.groupby(["game_id", "team_id"])["fouls"].sum().reset_index()
    pf_team_avg = pf_team_game.groupby("team_id")["fouls"].mean().to_dict()
    pf_dist = {}
    for tid in team_ids:
        subdf = box_df[box_df["team_id"] == tid]
        pf_dist[tid] = subdf["fouls"].value_counts().sort_index().to_dict()
    pbar.update(1)

    # 8) Possession Time & Violations
    slice_counts = {tid: [0] * 24 for tid in team_ids}
    poss_stats = {} 
    
    for tid in team_ids:
        t_poss = poss_df[poss_df['team_id'] == tid]['seconds']
        poss_stats[tid] = {
            'mean': t_poss.mean(),
            'std': t_poss.std(),
            'count': t_poss.count()
        }
        
    for _, r in poss_df.iterrows():
        tid = r["team_id"]
        sec = float(r["seconds"])
        slice_counts[tid][_slice_bin(sec)] += 1

    v8 = team_df.groupby("team_id")["violation_8s"].sum().to_dict()
    v24 = team_df.groupby("team_id")["violation_24s"].sum().to_dict()
    pbar.update(1)

    # 10) Speed vs Pace Correlation (Weighted by Minutes)
    team_speed_data = []
    for tid in team_ids:
        # Get static speed from roster
        t_roster = teams_src[tid].roster
        spd_map = {p.id: p.ath_speed for p in t_roster}
        
        # Get minutes played for this team
        t_box = box_df[box_df['team_id'] == tid]
        p_minutes = t_box.groupby('player_id')['seconds_played'].sum()
        
        total_sec = 0
        weighted_sum = 0
        for pid, sec in p_minutes.items():
            s = spd_map.get(pid, 0)
            weighted_sum += s * sec
            total_sec += sec
            
        avg_w_speed = weighted_sum / total_sec if total_sec > 0 else 0
        
        team_row = t_agg[t_agg['team_id'] == tid].iloc[0]
        team_speed_data.append({
            'team_id': tid,
            'w_speed': avg_w_speed,
            'pace': team_row['Pace'],
            'poss': team_row['Poss']
        })
    speed_df = pd.DataFrame(team_speed_data)
    pbar.update(1)

    # 11) High Grade Player Ranking (SSR/SS/S)
    high_grade_box = box_df[box_df['grade'].isin(['SSR', 'SS', 'S'])].copy()
    high_grade_box["mp"] = high_grade_box["seconds_played"].astype(float) / 60.0
    
    hg_stats = high_grade_box.groupby(['player_id', 'name', 'team_id', 'position', 'grade']).agg(
        MPG=('mp', 'mean'),
        PPG=('stat_pts', 'mean'),
        RPG=('stat_reb', 'mean'),
        APG=('stat_ast', 'mean'),
        SPG=('stat_stl', 'mean'),
        BPG=('stat_blk', 'mean'),
        TO=('stat_tov', 'mean'),
        FGM=('stat_fgm', 'sum'),
        FGA=('stat_fga', 'sum'),
    ).reset_index()
    
    hg_stats["FG%"] = hg_stats.apply(lambda r: (r["FGM"] / r["FGA"]) if r["FGA"] > 0 else 0.0, axis=1)
    # Sort by PPG descending
    hg_stats = hg_stats.sort_values('PPG', ascending=False).head(20)
    pbar.update(1)

    # 12) Violation Distribution
    vio_dist_data = {}
    for tid in team_ids:
        tdf = team_df[team_df['team_id'] == tid]
        v8_counts = tdf['violation_8s'].value_counts().sort_index().to_dict()
        v24_counts = tdf['violation_24s'].value_counts().sort_index().to_dict()
        vio_dist_data[tid] = {'v8': v8_counts, 'v24': v24_counts}
    pbar.update(1)

    # ---- WRITE REPORT ----
    with open(report_path, "w", encoding="utf-8") as f:
        f.write("# ASBL æ¨¡æ“¬å¹³è¡¡æ€§åˆ†æå ±å‘Š (v2.4)\n")
        f.write(f"**åˆ†ææ™‚é–“:** {now_str}\n")
        f.write(f"**è³‡æ–™ä¾†æº:** `{run_id}`\n\n")

        f.write("## 1. æ¨¡æ“¬æ¦‚æ³\n")
        f.write(f"- **å¯¦éš›åˆ†æå ´æ•¸:** {total_games}\n")
        f.write(f"- **ç¸½çƒå“¡äººæ¬¡ (boxscores rows):** {int(box_df.shape[0])}\n")
        f.write(f"- **OT å ´æ•¸:** {ot_games} ({_fmt_pct(ot_games / max(1, total_games))})\n")
        dist_str = ", ".join([f"{k}ç¯€={v}" for k, v in q_dist.items()])
        f.write(f"- **ç¯€æ•¸åˆ†ä½ˆ:** {dist_str}\n\n")

        f.write("### 1.2 åƒæ•¸è¨­å®š (Config Snapshot)\n")
        f.write("| åƒæ•¸é¡åˆ¥ | åƒæ•¸åç¨± | è¨­å®šå€¼ |\n|---|---|---|\n")
        f.write(f"| **å…¨åŸŸè¨­å®š** | æ¯ç¯€é•·åº¦ | `{gen.get('quarter_length')}` |\n")
        f.write(f"| | çŠ¯æ»¿æ¬¡æ•¸ | `{sub.get('foul_limit')}` |\n")
        f.write(f"| **é«”åŠ›ç³»çµ±** | æ¶ˆè€—ä¿‚æ•¸ | `{gen.get('stamina_drain_coeff')}` |\n")
        f.write(f"| | è¡°é€€é–¾å€¼ | `{gen.get('stamina_nerf_threshold')}` |\n")
        f.write(f"| **æŠ•ç±ƒè¨­å®š** | å…©åˆ†åŸºæ•¸ | `{shoot.get('base_rate_2pt')}` |\n")
        f.write(f"| | ä¸‰åˆ†åŸºæ•¸ | `{shoot.get('base_rate_3pt')}` |\n\n")

        f.write("#### match_engine å…¨è¨­å®š (YAML)\n")
        f.write("```yaml\n")
        f.write(match_engine_yaml)
        f.write("```\n\n")

        f.write("## 2. æ¸¬è©¦çƒéšŠé™£å®¹ (å«å ´å‡æ•¸æ“š)\n")
        f.write("> è¨»ï¼šæ•¸æ“šç‚ºæœ¬æ‰¹æ¬¡æ¨¡æ“¬ä¹‹å¹³å‡å€¼\n")
        for tid in team_ids:
            t = teams_src[tid]
            f.write(f"### çƒéšŠä»£ç¢¼: `{tid}` (æˆ°åŠ›ç¸½å’Œ: {strengths[tid]:,})\n")
            f.write(_roster_stats_table(t, box_df))
            f.write("\n")

        f.write("## 3. çƒéšŠå‹ç‡èˆ‡åˆ†å·®åˆ†ä½ˆ\n")
        f.write("### 3.1 ç¸½å‹ç‡\n")
        f.write("| çƒéšŠä»£ç¢¼ | å‹å ´ | ç¸½å ´æ•¸ | å‹ç‡ |\n|---|---:|---:|---:|\n")
        for tid in team_ids:
            g = int(game_counts[tid])
            w = int(win_counts[tid])
            wr = (w / g) if g > 0 else 0.0
            f.write(f"| `{tid}` | {w} | {g} | **{_fmt_pct(wr)}** |\n")
        f.write("\n")

        f.write("### 3.2 å°æˆ°çµ„åˆå‹ç‡\n")
        f.write("| å°æˆ°çµ„åˆ (A vs B) | A å‹å ´ | B å‹å ´ | ç¸½å ´æ•¸ | A å‹ç‡ |\n|---|---:|---:|---:|---:|\n")
        for (a, b), stats in sorted(h2h_stats.items()):
            if a < b: # åªé¡¯ç¤ºå–®å‘çµ„åˆé¿å…é‡è¤‡
                w_a = stats[0]
                total = stats[1]
                w_b = total - w_a
                wr_a = w_a / total if total > 0 else 0
                f.write(f"| {a} vs {b} | {w_a} | {w_b} | {total} | **{_fmt_pct(wr_a)}** |\n")
        f.write("\n")

        f.write("### 3.3 åˆ†å·®åˆ†ä½ˆ (å‹åˆ†å·®çµ•å°å€¼)\n")
        f.write("| åˆ†å·®å€é–“ | å ´æ•¸ | æ¯”ä¾‹ |\n|---|---:|---:|\n")
        for lab, cnt in diff_dist.items():
            f.write(f"| {lab} | {int(cnt)} | {_fmt_pct(int(cnt)/max(1,total_games))} |\n")
        f.write("\n")

        f.write("### 3.4 å‹åˆ†å·®å¸¸æ…‹åˆ†ä½ˆåˆ†æ\n")
        f.write(f"- **å¹³å‡åˆ†å·® (Mean):** {diff_mean:.2f} åˆ†\n")
        f.write(f"- **æ¨™æº–å·® (Std Dev):** {diff_std:.2f}\n")
        f.write(f"- **68% å€é–“ (Mean Â± 1Ïƒ):** {max(0, diff_mean-diff_std):.1f} ~ {diff_mean+diff_std:.1f} åˆ†\n\n")

        f.write("## 4. ç¯€å¥ã€å›åˆæ•¸ã€å¿«æ”»èˆ‡æ•ˆç‡ (åœ˜éšŠå ´å‡)\n")
        f.write("### 4.1 ç¶œåˆæ•¸æ“šè¡¨\n")
        f.write("| çƒéšŠ | å ´æ•¸ | å¾—åˆ† | å¤±åˆ† | ç¯€å¥(Pace) | å›åˆæ•¸ | æ¯å›åˆç§’æ•¸ | é€²æ”»æ•ˆç‡(ORtg) | é˜²å®ˆæ•ˆç‡(DRtg) | æ·¨æ•ˆç‡(Net) | å¿«æ”»å‡ºæ‰‹ | å¿«æ”»å‘½ä¸­ç‡ | å¿«æ”»é »ç‡(%) | 8ç§’é•ä¾‹ | 24ç§’é•ä¾‹ |\n")
        f.write("|---|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|\n")
        for _, r in t_agg.sort_values("team_id").iterrows():
            f.write(
                f"| `{r['team_id']}` | {int(r['G'])} | {r['PTS']:.1f} | {r['Opp_PTS']:.1f} | {r['Pace']:.2f} | {r['Poss']:.2f} | "
                f"{r['SecPerPoss']:.2f} | {r['ORtg']:.1f} | {r['DRtg']:.1f} | {r['Net']:+.1f} | {r['FB_Att']:.2f} | "
                f"{_fmt_pct(float(r['FB%']))} | {r['FB_Freq']:.2f}% | {r['Vio8']:.2f} | {r['Vio24']:.2f} |\n"
            )
        f.write("\n")

        f.write("## 5. èƒ½åŠ›èˆ‡è¡¨ç¾ç›¸é—œæ€§ (åˆ†ç´šåˆ†æ)\n")
        f.write("> æ’åºï¼šSSR -> G\n")
        grade_order = {"SSR": 0, "SS": 1, "S": 2, "A": 3, "B": 4, "C": 5, "G": 6}
        
        for tid in team_ids:
            f.write(f"### çƒéšŠ: `{tid}`\n")
            subdf = box_play[box_play["team_id"] == tid]
            if subdf.empty:
                f.write("> ç„¡ç¬¦åˆç¯©é¸æ¢ä»¶çš„æ¨£æœ¬\n\n")
                continue
            summ = summarize_skill(subdf)
            # Sort
            summ['sort_key'] = summ['grade'].map(lambda x: grade_order.get(x, 99))
            summ = summ.sort_values('sort_key')
            
            f.write("| ç­‰ç´š | å¹³å‡å±¬æ€§ | ä¸Šå ´(åˆ†) | å¾—åˆ† | ç±ƒæ¿ | åŠ©æ”» | æŠ„æˆª | é˜»æ”» | å¤±èª¤ | +/- | å‘½ä¸­ç‡ | Pts/36 | æ•ˆç‡/36 | æ¨£æœ¬æ•¸ |\n")
            f.write("|---|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|\n")
            for _, r in summ.iterrows():
                f.write(
                    f"| **{r['grade']}** | {float(r['attr_sum']):.1f} | {float(r['MPG']):.1f} | {float(r['PPG']):.1f} | "
                    f"{float(r['RPG']):.1f} | {float(r['APG']):.1f} | {float(r['SPG']):.1f} | {float(r['BPG']):.1f} | "
                    f"{float(r['TO']):.1f} | {float(r['PM']):+.1f} | {_fmt_pct(float(r['FG%']))} | {float(r['Pts/36']):.1f} | "
                    f"{float(r['Eff/36']):.1f} | {int(r['N'])} |\n"
                )
            f.write("\n")

        f.write("## 6. é«”åŠ›ç³»çµ±åˆ†æ\n")
        f.write("### 6.1 è³½å¾Œé«”åŠ›åˆ†ä½ˆ (å‘½ä¸­ç‡å½±éŸ¿)\n")
        f.write("| é«”åŠ›ç‹€æ…‹ | å‘½ä¸­ç‡ (FG%) | å‡ºæ‰‹æ¨£æœ¬æ•¸ (FGA) |\n|---|---:|---:|\n")
        
        g_stam = box_df.groupby("st_bucket").agg(
            FGM=("stat_fgm", "sum"),
            FGA=("stat_fga", "sum"),
        ).reset_index()
        g_stam["FG%"] = g_stam.apply(lambda r: (r["FGM"] / r["FGA"]) if r["FGA"] > 0 else 0.0, axis=1)
        
        order = ["æ­£å¸¸ (80-100)", "ç¨å¾®ç–²ç´¯ (60-79)", "æœ‰é»ç–²ç´¯ (40-59)", "ç–²ç´¯ (20-39)", "éå¸¸ç–²ç´¯ (1-19)"]
        # Ensure ordering
        g_stam["st_bucket"] = pd.Categorical(g_stam["st_bucket"], categories=order, ordered=True)
        g_stam = g_stam.sort_values("st_bucket")
        
        for _, r in g_stam.iterrows():
            f.write(f"| {r['st_bucket']} | **{_fmt_pct(float(r['FG%']))}** | {int(r['FGA'])} |\n")
        f.write("\n")

        f.write("## 7. çŠ¯è¦ç³»çµ±\n")
        f.write(f"- **å¹³å‡å–®å ´å€‹äººçŠ¯è¦:** {avg_pf:.2f}\n")
        f.write(f"- **å–®äººå–®å ´æœ€å¤§çŠ¯è¦:** {max_pf}\n")
        f.write(f"- **çŠ¯æ»¿é›¢å ´äººæ¬¡:** {fouled_out_cnt}\n\n")

        f.write("### 7.1 å„éšŠå¹³å‡æ¯å ´çŠ¯è¦æ¬¡æ•¸\n")
        for tid in team_ids:
            f.write(f"- **{tid}:** {float(pf_team_avg.get(tid, 0.0)):.2f} æ¬¡/å ´\n")
        f.write("\n")

        f.write("### 7.2 çŠ¯è¦æ¬¡æ•¸åˆ†ä½ˆ (Debug)\n")
        for tid in team_ids:
            f.write(f"#### çƒéšŠ: `{tid}`\n")
            f.write("| çŠ¯è¦æ¬¡æ•¸ | äººæ¬¡ | ç•°å¸¸æ¨™è¨˜ |\n|---:|---:|---|\n")
            dist = pf_dist.get(tid, {})
            for k in sorted(dist.keys()):
                f.write(f"| {int(k)} | {int(dist[k])} |  |\n")
            f.write("\n")

        f.write("## 8. æ¯éšŠæ¯å›åˆèŠ±è²»æ™‚é–“åˆ‡ç‰‡åˆ†å¸ƒèˆ‡é•ä¾‹\n")
        for tid in team_ids:
            stats = poss_stats[tid]
            total_poss = stats['count']
            
            f.write(f"### çƒéšŠ: `{tid}`\n")
            f.write(f"- **8ç§’é•ä¾‹ (ç¸½è¨ˆ):** {int(v8.get(tid, 0))}\n")
            f.write(f"- **24ç§’é•ä¾‹ (ç¸½è¨ˆ):** {int(v24.get(tid, 0))}\n")
            f.write(f"- **å¹³å‡æ™‚é–“:** {stats['mean']:.2f} ç§’ (Ïƒ={stats['std']:.2f})\n\n")
            
            f.write("| å€é–“ | æ¬¡æ•¸ | ä½”æ¯” |\n|---|---:|---:|\n")
            for i in range(24):
                cnt = int(slice_counts[tid][i])
                pct = cnt / total_poss if total_poss > 0 else 0
                f.write(f"| {i}~{i+1} ç§’ | {cnt} | {_fmt_pct(pct)} |\n")
            f.write("\n")

        f.write("## 9. å¿«æ”»æ•¸æ“šè©³æƒ… (Team-Level)\n")
        f.write("| çƒéšŠ | å ´å‡å¿«æ”»å‡ºæ‰‹ | å ´å‡å¿«æ”»å¾—åˆ† | å¿«æ”»å‘½ä¸­ç‡ | å¿«æ”»å¾—åˆ†ä½”æ¯” |\n|---|---:|---:|---:|---:|\n")
        for _, r in t_agg.sort_values("team_id").iterrows():
            fb_pts = r['FB_Made'] * 2 # å‡è¨­å¿«æ”»éƒ½æ˜¯2åˆ†
            pts_pct = (fb_pts / r['PTS']) if r['PTS'] > 0 else 0
            f.write(
                f"| `{r['team_id']}` | {r['FB_Att']:.2f} | {fb_pts:.1f} | "
                f"{_fmt_pct(float(r['FB%']))} | {_fmt_pct(pts_pct)} |\n"
            )
        f.write("\n")

        f.write("## 10. é€Ÿåº¦å°çƒéšŠå›åˆæ•¸ (Pace) çš„å½±éŸ¿\n")
        f.write("> è¨»ï¼šå¹³å‡é€Ÿåº¦æ”¹æ¡ã€Œä¸Šå ´æ™‚é–“åŠ æ¬Š (Minutes Weighted)ã€ï¼Œæ›´èƒ½åæ˜ å ´ä¸Šå¯¦éš›é™£å®¹é€Ÿåº¦ã€‚\n\n")
        f.write("| çƒéšŠ | åŠ æ¬Šå¹³å‡é€Ÿåº¦ | å ´å‡ Pace | å ´å‡å›åˆæ•¸ |\n|---|---:|---:|---:|\n")
        for _, r in speed_df.iterrows():
            f.write(f"| `{r['team_id']}` | {r['w_speed']:.1f} | {r['pace']:.2f} | {r['poss']:.2f} |\n")
        f.write("\n")
        
        if len(speed_df) > 1:
            corr = speed_df['w_speed'].corr(speed_df['pace'])
            f.write(f"\n**åŠ æ¬Šé€Ÿåº¦èˆ‡ Pace çš„ç›¸é—œä¿‚æ•¸ (Correlation):** {corr:.4f}\n")
            
        f.write("\n## 11. é«˜éšçƒå“¡è¡¨ç¾æ’è¡Œ (SSR/SS/S)\n")
        f.write("> ä¾å ´å‡å¾—åˆ† (PPG) æ’åºï¼Œå–å‰ 20 å\n\n")
        f.write("| æ’å | çƒå“¡ | éšŠä¼ | ä½ç½® | ç­‰ç´š | PPG | RPG | APG | FG% | MPG |\n")
        f.write("|---:|---|---|---|---|---:|---:|---:|---:|---:|\n")
        
        rank = 1
        for _, r in hg_stats.iterrows():
            f.write(
                f"| {rank} | {r['name']} | {r['team_id']} | {r['position']} | {r['grade']} | "
                f"**{r['PPG']:.1f}** | {r['RPG']:.1f} | {r['APG']:.1f} | {_fmt_pct(r['FG%'])} | {r['MPG']:.1f} |\n"
            )
            rank += 1
        f.write("\n")
        
        f.write("## 12. é•ä¾‹è©³ç´°åˆ†æ (Distribution)\n")
        for tid in team_ids:
            f.write(f"### çƒéšŠ: `{tid}`\n")
            d = vio_dist_data[tid]
            
            # 8s
            f.write("**8ç§’é•ä¾‹å–®å ´æ¬¡æ•¸åˆ†ä½ˆ:**\n")
            f.write("| æ¬¡æ•¸ | å ´æ•¸ | ä½”æ¯” |\n|---:|---:|---:|\n")
            total_g = sum(d['v8'].values())
            for k, v in d['v8'].items():
                if v > 0:
                    f.write(f"| {k} æ¬¡ | {v} | {_fmt_pct(v/total_g)} |\n")
            
            # 24s
            f.write("\n**24ç§’é•ä¾‹å–®å ´æ¬¡æ•¸åˆ†ä½ˆ:**\n")
            f.write("| æ¬¡æ•¸ | å ´æ•¸ | ä½”æ¯” |\n|---:|---:|---:|\n")
            total_g = sum(d['v24'].values())
            for k, v in d['v24'].items():
                if v > 0:
                    f.write(f"| {k} æ¬¡ | {v} | {_fmt_pct(v/total_g)} |\n")
            f.write("\n")
    
    pbar.update(1) # Step 13 Done
    pbar.close()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--parquet", type=str, default=DEFAULT_PARQUET)
    parser.add_argument("--cycles", type=int, default=500, help="æ¯ cycle 6 å ´ï¼›ç¸½å ´æ•¸=cycles*6")
    parser.add_argument("--batch-size", type=int, default=50)
    parser.add_argument("--seed", type=int, default=None)
    parser.add_argument("--output-root", type=str, default=DEFAULT_OUTPUT_ROOT)
    args = parser.parse_args()

    if args.seed is not None:
        rng.seed(args.seed)

    run_id = now_id()
    output_dir = os.path.join(PROJECT_ROOT, args.output_root, run_id)
    os.makedirs(output_dir, exist_ok=True)
    
    error_log_path = os.path.join(output_dir, "error_log.txt")

    snapshot_dir = make_snapshot(output_dir)
    print(f"[Snapshot] {snapshot_dir}")

    config = load_config()
    teams_src = load_teams(args.parquet)
    team_ids = sorted(list(teams_src.keys()))
    pairs = list(combinations(team_ids, 2))  # 4éšŠ=6å ´

    total_games = args.cycles * len(pairs)
    print(f"[Run] cycles={args.cycles}, total_games={total_games}, batch_size={args.batch_size}")

    proc = psutil.Process(os.getpid())
    t0 = time.time()

    # buffers
    matches_rows: List[Dict[str, Any]] = []
    team_game_rows: List[Dict[str, Any]] = []
    box_rows: List[Dict[str, Any]] = []
    poss_rows: List[Dict[str, Any]] = []

    # batch files
    mf, tf, bf, pf = [], [], [], []
    batch_idx = 0
    game_idx = 0

    def flush():
        nonlocal batch_idx, matches_rows, team_game_rows, box_rows, poss_rows
        if not matches_rows:
            return

        try:
            mdf = pd.DataFrame(matches_rows)
            tdf = pd.DataFrame(team_game_rows)
            bdf = pd.DataFrame(box_rows)
            pdf = pd.DataFrame(poss_rows)

            base = os.path.join(output_dir, "batches")
            os.makedirs(base, exist_ok=True)
            m_path = os.path.join(base, f"matches_{batch_idx:05d}.parquet")
            t_path = os.path.join(base, f"team_game_stats_{batch_idx:05d}.parquet")
            b_path = os.path.join(base, f"boxscores_{batch_idx:05d}.parquet")
            p_path = os.path.join(base, f"possession_times_{batch_idx:05d}.parquet")

            write_parquet(mdf, m_path)
            write_parquet(tdf, t_path)
            write_parquet(bdf, b_path)
            write_parquet(pdf, p_path)

            mf.append(m_path)
            tf.append(t_path)
            bf.append(b_path)
            pf.append(p_path)

            # Clear buffers
            matches_rows = []
            team_game_rows = []
            box_rows = []
            poss_rows = []

            batch_idx += 1
            
            # [Forensic] Aggressive GC to prevent OOM
            gc.collect()
            
        except Exception as e:
            # [Forensic] Flush Isolation - Log and discard batch, do NOT crash main loop
            err_msg = f"=== Flush Error at Batch {batch_idx} ===\n{traceback.format_exc()}\n"
            tqdm.write(f"[Critical] Flush failed: {e}")
            with open(error_log_path, "a", encoding="utf-8") as ef:
                ef.write(err_msg)
                ef.flush()
                os.fsync(ef.fileno())
            
            # Discard buffers to prevent memory leak
            matches_rows = []
            team_game_rows = []
            box_rows = []
            poss_rows = []

    pbar = tqdm(total=total_games, ncols=120)

    try:
        for _ in range(args.cycles):
            for a_id, b_id in pairs:
                game_idx += 1
                game_id = f"{run_id}_G{game_idx:06d}"
                
                retries = 0
                success = False
                
                while not success and retries < MAX_RETRIES_PER_GAME:
                    try:
                        team_a = clone_team(teams_src[a_id])
                        team_b = clone_team(teams_src[b_id])

                        engine = MatchEngine(team_a, team_b, config, game_id=game_id)
                        result = engine.simulate()
                        
                        success = True

                        a_8sec = int(result.home_violation_8s)
                        a_24sec = int(result.home_violation_24s)
                        b_8sec = int(result.away_violation_8s)
                        b_24sec = int(result.away_violation_24s)

                        matches_rows.append({
                            "game_id": game_id,
                            "team_a_id": team_a.id,
                            "team_b_id": team_b.id,
                            "team_a_score": int(result.home_score),
                            "team_b_score": int(result.away_score),
                            "is_ot": bool(result.is_ot),
                            "total_quarters": int(result.total_quarters),
                            "pace": float(result.pace),
                            "team_a_possessions": int(result.home_possessions),
                            "team_b_possessions": int(result.away_possessions),
                            "team_a_fb_made": int(result.home_fb_made),
                            "team_a_fb_attempt": int(result.home_fb_attempt),
                            "team_b_fb_made": int(result.away_fb_made),
                            "team_b_fb_attempt": int(result.away_fb_attempt),
                            "team_a_violation_8s": a_8sec,
                            "team_a_violation_24s": a_24sec,
                            "team_b_violation_8s": b_8sec,
                            "team_b_violation_24s": b_24sec,
                        })

                        a_poss = int(result.home_possessions)
                        b_poss = int(result.away_possessions)

                        a_pts = int(result.home_score)
                        b_pts = int(result.away_score)
                        
                        base_row = {
                            "game_id": game_id,
                            "pace": float(result.pace),
                            "is_ot": bool(result.is_ot),
                            "total_quarters": int(result.total_quarters),
                        }
                        
                        team_game_rows.append({
                            **base_row,
                            "team_id": team_a.id,
                            "opponent_team_id": team_b.id,
                            "points": a_pts,
                            "opp_points": b_pts,
                            "possessions": a_poss,
                            "sec_per_poss": float(team_a.stat_possession_seconds / a_poss) if a_poss > 0 else 0.0,
                            "ortg": calc_orating(a_pts, a_poss),
                            "drtg": calc_orating(b_pts, a_poss),
                            "net": calc_orating(a_pts, a_poss) - calc_orating(b_pts, a_poss),
                            "fb_made": int(result.home_fb_made),
                            "fb_attempt": int(result.home_fb_attempt),
                            "violation_8s": a_8sec,
                            "violation_24s": a_24sec,
                        })
                        
                        team_game_rows.append({
                            **base_row,
                            "team_id": team_b.id,
                            "opponent_team_id": team_a.id,
                            "points": b_pts,
                            "opp_points": a_pts,
                            "possessions": b_poss,
                            "sec_per_poss": float(team_b.stat_possession_seconds / b_poss) if b_poss > 0 else 0.0,
                            "ortg": calc_orating(b_pts, b_poss),
                            "drtg": calc_orating(a_pts, b_poss),
                            "net": calc_orating(b_pts, b_poss) - calc_orating(a_pts, b_poss),
                            "fb_made": int(result.away_fb_made),
                            "fb_attempt": int(result.away_fb_attempt),
                            "violation_8s": b_8sec,
                            "violation_24s": b_24sec,
                        })

                        box_rows.extend(extract_box_rows(game_id, team_a, team_b.id))
                        box_rows.extend(extract_box_rows(game_id, team_b, team_a.id))

                        poss_rows.extend(extract_possession_rows(game_id, team_a, team_b.id))
                        poss_rows.extend(extract_possession_rows(game_id, team_b, team_a.id))

                    except BaseException as e: # [Forensic] Catch everything including SystemExit/KeyboardInterrupt
                        retries += 1
                        error_msg = traceback.format_exc()
                        tqdm.write(f"[Warning] Game {game_id} failed (Retry {retries}/{MAX_RETRIES_PER_GAME})")
                        
                        with open(error_log_path, "a", encoding="utf-8") as ef:
                            ef.write(f"=== Error in {game_id} (Retry {retries}/{MAX_RETRIES_PER_GAME}) ===\n")
                            ef.write(f"Teams: {a_id} vs {b_id}\n")
                            ef.write(error_msg)
                            ef.write("\n" + "="*50 + "\n")
                            ef.flush()
                            os.fsync(ef.fileno())
                        
                        if isinstance(e, KeyboardInterrupt):
                            raise e

                if not success:
                    tqdm.write(f"[CRITICAL] Game {game_id} failed after {MAX_RETRIES_PER_GAME} retries.")

                # Update Progress & Resource Monitor
                if game_idx == 1 or game_idx % 100 == 0:
                    cpu = psutil.cpu_percent(interval=None)
                    ram_mb = proc.memory_info().rss / (1024**2)
                    elapsed = time.time() - t0
                    pbar.set_postfix({"CPU%": f"{cpu:.0f}", "RAM(MB)": f"{ram_mb:.0f}", "Elapsed(s)": f"{elapsed:.0f}"})

                pbar.update(1)

                if game_idx % args.batch_size == 0:
                    flush()

        # Final flush
        flush()
        
    except KeyboardInterrupt:
        tqdm.write("\n[Stopped] User interrupted.")
        flush()
    except BaseException as e: # [Forensic] Catch ALL, including SystemExit
        tqdm.write(f"\n[CRITICAL ERROR] Main loop crashed: {e}")
        with open(error_log_path, "a", encoding="utf-8") as ef:
            ef.write(f"=== CRITICAL MAIN LOOP CRASH ===\n{traceback.format_exc()}\n")
            ef.flush()
            os.fsync(ef.fileno())
    finally:
        pbar.close()

    # merge outputs
    out_matches = os.path.join(output_dir, "matches.parquet")
    out_team = os.path.join(output_dir, "team_game_stats.parquet")
    out_box = os.path.join(output_dir, "boxscores.parquet")
    out_poss = os.path.join(output_dir, "possession_times.parquet")

    print("\n[Merging] Consolidating batch files...")
    if mf:
        concat_parquets(mf, out_matches)
        concat_parquets(tf, out_team)
        concat_parquets(bf, out_box)
        concat_parquets(pf, out_poss)

        print(f"\n[Loading] Reading merged dataframes...")
        matches_df = pd.read_parquet(out_matches)
        team_df = pd.read_parquet(out_team)
        box_df = pd.read_parquet(out_box)
        poss_df = pd.read_parquet(out_poss)

        report_path = os.path.join(output_dir, "report.md")
        build_report(
            report_path=report_path,
            run_id=run_id,
            config=config,
            teams_src=teams_src,
            matches_df=matches_df,
            team_df=team_df,
            box_df=box_df,
            poss_df=poss_df,
        )

        cpu = psutil.cpu_percent(interval=None)
        ram_mb = proc.memory_info().rss / (1024**2)
        elapsed = time.time() - t0

        print("\n=== DONE ===")
        print(f"run_id: {run_id}")
        print(f"output_dir: {output_dir}")
        print(f"matches: {matches_df.shape[0]}")
        print(f"team_game_stats: {team_df.shape[0]}")
        print(f"possession_rows: {poss_df.shape[0]}")
        print(f"report: {report_path}")
        print(f"CPU%: {cpu:.0f}  RAM(MB): {ram_mb:.0f}  elapsed(s): {elapsed:.1f}")
    else:
        print("\n[Warning] No data generated. Check error logs.")


if __name__ == "__main__":
    try:
        # Optional: Clear terminal for cleaner output
        from scripts.terminal import clear_terminal
        clear_terminal()
        pass
    except ImportError:
        pass
    except Exception:
        pass
    main()
```

---

### ğŸ“„ File: `tests\player_generator_big_data\analyzer.py`

```python
# tests/player_generator_big_data/analyzer.py
import pandas as pd
import numpy as np
import os
import json
import math
import pyarrow.dataset as ds
from datetime import datetime, timedelta
import time

# ==========================================
# æ¬„ä½åç¨±æ˜ å°„è¡¨
# ==========================================
FIELD_MAP = {
    # Untrainable
    'physical_stamina': 'é«”åŠ›',
    'physical_strength': 'åŠ›é‡',
    'physical_speed': 'é€Ÿåº¦',
    'physical_jumping': 'å½ˆè·³',
    'physical_health': 'å¥åº·',
    'offense_touch': 'æ‰‹æ„Ÿ',
    'offense_release': 'å‡ºæ‰‹é€Ÿåº¦',
    'mental_off_iq': 'é€²æ”»æ™ºå•†',
    'mental_def_iq': 'é˜²å®ˆæ™ºå•†',
    'mental_luck': 'é‹æ°£',
    
    # Trainable
    'offense_accuracy': 'æŠ•ç±ƒæº–å¿ƒ',
    'offense_range': 'å°„ç¨‹',
    'offense_passing': 'å‚³çƒ',
    'offense_dribble': 'é‹çƒ',
    'offense_handle': 'æ§çƒ',
    'offense_move': 'è·‘ä½',
    'defense_rebound': 'ç±ƒæ¿',
    'defense_boxout': 'å¡ä½',
    'defense_contest': 'å¹²æ“¾',
    'defense_disrupt': 'æŠ„æˆª'
}

# Base Caps Definition for Validation
BASE_CAPS = {'G': 800, 'C': 700, 'B': 650, 'A': 600, 'S': 550, 'SS': 550, 'SSR': 550}

class BigDataAnalyzer:
    def __init__(self, config, data_path):
        self.config = config
        self.data_path = data_path
        self.report_lines = []
        self.meta = {}
        
        # çµ±è¨ˆå®¹å™¨ (Aggregators)
        self.stats = {
            'total_rows': 0,
            'grade_counts': {},
            
            # [New] Name & Language Stats
            'lang_counts': {},       # èªç³»çµ±è¨ˆ {code: count}
            'unique_names': set(),   # å”¯ä¸€å§“åé›†åˆ (ç”¨æ–¼è¨ˆç®—é‡è¤‡ç‡)
            
            # Height
            'height_counts': {}, 
            'height_sum': 0.0,
            'height_sq_sum': 0.0,
            
            # Position Matrix
            'pos_matrix': {}, 
            
            # KPI 3.1.C: Rating by Detailed Height & Grade
            'rating_matrix': {},

            # Untrainable (Sum Ranges)
            'untrainable_sum_ranges': {}, 
            
            # Histograms
            'stat_histograms_by_grade': {}, 
            'stat_histograms_by_pos': {},
            
            # Trainable (Slices & Caps)
            'trainable_slices': {}, 
            'trainable_caps': {}, 
            
            # Age
            'age_dist': {}, 
            
            # Violations & Monitors
            'violations': [],
            
            # KPI 3.6 Small Player Monitor by Grade
            'small_player_stats': {} 
        }

    def _log(self, text):
        self.report_lines.append(text)

    def _load_metadata(self):
        meta_path = os.path.join(self.data_path, "execution_meta.json")
        if os.path.exists(meta_path):
            with open(meta_path, 'r') as f:
                self.meta = json.load(f)
        else:
            self.meta = {
                "start_time": "N/A", "end_time": "N/A", "duration_seconds": 0,
                "total_rows": 0, "peak_cpu": 0, "peak_ram_gb": 0, "avg_speed": 0
            }

    def run_analysis(self):
        """åŸ·è¡Œåˆ†æä¸¦ç”Ÿæˆå ±å‘Š"""
        self._load_metadata()
        self._write_project_journal()
        self._process_stream()
        
        self._write_execution_summary()
        self._write_name_analysis()      # [New] æ–°å¢åå­—èˆ‡èªç³»åˆ†æå ±å‘Š
        self._write_height_analysis() 
        self._write_position_matrix() 
        self._write_rating_matrix()   
        self._write_grade_distribution() 
        self._write_untrainable_analysis() 
        self._write_trainable_analysis()   
        self._write_age_analysis()    
        self._write_violations()      
        
        return "\n".join(self.report_lines)

    def _write_project_journal(self):
        now_str = datetime.now().strftime('%Y-%m-%d %H:%M')
        self._log(f"# {now_str} å°ˆæ¡ˆé–‹ç™¼æ—¥èªŒï¼šASBL çƒå“¡ç”Ÿæˆç³»çµ±å¤§æ•¸æ“šé©—è­‰æ¶æ§‹ (v2.7)")
        self._log(f"**Project Journal: ASBL Player Generation System - Big Data Verification Architecture (v2.7)**\n")
        self._log(f"**æ—¥æœŸ**: {now_str}")
        self._log(f"**åƒèˆ‡è€…**: Product Owner (User), Lead Architect (Monica)")
        self._log(f"**ä¸»é¡Œ**: æ“´å¢å§“åèˆ‡èªç³»å¤šæ¨£æ€§åˆ†æ (Name Variety Analysis)\n")
        self._log(f"## 1. å‰è¨€ï¼šæ¸¬è©¦ç›®æ¨™ (Preface)")
        self._log(f"æœ¬æ¬¡æ›´æ–° (v2.7) æ–°å¢äº†é‡å° `PlayerGenerator` å§“ååº«çš„çµ±è¨ˆåˆ†æã€‚")
        self._log(f"ç›®æ¨™æ˜¯é©—è­‰å¤šåœ‹èªç³» (Nationality) çš„å‡ºç¾æ©Ÿç‡æ˜¯å¦ç¬¦åˆè¨­å®šï¼Œä¸¦ç›£æ¸¬å§“åé‡è¤‡ç‡ä»¥è©•ä¼°è©åº«è±å¯Œåº¦ã€‚\n")

    def _process_stream(self):
        print("[Analyzer] é–‹å§‹ä¸²æµæƒææ•¸æ“š (Aggregation Mode)...")
        t0 = time.time()
        
        files = [
            os.path.join(self.data_path, f) 
            for f in os.listdir(self.data_path) 
            if f.endswith('.parquet')
        ]
        
        if not files:
            print("[Error] ç›®éŒ„ä¸­æ‰¾ä¸åˆ°ä»»ä½• .parquet æª”æ¡ˆï¼")
            return

        dataset = ds.dataset(files, format="parquet")
        
        # Bins Definitions
        pos_h_bins = [0, 189, 199, 209, 300]
        pos_h_labels = ['< 190', '190-199', '200-209', '>= 210']
        
        det_h_bins = [0, 169, 179, 189, 199, 209, 219, 300]
        det_h_labels = ['< 170', '170-179', '180-189', '190-199', '200-209', '210-219', '>= 220']
        
        stat_bins = [0, 10, 40, 60, 89, 99]
        
        # Columns (Added 'nationality')
        cols = [
            'grade', 'position', 'height', 'age', 'name', 'nationality', 'rating',
            # Untrainable
            'physical_stamina', 'physical_strength', 'physical_speed', 'physical_jumping', 'physical_health',
            'offense_touch', 'offense_release', 'mental_off_iq', 'mental_def_iq', 'mental_luck',
            # Trainable
            'offense_accuracy', 'offense_range', 'offense_passing', 'offense_dribble', 'offense_handle', 'offense_move',
            'defense_rebound', 'defense_boxout', 'defense_contest', 'defense_disrupt'
        ]
        
        schema_names = dataset.schema.names
        scan_cols = [c for c in cols if c in schema_names]
        
        untrainable_cols = [c for c in scan_cols if c in [
            'physical_stamina', 'physical_strength', 'physical_speed', 'physical_jumping', 'physical_health',
            'offense_touch', 'offense_release', 'mental_off_iq', 'mental_def_iq', 'mental_luck'
        ]]
        trainable_cols = [c for c in scan_cols if c in [
            'offense_accuracy', 'offense_range', 'offense_passing', 'offense_dribble', 'offense_handle', 'offense_move',
            'defense_rebound', 'defense_boxout', 'defense_contest', 'defense_disrupt'
        ]]

        for batch in dataset.to_batches(columns=scan_cols, batch_size=100000):
            df = batch.to_pandas()
            self.stats['total_rows'] += len(df)
            
            # [New] Language Stats
            if 'nationality' in df.columns:
                l_counts = df['nationality'].value_counts()
                for l, c in l_counts.items():
                    self.stats['lang_counts'][l] = self.stats['lang_counts'].get(l, 0) + c
            
            # [New] Name Uniqueness
            if 'name' in df.columns:
                # å°‡è©²æ‰¹æ¬¡çš„å”¯ä¸€å§“ååŠ å…¥å…¨åŸŸé›†åˆ
                batch_unique = set(df['name'].unique())
                self.stats['unique_names'].update(batch_unique)

            # 1. Grade Counts
            g_counts = df['grade'].value_counts()
            for g, c in g_counts.items():
                self.stats['grade_counts'][g] = self.stats['grade_counts'].get(g, 0) + c
                
            # 2. Height Stats
            h_counts = df['height'].value_counts()
            for h, c in h_counts.items():
                self.stats['height_counts'][h] = self.stats['height_counts'].get(h, 0) + c
            
            h_vals = df['height'].values
            self.stats['height_sum'] += np.sum(h_vals)
            self.stats['height_sq_sum'] += np.sum(h_vals ** 2)
            
            # 3. Position Matrix
            pos_h_cuts = pd.cut(df['height'], bins=pos_h_bins, labels=pos_h_labels)
            pos_grp = df.groupby([pos_h_cuts, 'position'], observed=True).size()
            for (h_grp, pos), count in pos_grp.items():
                self.stats['pos_matrix'][(h_grp, pos)] = self.stats['pos_matrix'].get((h_grp, pos), 0) + count
            
            # 3.1.C Rating Matrix
            if 'rating' in df.columns:
                det_h_cuts = pd.cut(df['height'], bins=det_h_bins, labels=det_h_labels)
                rating_grp = df.groupby([det_h_cuts, 'grade'], observed=True)['rating'].agg(['sum', 'count'])
                for (h_grp, grade), row in rating_grp.iterrows():
                    key = (h_grp, grade)
                    if key not in self.stats['rating_matrix']:
                        self.stats['rating_matrix'][key] = {'sum': 0, 'count': 0}
                    self.stats['rating_matrix'][key]['sum'] += row['sum']
                    self.stats['rating_matrix'][key]['count'] += row['count']

            # 4. Histograms by Grade
            grouped_g = df.groupby('grade')
            for grade, sub_df in grouped_g:
                if grade not in self.stats['stat_histograms_by_grade']:
                    self.stats['stat_histograms_by_grade'][grade] = {}
                
                target_cols = untrainable_cols + trainable_cols
                for col in target_cols:
                    counts, _ = np.histogram(sub_df[col], bins=stat_bins)
                    if col not in self.stats['stat_histograms_by_grade'][grade]:
                        self.stats['stat_histograms_by_grade'][grade][col] = np.zeros(len(stat_bins)-1, dtype=int)
                    self.stats['stat_histograms_by_grade'][grade][col] += counts
                    
                    # Check bounds
                    c_min, c_max = sub_df[col].min(), sub_df[col].max()
                    if c_min < 1 or c_max > 99:
                        self.stats['violations'].append(f"ç­‰ç´š {grade} å±¬æ€§ {FIELD_MAP.get(col, col)} è¶…å‡ºç¯„åœ 1-99 (Val: {c_min}-{c_max})")

            # 5. Histograms by Position
            grouped_p = df.groupby('position')
            for pos, sub_df in grouped_p:
                if pos not in self.stats['stat_histograms_by_pos']:
                    self.stats['stat_histograms_by_pos'][pos] = {}
                for col in trainable_cols:
                    counts, _ = np.histogram(sub_df[col], bins=stat_bins)
                    if col not in self.stats['stat_histograms_by_pos'][pos]:
                        self.stats['stat_histograms_by_pos'][pos][col] = np.zeros(len(stat_bins)-1, dtype=int)
                    self.stats['stat_histograms_by_pos'][pos][col] += counts

            # Untrainable Sum Check
            if untrainable_cols:
                batch_u_sums = df[untrainable_cols].sum(axis=1)
                temp_df = pd.DataFrame({'grade': df['grade'], 'u_sum': batch_u_sums})
                grp_stats = temp_df.groupby('grade')['u_sum'].agg(['min', 'max'])
                for g in grp_stats.index:
                    g_min, g_max = grp_stats.loc[g, 'min'], grp_stats.loc[g, 'max']
                    if g not in self.stats['untrainable_sum_ranges']:
                        self.stats['untrainable_sum_ranges'][g] = {'min': 9999, 'max': 0}
                    curr = self.stats['untrainable_sum_ranges'][g]
                    curr['min'] = min(curr['min'], g_min)
                    curr['max'] = max(curr['max'], g_max)

            # Trainable Stats (Slices & Caps & Small Player Monitor)
            if trainable_cols:
                t_sum = df[trainable_cols].sum(axis=1)
                t_bins = list(range(0, 1001, 100))
                t_cuts = pd.cut(t_sum, bins=t_bins, right=False, labels=False)
                
                slice_grp = df.groupby(['grade', t_cuts], observed=True).size()
                for (g, bin_idx), count in slice_grp.items():
                    if g not in self.stats['trainable_slices']: self.stats['trainable_slices'][g] = {}
                    self.stats['trainable_slices'][g][bin_idx] = self.stats['trainable_slices'][g].get(bin_idx, 0) + count
                    
                temp_t_df = pd.DataFrame({'grade': df['grade'], 't_sum': t_sum})
                grp_max = temp_t_df.groupby('grade')['t_sum'].max()
                trash_mask = temp_t_df['t_sum'] < 100
                grp_trash = temp_t_df[trash_mask].groupby('grade').size()
                
                all_grades = set(grp_max.index) | set(grp_trash.index)
                for g in all_grades:
                    if g not in self.stats['trainable_caps']: 
                        self.stats['trainable_caps'][g] = {'max': 0, 'trash': 0}
                    if g in grp_max:
                        self.stats['trainable_caps'][g]['max'] = max(self.stats['trainable_caps'][g]['max'], grp_max[g])
                    if g in grp_trash:
                        self.stats['trainable_caps'][g]['trash'] += grp_trash[g]
                        
                # Monitor 3.6: Small Player Overflow Check
                is_small = df['height'] <= 189
                if is_small.any():
                    small_df = pd.DataFrame({
                        'grade': df.loc[is_small, 'grade'],
                        't_sum': t_sum[is_small]
                    })
                    
                    for grade, sub_df in small_df.groupby('grade'):
                        cap = BASE_CAPS.get(grade, 9999)
                        max_val = sub_df['t_sum'].max()
                        count = len(sub_df)
                        overflow_count = (sub_df['t_sum'] > cap).sum()
                        
                        if grade not in self.stats['small_player_stats']:
                            self.stats['small_player_stats'][grade] = {'max': 0, 'count': 0, 'overflow_count': 0}
                        
                        s = self.stats['small_player_stats'][grade]
                        s['max'] = max(s['max'], max_val)
                        s['count'] += count
                        s['overflow_count'] += overflow_count

            # 6. Age Distribution
            age_grp = df.groupby(['grade', 'age']).size()
            for (g, age), count in age_grp.items():
                if g not in self.stats['age_dist']: self.stats['age_dist'][g] = {}
                self.stats['age_dist'][g][age] = self.stats['age_dist'][g].get(age, 0) + count
                
            if self.stats['total_rows'] % 5000000 == 0:
                print(f"  Processed {self.stats['total_rows']/1000000:.0f}M rows...")
                
        print(f"[Analyzer] æƒæå®Œæˆã€‚è€—æ™‚: {time.time() - t0:.2f} ç§’")

    def _write_execution_summary(self):
        m = self.meta
        duration_str = str(timedelta(seconds=int(m['duration_seconds'])))
        
        self._log("ğŸ“Š [åŸ·è¡Œæ‘˜è¦å ±å‘Š] Execution Summary Report")
        self._log("-" * 100)
        self._log(f"â€¢ Log æª”æ¡ˆ:      {os.path.join(self.data_path, 'execution_meta.json')}")
        self._log(f"â€¢ åŸ·è¡Œæ™‚é–“:      {m['start_time']} ~ {m['end_time']}")
        self._log(f"â€¢ ç¸½è€—æ™‚:        {duration_str}")
        self._log(f"â€¢ ç¸½ç”Ÿæˆç­†æ•¸:    {m['total_rows']:,}")
        self._log(f"â€¢ å¹³å‡é€Ÿåº¦:      {m['avg_speed']:.2f} ç­†/ç§’")
        self._log(f"â€¢ è¨˜æ†¶é«”å³°å€¼:    {m['peak_ram_gb']:.2f} GB")
        self._log(f"â€¢ CPU å³°å€¼:      {m['peak_cpu']:.1f}%")
        self._log("-" * 100 + "\n")

    def _write_name_analysis(self):
        """[New] è¼¸å‡ºå§“åèˆ‡èªç³»åˆ†æ"""
        self._log("ğŸ“Š [KPI 3.0] å§“åèˆ‡èªç³»å¤šæ¨£æ€§ (Name & Nationality Diversity)")
        self._log("-" * 100)
        
        total = self.stats['total_rows']
        if total == 0: return

        # 1. èªç³»åˆ†ä½ˆ
        self._log("ğŸ” (A) èªç³»åˆ†ä½ˆ (Nationality Distribution):")
        self._log(f"{'Code':<10} | {'Count':<12} | {'Percentage':<12}")
        self._log("-" * 40)
        
        sorted_langs = sorted(self.stats['lang_counts'].items(), key=lambda x: x[1], reverse=True)
        for code, count in sorted_langs:
            pct = count / total
            self._log(f"{code:<10} | {count:<12,} | {pct:10.2%}")
        self._log("-" * 40 + "\n")

        # 2. å§“åé‡è¤‡ç‡
        unique_count = len(self.stats['unique_names'])
        repetition_rate = 1.0 - (unique_count / total)
        
        self._log("ğŸ” (B) å§“åè±å¯Œåº¦ (Name Uniqueness):")
        self._log(f"â€¢ ç¸½ç”Ÿæˆæ•¸ (Total):      {total:,}")
        self._log(f"â€¢ å”¯ä¸€å§“åæ•¸ (Unique):    {unique_count:,}")
        self._log(f"â€¢ é‡è¤‡ç‡ (Repetition):    {repetition_rate:.2%} (æ•¸å€¼è¶Šä½ä»£è¡¨è©åº«çµ„åˆè¶Šå¤š)")
        
        # ç°¡å–®è©•åƒ¹
        status = "æ¥µé«˜" if repetition_rate < 0.1 else "ä¸­ç­‰" if repetition_rate < 0.5 else "åé«˜"
        self._log(f"â€¢ è©åº«å¤šæ¨£æ€§è©•åƒ¹:        {status}")
        self._log("\n")

    def _get_normal_prob(self, start, end, mean=195, std=10):
        cdf_end = 0.5 * (1 + math.erf((end - mean) / (std * 2**0.5)))
        cdf_start = 0.5 * (1 + math.erf((start - mean) / (std * 2**0.5)))
        return cdf_end - cdf_start

    def _write_height_analysis(self):
        self._log("ğŸ“Š [KPI 3.1 A] èº«é«˜åˆ†ä½ˆèˆ‡æ¥µç«¯å€¼ç›£æ¸¬")
        self._log("   ç†è«–æ¨¡å‹: Mean=195, SD=10")
        self._log("-" * 120)
        self._log(f"{'Slice (cm)':<12} | {'Actual %':<12} | {'Theory %':<12} | {'Diff %':<12} | Status")
        self._log("-" * 120)
        
        slices = [
            (160, 169), (170, 179), (180, 189), (190, 199),
            (200, 209), (210, 219), (220, 229)
        ]
        total = self.stats['total_rows']
        if total == 0: return

        for s_min, s_max in slices:
            count = sum(self.stats['height_counts'].get(h, 0) for h in range(s_min, s_max + 1))
            actual_pct = count / total
            theory_pct = self._get_normal_prob(s_min - 0.5, s_max + 0.5)
            diff = actual_pct - theory_pct
            status = "âœ…" if abs(diff) < 0.015 else "âŒ"
            self._log(f"{s_min}-{s_max}cm    | {actual_pct:10.4%} | {theory_pct:10.4%} | {diff:+10.4%} | {status}")
        
        self._log("-" * 120)
        self._log("ğŸ” æ¥µç«¯å€¼é€å…¬åˆ†è©³ç´°ç›£æ¸¬ (Per cm Breakdown):")
        self._log("\n   >>> Low Extreme (160-169 cm)")
        self._write_height_detail(160, 169)
        self._log("\n   >>> High Extreme (221-230 cm)")
        self._write_height_detail(221, 230)
        self._log("\n")

    def _write_height_detail(self, start, end):
        self._log(f"   {'Height':<8} | {'Count':<10} | {'Actual %':<10} | {'Theory %':<10} | {'Diff %':<10}")
        self._log("   " + "-" * 70)
        total_sub = 0
        for h in range(start, end + 1):
            c = self.stats['height_counts'].get(h, 0)
            total_sub += c
            act = c / self.stats['total_rows']
            theory = self._get_normal_prob(h - 0.5, h + 0.5)
            diff = act - theory
            self._log(f"   {h} cm   | {c:10,} | {act:9.4%} | {theory:9.4%} | {diff:+.4%}")
        self._log("   " + "-" * 70)
        self._log(f"   Total    | {total_sub:10,} | {total_sub/self.stats['total_rows']:9.4%}")

    def _write_position_matrix(self):
        self._log("ğŸ“Š [KPI 3.1 B] ä½ç½®åˆ¤å®šçŸ©é™£ (Position Assignment)")
        labels = ['< 190', '190-199', '200-209', '>= 210']
        targets = {
            '< 190': {'PG': 0.60, 'SG': 0.40},
            '190-199': {'PG': 0.35, 'SG': 0.45, 'SF': 0.20},
            '200-209': {'PF': 0.50, 'SF': 0.20, 'C': 0.15, 'SG': 0.10, 'PG': 0.05},
            '>= 210': {'C': 0.45, 'PF': 0.30, 'SG': 0.10, 'SF': 0.10, 'PG': 0.05}
        }
        self._log(f"{'Height Bin':<10} | {'Pos':<4} | {'Target %':<10} | {'Actual % (Count)':<22} | {'Diff %':<8} | Check")
        self._log("-" * 120)
        for label in labels:
            row_total = sum(self.stats['pos_matrix'].get((label, p), 0) for p in ['PG', 'SG', 'SF', 'PF', 'C'])
            if row_total == 0: continue
            self._log(f"[{label}] (Total: {row_total:,})")
            t_map = targets.get(label, {})
            sorted_pos = sorted(t_map.keys(), key=lambda x: t_map[x], reverse=True)
            for pos in sorted_pos:
                target = t_map[pos]
                count = self.stats['pos_matrix'].get((label, pos), 0)
                actual = count / row_total
                diff = actual - target
                check = "âœ…" if abs(diff) < 0.01 else "âŒ"
                self._log(f"{'':<10} | {pos:<4} | {target:9.4%} | {actual:9.4%} ({count})   | {diff:+.4%} | {check}")
            self._log("-" * 120)
        self._log("\n")

    def _write_rating_matrix(self):
        self._log("ğŸ“Š [KPI 3.1 C] èº«é«˜ç´šè·å…§å„ç­‰ç´šå¹³å‡èƒ½åŠ›å€¼ (Average Rating by 10cm)")
        labels = ['< 170', '170-179', '180-189', '190-199', '200-209', '210-219', '>= 220']
        grades = ['G', 'C', 'B', 'A', 'S', 'SS', 'SSR']
        
        header = f"{'Height Bin':<10} | " + " | ".join([f"{g:^8}" for g in grades])
        self._log("-" * len(header))
        self._log(header)
        self._log("-" * len(header))
        
        for label in labels:
            vals = []
            for g in grades:
                key = (label, g)
                data = self.stats['rating_matrix'].get(key, {'sum': 0, 'count': 0})
                if data['count'] > 0:
                    avg = data['sum'] / data['count']
                    vals.append(f"{avg:^8.1f}")
                else:
                    vals.append(f"{'-':^8}")
            self._log(f"{label:<10} | " + " | ".join(vals))
        self._log("-" * len(header) + "\n")

    def _write_grade_distribution(self):
        self._log("ğŸ“Š [KPI 3.2] ç­‰ç´šæ©Ÿç‡åˆ†ä½ˆ (Grade Drop Rates)")
        targets = {
            'G':   {'target': 0.280, 'tol': 0.010},
            'C':   {'target': 0.260, 'tol': 0.010},
            'B':   {'target': 0.220, 'tol': 0.010},
            'A':   {'target': 0.140, 'tol': 0.010},
            'S':   {'target': 0.070, 'tol': 0.005},
            'SS':  {'target': 0.025, 'tol': 0.005},
            'SSR': {'target': 0.005, 'tol': 0.001}
        }
        self._log(f"{'Grade':<6} | {'Target':<8} | {'Actual':<10} | {'Diff':<10} | {'Tolerance':<10} | Status")
        self._log("-" * 80)
        total = self.stats['total_rows']
        for g in ['G', 'C', 'B', 'A', 'S', 'SS', 'SSR']:
            count = self.stats['grade_counts'].get(g, 0)
            actual = count / total if total > 0 else 0
            t_data = targets[g]
            target = t_data['target']
            tol = t_data['tol']
            diff = actual - target
            status = "âœ…" if abs(diff) <= tol else f"âŒ"
            self._log(f"{g:<6} | {target:8.1%} | {actual:10.4%} | {diff:+.4%} | Â±{tol:.1%}   | {status}")
        self._log("-" * 80 + "\n")

    def _write_generic_histograms(self, title, data_source, keys, target_cols):
        self._log(title)
        self._log("-" * 120)
        self._log(f"{'Stat Name':<12} | {'1-10':<12} | {'11-40':<12} | {'41-60':<12} | {'61-89':<12} | {'90-99':<12}")
        
        for key in keys:
            if key not in data_source: continue
            self._log(f"\n[Group: {key}]")
            self._log("-" * 80)
            
            group_data = data_source[key]
            for col in target_cols:
                if col not in group_data: continue
                counts = group_data[col]
                total = counts.sum()
                if total == 0: continue
                pcts = counts / total
                cn_name = FIELD_MAP.get(col, col)
                row = f"{cn_name:<12} | " + " | ".join([f"{p:10.4%}" for p in pcts])
                self._log(row)
        self._log("\n")

    def _write_untrainable_analysis(self):
        self._log("ğŸ“Š [KPI 3.3] å¤©è³¦ç”Ÿæˆè©³ç´°é©—è­‰ (Untrainable Stats)")
        self._log("-" * 120)
        
        self._log("ğŸ” (A) ç¸½åˆ†å€é–“åˆè¦æ€§ (Total Sum Check):")
        self._log(f"{'Grade':<6} | {'Spec Range':<15} | {'Actual Range':<15} | Status")
        specs = {
            'G': (10, 400), 'C': (399, 600), 'B': (599, 700),
            'A': (699, 800), 'S': (799, 900), 'SS': (900, 950), 'SSR': (951, 990)
        }
        for g in ['G', 'C', 'B', 'A', 'S', 'SS', 'SSR']:
            if g not in self.stats['untrainable_sum_ranges']: continue
            data = self.stats['untrainable_sum_ranges'][g]
            spec = specs.get(g, (0,0))
            status = "âœ…"
            if data['min'] < spec[0] or data['max'] > spec[1]:
                status = f"âŒ (Out: {data['min']}~{data['max']})"
            self._log(f"{g:<6} | {spec[0]}-{spec[1]:<10} | {data['min']}-{data['max']:<10} | {status}")
        self._log("\n")

        cols = [
            'physical_stamina', 'physical_strength', 'physical_speed', 'physical_jumping', 'physical_health',
            'offense_touch', 'offense_release', 'mental_off_iq', 'mental_def_iq', 'mental_luck'
        ]
        self._write_generic_histograms(
            "ğŸ” (B) å¤©è³¦å±¬æ€§åˆ†ä½ˆ (Untrainable Distribution by Grade)",
            self.stats['stat_histograms_by_grade'],
            ['SSR', 'SS', 'S', 'A', 'B', 'C', 'G'],
            cols
        )

    def _write_trainable_analysis(self):
        self._log("ğŸ“Š [KPI 3.4] æŠ€è¡“ç”Ÿæˆé©—è­‰ (Trainable Stats)")
        self._log("-" * 120)
        
        self._log("ğŸ” (A) ç¸½åˆ†åˆ‡ç‰‡åˆ†ä½ˆ (Total Score Slices):")
        slices = [f"{i}-{i+99}" for i in range(0, 900, 100)]
        header = f"{'Grade':<6} | " + " | ".join([f"{s:^12}" for s in slices])
        self._log(header)
        self._log("-" * len(header))
        for g in ['G', 'C', 'B', 'A', 'S', 'SS', 'SSR']:
            if g not in self.stats['trainable_slices']: continue
            row_data = self.stats['trainable_slices'][g]
            g_total = sum(row_data.values())
            vals = []
            for i in range(len(slices)):
                c = row_data.get(i, 0)
                if c == 0: vals.append(f"{'0.00%':^12}")
                else:
                    pct = c / g_total
                    if pct < 0.0001: vals.append(f"{pct:.4%} (n={c})")
                    else: vals.append(f"{pct:^12.4%}")
            self._log(f"{g:<6} | " + " | ".join(vals))
        self._log("\n")
        
        self._log("ğŸ” (B) æ¥µå€¼ç›£æ¸¬ (Extreme Values):")
        self._log(f"{'Grade':<6} | {'Max Val':<10} | {'Trash (<100)':<15}")
        self._log("-" * 60)
        for g in ['G', 'C', 'B', 'A', 'S', 'SS', 'SSR']:
            if g in self.stats['trainable_caps']:
                d = self.stats['trainable_caps'][g]
                g_total = self.stats['grade_counts'].get(g, 1)
                trash_pct = d['trash'] / g_total
                self._log(f"{g:<6} | {d['max']:<10} | {trash_pct:.4%} (n={d['trash']})")
        self._log("\n")

        cols = [
            'offense_accuracy', 'offense_range', 'offense_passing', 'offense_dribble', 'offense_handle', 'offense_move',
            'defense_rebound', 'defense_boxout', 'defense_contest', 'defense_disrupt'
        ]
        self._write_generic_histograms(
            "ğŸ” (C) æŠ€è¡“å±¬æ€§åˆ†ä½ˆ (Trainable Distribution by Grade)",
            self.stats['stat_histograms_by_grade'],
            ['SSR', 'SS', 'S', 'A', 'B', 'C', 'G'],
            cols
        )
        
        self._write_generic_histograms(
            "ğŸ” (D) æŠ€è¡“å±¬æ€§åˆ†ä½ˆ (Trainable Distribution by Position)",
            self.stats['stat_histograms_by_pos'],
            ['PG', 'SG', 'SF', 'PF', 'C'],
            cols
        )

    def _write_age_analysis(self):
        self._log("ğŸ“Š [KPI 3.5] å¹´é½¡åˆ†ä½ˆé©—è­‰ (Age Distribution)")
        self._log("-" * 120)
        targets = {
            'SSR': [18], 'SS': [18, 19], 'S': [18, 19, 20],
            'A': [18, 19, 20, 21], 'B': range(18, 23), 'C': range(18, 24), 'G': range(18, 25)
        }
        for g, allowed_ages in targets.items():
            if g not in self.stats['age_dist']: continue
            dist = self.stats['age_dist'][g]
            total = sum(dist.values())
            expected_pct = 1.0 / len(allowed_ages)
            self._log(f"{g:<4} | Target: {list(allowed_ages)}")
            for age in sorted(dist.keys()):
                pct = dist[age] / total
                diff = pct - expected_pct
                status = "âœ…" if abs(diff) < 0.03 else "âš ï¸"
                self._log(f"       â†³ {age}æ­²: {pct:.4%} (Diff: {diff:+.4%}) {status}")
            self._log("-" * 60)
        self._log("\n")

    def _write_violations(self):
        self._log("ğŸš¨ [KPI 3.6] é•è¦èˆ‡ç•°å¸¸æª¢æ¸¬ (Violation Check)")
        self._log("   ç›®æ¨™: ç¢ºä¿æ²’æœ‰ä»»ä½•ä¸€ç­†è³‡æ–™é•åç¡¬æ€§è¦å‰‡ã€‚")
        self._log("-" * 120)
        
        # 3.6.A Basic Violations
        if not self.stats['violations']:
            self._log("âœ… [å–®é …å±¬æ€§é‚Šç•Œ] æ‰€æœ‰å±¬æ€§çš†åœ¨ 1-99 ç¯„åœå…§ã€‚")
        else:
            unique_v = list(set(self.stats['violations']))
            for v in unique_v[:20]:
                self._log(f"âŒ {v}")
            if len(unique_v) > 20:
                self._log(f"... (é‚„æœ‰ {len(unique_v)-20} é …éŒ¯èª¤)")
                
        # 3.6.B Small Player Monitor by Grade
        self._log("\nğŸ” [çŸ®å€‹å­ç›£æ§] èº«é«˜ <= 189cm çƒå“¡èƒ½åŠ›å€¼æª¢æ¸¬ (ä¾ç­‰ç´š):")
        self._log("   èªªæ˜: æª¢æŸ¥æ˜¯å¦å› èº«é«˜ç´…åˆ©å°è‡´çªç ´è©²ç­‰ç´šçš„ Base Capã€‚")
        
        self._log(f"   {'Grade':<6} | {'Total Small (n)':<16} | {'Max Val':<8} | {'Base Cap':<8} | {'Overflow (n)':<12} | {'Overflow %':<10} | Check")
        self._log("   " + "-" * 100)
        
        # Sort by Grade Priority
        for g in ['SSR', 'SS', 'S', 'A', 'B', 'C', 'G']:
            if g not in self.stats['small_player_stats']:
                self._log(f"   {g:<6} | {'0':<16} | {'-':<8} | {BASE_CAPS.get(g,0):<8} | {'-':<12} | {'-':<10} | -")
                continue
                
            data = self.stats['small_player_stats'][g]
            max_val = data['max']
            count = data['count']
            overflow_count = data['overflow_count']
            base_cap = BASE_CAPS.get(g, 0)
            
            overflow_pct = overflow_count / count if count > 0 else 0
            
            diff = max_val - base_cap
            status = "âœ…"
            if diff > 50: status = "âš ï¸ (High)"
            if diff < 0: status = "âœ… (Under)"
            
            self._log(f"   {g:<6} | {count:<16,} | {max_val:<8} | {base_cap:<8} | {overflow_count:<12,} | {overflow_pct:<10.2%} | {status}")
            
        self._log("-" * 120)
```

---

### ğŸ“„ File: `tests\player_generator_big_data\check_data_integrity.py`

```python
# tests/player_generator_big_data/check_data_integrity.py
import os
import sys
import glob
import pyarrow.parquet as pq
from concurrent.futures import ProcessPoolExecutor
from tqdm import tqdm

# ==========================================
# è¨­å®š
# ==========================================
DATA_DIR = os.path.join(os.path.dirname(__file__), 'data')

def check_file(filepath):
    """
    å˜—è©¦è®€å–å–®å€‹ Parquet æª”æ¡ˆçš„ Schema å’Œç¬¬ä¸€æ‰¹æ•¸æ“š
    ä»¥é©—è­‰æª”æ¡ˆæ˜¯å¦æå£æˆ–å­—å…¸ç·¨ç¢¼æ˜¯å¦æœ‰èª¤
    """
    try:
        # åƒ…è®€å– Metadata èˆ‡ç¬¬ä¸€è¡Œæ•¸æ“šï¼Œé€Ÿåº¦è¼ƒå¿«
        parquet_file = pq.ParquetFile(filepath)
        _ = parquet_file.metadata
        _ = parquet_file.read_row_group(0)
        return None  # æˆåŠŸ
    except Exception as e:
        return (filepath, str(e))

def main():
    print(f"Checking data integrity in: {DATA_DIR}")
    files = glob.glob(os.path.join(DATA_DIR, "*.parquet"))
    
    if not files:
        print("No parquet files found.")
        return

    print(f"Found {len(files)} files. Starting verification...")
    
    bad_files = []
    
    # ä½¿ç”¨å¤šé€²ç¨‹åŠ é€Ÿæª¢æŸ¥
    with ProcessPoolExecutor(max_workers=20) as executor:
        results = list(tqdm(executor.map(check_file, files), total=len(files), unit="file"))
    
    for res in results:
        if res is not None:
            bad_files.append(res)
    
    print("-" * 60)
    if bad_files:
        print(f"âŒ Found {len(bad_files)} corrupted files:")
        for fpath, err in bad_files:
            print(f"File: {os.path.basename(fpath)}")
            print(f"Error: {err}")
            # é¸é …ï¼šè‡ªå‹•åˆªé™¤å£æª”
            # os.remove(fpath)
            # print("Deleted.")
        print("\nå»ºè­°ï¼šè«‹æ‰‹å‹•åˆªé™¤ä¸Šè¿°æå£æª”æ¡ˆå¾Œï¼Œå†åŸ·è¡Œåˆ†æå ±å‘Šã€‚")
    else:
        print("âœ… All files passed integrity check.")
    print("-" * 60)

if __name__ == "__main__":
    main()
```

---

### ğŸ“„ File: `tests\player_generator_big_data\run_test.py`

```python
# tests/player_generator_big_data/run_test.py
import os
import sys
import time
import yaml
import shutil
import multiprocessing
import random
import psutil
import json
from datetime import datetime, timedelta

# ==========================================
# ç’°å¢ƒè¨­å®š
# ==========================================
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(current_dir, '../../'))
sys.path.append(project_root)

# å»¶é²åŒ¯å…¥ pandasï¼Œé¿å…åœ¨ä¸»é€²ç¨‹åˆå§‹åŒ–æ™‚é€ æˆåº•å±¤è¡çª
pd = None 

try:
    from app import create_app
    from app.services.player_generator import PlayerGenerator
    import config
    from analyzer import BigDataAnalyzer
except ImportError as e:
    print(f"[Error] ç„¡æ³•åŒ¯å…¥å°ˆæ¡ˆæ¨¡çµ„ï¼Œè«‹æª¢æŸ¥è·¯å¾‘ã€‚\n{e}")
    sys.exit(1)

# ==========================================
# å·¥å…·å‡½å¼
# ==========================================
def load_config():
    path = os.path.join(current_dir, 'test_config.yaml')
    with open(path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)

def get_system_stats():
    mem = psutil.virtual_memory()
    return psutil.cpu_percent(), mem.percent, mem.used / (1024**3)

def get_latest_run_dir(base_dir):
    """æœå°‹ base_dir ä¸‹æœ€æ–°çš„æ™‚é–“æˆ³è³‡æ–™å¤¾"""
    if not os.path.exists(base_dir):
        return None
    
    subdirs = [d for d in os.listdir(base_dir) if os.path.isdir(os.path.join(base_dir, d))]
    if not subdirs:
        return None
    
    # å‡è¨­è³‡æ–™å¤¾åç¨±æ ¼å¼ç‚º YYYYMMDD_HHMMï¼Œæ’åºå¾Œæœ€å¾Œä¸€å€‹å³ç‚ºæœ€æ–°
    subdirs.sort()
    return os.path.join(base_dir, subdirs[-1])

class ResourceMonitor:
    """ç”¨æ–¼è¿½è¹¤æ•´å€‹åŸ·è¡Œéç¨‹ä¸­çš„è³‡æºå³°å€¼"""
    def __init__(self):
        self.peak_cpu = 0.0
        self.peak_ram_gb = 0.0
        self.start_time = None
        self.end_time = None
        self.total_rows = 0

    def update(self):
        cpu, _, mem_gb = get_system_stats()
        if cpu > self.peak_cpu: self.peak_cpu = cpu
        if mem_gb > self.peak_ram_gb: self.peak_ram_gb = mem_gb
        return cpu, mem_gb

def print_progress(current, total, start_time, monitor):
    elapsed = time.time() - start_time
    rate = current / elapsed if elapsed > 0 else 0
    eta = (total - current) / rate if rate > 0 else 0
    
    cpu, mem_gb = monitor.update()
    
    bar_len = 30
    filled = int(bar_len * current / total)
    bar = 'â–ˆ' * filled + 'â–‘' * (bar_len - filled)
    
    sys.stdout.write(
        f"\r[{bar}] {current/total*100:5.1f}% | "
        f"Cnt: {current/1000:.0f}k | "
        f"Spd: {rate:.0f}/s | "
        f"CPU: {cpu:4.0f}% | "
        f"RAM: {mem_gb:4.1f}G | "
        f"ETA: {int(eta//60)}:{int(eta%60):02d}   "
    )
    sys.stdout.flush()

# ==========================================
# Worker (å¤šé€²ç¨‹ç”Ÿæˆä»»å‹™)
# ==========================================
def worker_task(batch_size):
    """å–®ä¸€ Worker çš„ç”Ÿæˆä»»å‹™"""
    # å¼·åˆ¶é‡ç½®éš¨æ©Ÿç¨®å­
    random.seed(os.getpid() + time.time())
    
    app = create_app(config.Config)
    data = []
    
    with app.app_context():
        PlayerGenerator.initialize_class()
        try:
            for _ in range(batch_size):
                payload = PlayerGenerator.generate_payload()
                data.append(PlayerGenerator.to_flat_dict(payload))
        except Exception as e:
            print(f"[Worker Error PID {os.getpid()}]: {e}")
            return []
    return data

# ==========================================
# æµç¨‹æ§åˆ¶
# ==========================================
def run_dry_run(conf):
    global pd
    import pandas as pd
    
    count = conf['execution']['dry_run_count']
    batch_size = conf['execution']['batch_size_per_task']
    workers = conf['execution']['max_workers']
    
    print(f"\n=== [æ­¥é©Ÿ 1] è©¦è·‘ (Dry Run: {count:,} ç­†) ===")
    print(f"Worker æ•¸: {workers}")
    
    start_time = time.time()
    monitor = ResourceMonitor()
    
    tasks = [batch_size] * (count // batch_size)
    if count % batch_size != 0: tasks.append(count % batch_size)
    
    results = []
    ctx = multiprocessing.get_context('spawn')
    
    with ctx.Pool(processes=workers) as pool:
        for res in pool.imap_unordered(worker_task, tasks):
            results.extend(res)
            print_progress(len(results), count, start_time, monitor)
            
    duration = time.time() - start_time
    print(f"\n\nè©¦è·‘å®Œæˆï¼è€—æ™‚: {duration:.2f} ç§’ (é€Ÿåº¦: {count/duration:.0f} ç­†/ç§’)")
    
    print("-" * 60)
    print("æ¨£æœ¬æ•¸æ“šé è¦½:")
    df = pd.DataFrame(results[:3])
    print(df[['name', 'grade', 'position', 'height', 'rating', 'salary']].to_string(index=False))
    print("-" * 60)
    
    return count / duration

def execute_production_run(target_count, speed, conf):
    global pd
    if pd is None: import pandas as pd
    
    print(f"\n=== [æ­¥é©Ÿ 3] æ­£å¼åŸ·è¡Œ (Target: {target_count:,} ç­†) ===")
    
    # 1. å»ºç«‹æ™‚é–“æˆ³è¨˜è³‡æ–™å¤¾
    run_id = datetime.now().strftime('%Y%m%d_%H%M')
    base_data_dir = os.path.join(current_dir, conf['output']['data_dir'])
    current_run_dir = os.path.join(base_data_dir, run_id)
    
    os.makedirs(current_run_dir, exist_ok=True)
    
    batch_size = conf['execution']['batch_size_per_task']
    workers = conf['execution']['max_workers']
    
    tasks = [batch_size] * (target_count // batch_size)
    if target_count % batch_size != 0: tasks.append(target_count % batch_size)
    
    print(f"è¼¸å‡ºç›®éŒ„: {current_run_dir}")
    
    monitor = ResourceMonitor()
    monitor.start_time = datetime.now()
    start_time = time.time()
    
    processed = 0
    file_idx = 0
    
    ctx = multiprocessing.get_context('spawn')
    
    with ctx.Pool(processes=workers) as pool:
        for batch_data in pool.imap_unordered(worker_task, tasks):
            if not batch_data: continue
            
            df = pd.DataFrame(batch_data)
            fname = f"part_{file_idx:05d}.parquet"
            fpath = os.path.join(current_run_dir, fname)
            
            df.to_parquet(fpath, engine='pyarrow', compression=conf['output']['compression'])
            
            processed += len(batch_data)
            file_idx += 1
            print_progress(processed, target_count, start_time, monitor)
            
    monitor.end_time = datetime.now()
    monitor.total_rows = processed
    total_time = time.time() - start_time
    
    print(f"\n\nåŸ·è¡Œå®Œæˆï¼ç¸½è€—æ™‚: {total_time:.2f} ç§’")
    
    # å„²å­˜åŸ·è¡Œæ‘˜è¦ (Metadata) ä¾› Analyzer ä½¿ç”¨
    meta_path = os.path.join(current_run_dir, "execution_meta.json")
    meta_data = {
        "run_id": run_id,
        "start_time": monitor.start_time.strftime("%Y-%m-%d %H:%M:%S"),
        "end_time": monitor.end_time.strftime("%Y-%m-%d %H:%M:%S"),
        "duration_seconds": total_time,
        "total_rows": processed,
        "peak_cpu": monitor.peak_cpu,
        "peak_ram_gb": monitor.peak_ram_gb,
        "avg_speed": processed / total_time if total_time > 0 else 0
    }
    with open(meta_path, 'w') as f:
        json.dump(meta_data, f)
        
    return current_run_dir

def generate_report(data_dir, conf):
    print(f"\n=== [æ­¥é©Ÿ 4] æ•¸æ“šåˆ†æèˆ‡å ±å‘Šç”Ÿæˆ ===")
    print(f"åˆ†æç›®æ¨™ç›®éŒ„: {data_dir}")
    
    # å–å¾— Run ID (å¾è³‡æ–™å¤¾åç¨±)
    run_id = os.path.basename(os.path.normpath(data_dir))
    
    # å»ºç«‹å°æ‡‰çš„å ±å‘Šç›®éŒ„
    base_report_dir = os.path.join(current_dir, conf['output']['report_dir'])
    current_report_dir = os.path.join(base_report_dir, run_id)
    os.makedirs(current_report_dir, exist_ok=True)
    
    analyzer = BigDataAnalyzer(conf, data_dir)
    report_content = analyzer.run_analysis()
    
    report_file = os.path.join(current_report_dir, f"Validation_Report.md")
    with open(report_file, 'w', encoding='utf-8') as f:
        f.write(report_content)
        
    print(f"\nå ±å‘Šå·²ç”Ÿæˆ: {report_file}")
    print("-" * 60)

if __name__ == "__main__":
    try:
        from scripts.terminal import clear_terminal
        clear_terminal()
    except ImportError:
        pass
    except Exception:
        pass
    multiprocessing.freeze_support()
    os.environ['PYTHON_JIT'] = '0'
    
    conf = load_config()
    
    print("\n==========================================")
    print("   ASBL Big Data Generator & Analyzer     ")
    print("==========================================")
    print("1. å®Œæ•´æµç¨‹ (è©¦è·‘ -> ç”Ÿæˆ -> å ±å‘Š)")
    print("2. åƒ…ç”Ÿæˆå ±å‘Š (Report Only - åˆ†ææœ€æ–°çµæœ)")
    print("q. é›¢é–‹")
    
    mode = input("\nè«‹é¸æ“‡æ¨¡å¼ [1/2]: ").strip().lower()
    
    if mode == 'q':
        sys.exit(0)
        
    elif mode == '2':
        base_data_dir = os.path.join(current_dir, conf['output']['data_dir'])
        latest_dir = get_latest_run_dir(base_data_dir)
        
        if not latest_dir:
            print(f"\n[Error] åœ¨ {base_data_dir} æ‰¾ä¸åˆ°ä»»ä½•æ¸¬è©¦æ•¸æ“šè³‡æ–™å¤¾ã€‚")
            sys.exit(1)
            
        print(f"\n[System] åµæ¸¬åˆ°æœ€æ–°æ¸¬è©¦æ•¸æ“š: {latest_dir}")
        generate_report(latest_dir, conf)
        
    else:
        speed = run_dry_run(conf)
        while True:
            try:
                val = input("\nè«‹è¼¸å…¥æ­£å¼åŸ·è¡Œçš„ç¸½ç­†æ•¸ (ä¾‹å¦‚ 1000000) [è¼¸å…¥ q é›¢é–‹]: ")
                if val.lower() == 'q': sys.exit(0)
                target_count = int(val)
                est_sec = target_count / speed
                print(f"é ä¼°è€—æ™‚: {est_sec:.0f} ç§’ ({est_sec/60:.1f} åˆ†)")
                if input("ç¢ºèªåŸ·è¡Œ? (y/n): ").lower() == 'y': break
            except ValueError: pass
        
        data_dir = execute_production_run(target_count, speed, conf)
        generate_report(data_dir, conf)
```

---

### ğŸ“„ File: `tests\player_generator_big_data\test_config.yaml`

```yaml
# tests/player_generator_big_data/test_config.yaml

execution:
  # è©¦è·‘æ¬¡æ•¸ (ç”¨æ–¼è¨ˆç®—é ä¼°æ™‚é–“)
  dry_run_count: 300000
  
  # ä¸¦è¡Œé‹ç®—è¨­å®š
  # i9-14900K (24 Cores / 32 Threads)
  # å»ºè­°ä¿ç•™ä¸€äº›æ ¸å¿ƒçµ¦ OS èˆ‡èƒŒæ™¯ä½œæ¥­ï¼Œè¨­ç‚º 20-24 æ•ˆæœæœ€ä½³
  max_workers: 24
  
  # åˆ‡ç‰‡å¤§å°
  # æ¯å€‹ Worker æ¯æ¬¡å›å‚³çš„ç­†æ•¸ã€‚
  # 128GB RAM å¯ä»¥è¨­å¤§ä¸€é» (50000-100000) ä»¥æ¸›å°‘ I/O é »ç‡
  batch_size_per_task: 100000

output:
  # è³‡æ–™å­˜æ”¾ç›®éŒ„ (ç›¸å°æ–¼ tests/player_generator_big_data/)
  data_dir: "data"
  logs_dir: "logs"
  report_dir: "reports"
  
  # å£“ç¸®æ ¼å¼ (snappy é€Ÿåº¦æœ€å¿«ï¼Œé©åˆå¤§æ•¸æ“šæš«å­˜)
  compression: "snappy"

validation:
  # [æ–°å¢éœ€æ±‚] ç­‰ç´šæ©Ÿç‡èˆ‡å®¹è¨±èª¤å·®
  grade_distribution:
    G:   { target: 0.280, tolerance: 0.010 }
    C:   { target: 0.260, tolerance: 0.010 }
    B:   { target: 0.220, tolerance: 0.010 }
    A:   { target: 0.140, tolerance: 0.010 }
    S:   { target: 0.070, tolerance: 0.005 }
    SS:  { target: 0.025, tolerance: 0.005 }
    SSR: { target: 0.005, tolerance: 0.001 }

  # èº«é«˜åˆ†ä½ˆç†è«–å€¼ (ç”¨æ–¼å ±å‘Šæ¯”è¼ƒ)
  height_distribution:
    mean: 195
    std_dev: 10
```

---

### ğŸ“„ File: `tests\team_bigdata_test\manual_merge.py`

```python
# tests/team_bigdata_test/manual_merge.py
# Description: æ•‘æ´å´©æ½°æ•¸æ“š V2 - ä¿®æ­£å­—ä¸²è§£æéŒ¯èª¤ (Fix String/List parsing issue)

import os
import sys
import pandas as pd
import numpy as np
import ast
from datetime import datetime
from collections import Counter
import glob

# ==========================================
# è¨­å®šå€
# ==========================================
TARGET_DIR = r"D:\ASBL-Basketball-Manager\tests\team_bigdata_test\data\20251229_202911"

def parse_names(val):
    """
    å˜—è©¦å°‡å„ç¨®å¥‡å½¢æ€ªç‹€çš„è³‡æ–™è½‰å› List
    """
    if isinstance(val, list):
        return val
    if isinstance(val, np.ndarray):
        return val.tolist()
    if isinstance(val, str):
        val = val.strip()
        if val.startswith('[') and val.endswith(']'):
            try:
                # å°‡å­—ä¸² "['A', 'B']" è½‰å› list ['A', 'B']
                return ast.literal_eval(val)
            except:
                pass
        return [val] # çœŸçš„åªæ˜¯å–®ä¸€å­—ä¸²
    return []

def main():
    print(f"æ­£åœ¨æ•‘æ´ç›®éŒ„: {TARGET_DIR}")
    
    temp_dir = os.path.join(TARGET_DIR, "temp_parts")
    final_parquet_path = os.path.join(TARGET_DIR, 'teams_data.parquet')
    report_file = os.path.join(TARGET_DIR, "report_rescued_v2.md")

    if not os.path.exists(temp_dir):
        print(f"éŒ¯èª¤: æ‰¾ä¸åˆ°æš«å­˜ç›®éŒ„ {temp_dir}")
        return

    # 1. è®€å–ä¸¦åˆä½µæ•¸æ“š
    print("æ­£åœ¨è®€å–æ‰€æœ‰åˆ†å¡Šæª”æ¡ˆ...")
    try:
        files = glob.glob(os.path.join(temp_dir, "*.parquet"))
        if not files:
            print("æ²’æœ‰æª”æ¡ˆå¯ä»¥åˆä½µã€‚")
            return

        df_all = pd.read_parquet(temp_dir)
        print(f"åˆä½µæˆåŠŸï¼ç¸½è³‡æ–™ç­†æ•¸: {len(df_all):,}")
        
        # å­˜æª”
        df_all.to_parquet(final_parquet_path, engine='pyarrow')
        print(f"å·²å„²å­˜åˆä½µæª”æ¡ˆè‡³: {final_parquet_path}")
        
    except Exception as e:
        print(f"åˆä½µå¤±æ•—: {e}")
        return

    # 2. ç”Ÿæˆå ±å‘Š
    print("æ­£åœ¨é‡æ–°è¨ˆç®—çµ±è¨ˆæ•¸æ“šä¸¦ç”Ÿæˆå ±å‘Š...")
    
    try:
        scores = df_all['weighted_score']
        times = df_all['generation_time']
        
        avg_score = scores.mean()
        stdev_score = scores.std()
        min_score = scores.min()
        max_score = scores.max()
        avg_time = times.mean()
        
        print("æ­£åœ¨åˆ†æåå­—é‡è¤‡ç‡ (æ­£åœ¨è§£æå­—ä¸²ï¼Œè«‹ç¨å€™)...")
        global_name_counter = Counter()
        
        # ä½¿ç”¨ apply é€²è¡Œæ‰¹æ¬¡è™•ç†ï¼Œæ¯” for loop å¿«ä¸€é»
        # ä½†ç‚ºäº†ä¿éšªèµ·è¦‹ï¼Œæˆ‘å€‘ç”¨æ˜ç¢ºçš„è¿­ä»£ä¸¦åŠ å…¥é€²åº¦é¡¯ç¤º
        all_names = []
        total_rows = len(df_all)
        
        for idx, row_names in enumerate(df_all['player_names']):
            parsed_list = parse_names(row_names)
            all_names.extend(parsed_list)
            
            if idx % 50000 == 0:
                print(f"å·²è™•ç† {idx}/{total_rows} éšŠ...")
        
        global_name_counter.update(all_names)
        
        total_players = sum(global_name_counter.values())
        unique_names = len(global_name_counter)
        duplicate_ratio = ((total_players - unique_names) / total_players) * 100 if total_players > 0 else 0
        top_duplicates = global_name_counter.most_common(20) # çœ‹å‰ 20 å

        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(f"# ASBL éšŠä¼ç”Ÿæˆå¤§æ•¸æ“šå£“åŠ›æ¸¬è©¦å ±å‘Š (æ•‘æ´ä¿®æ­£ç‰ˆ)\n")
            f.write(f"**æ•‘æ´æ™‚é–“**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"**è³‡æ–™è·¯å¾‘**: `{TARGET_DIR}`\n")
            f.write(f"**æ•‘æ´è³‡æ–™ç­†æ•¸**: {len(df_all):,}\n")
            f.write(f"**ç¸½çƒå“¡äººæ¬¡**: {total_players:,}\n\n")
            
            f.write(f"## 1. çµ±è¨ˆæ•¸æ“š\n")
            f.write(f"- **å¹³å‡åŠ æ¬Šåˆ†**: {avg_score:.4f}\n")
            f.write(f"- **æ¨™æº–å·®**: {stdev_score:.4f}\n")
            f.write(f"- **æœ€å°/æœ€å¤§åˆ†**: {min_score:.4f} / {max_score:.4f}\n")
            f.write(f"- **å¹³å‡ç”Ÿæˆæ™‚é–“**: {avg_time:.6f} ç§’/éšŠ\n")
            f.write(f"- **åå­—é‡è¤‡ç‡**: {duplicate_ratio:.4f}%\n")
            
            f.write(f"## 2. å‰ 20 åé‡è¤‡åå­—\n")
            f.write(f"| æ’å | åå­— | æ¬¡æ•¸ |\n|---|---|---|\n")
            for i, (name, count) in enumerate(top_duplicates, 1):
                f.write(f"| {i} | {name} | {count} |\n")
                
        print(f"ä¿®æ­£ç‰ˆå ±å‘Šå·²ç”Ÿæˆæ–¼ï¼š{report_file}")
        print("é€™æ¬¡æ‡‰è©²å¯ä»¥çœ‹åˆ°çœŸå¯¦çš„é‡è¤‡ç‡äº†ï¼")
        
    except Exception as e:
        print(f"å ±å‘Šç”Ÿæˆå¤±æ•—: {e}")
        import traceback
        traceback.print_exc()

if __name__ == '__main__':
    main()
```

---

### ğŸ“„ File: `tests\team_bigdata_test\run_simulation.py`

```python
# tests/team_bigdata_test/run_simulation.py
# Project: ASBL (Advanced Simulation Basketball League)
# Author: System Architect
# Date: 2026-01-26
# Description: 1000è¬æ”¯éšŠä¼ç”Ÿæˆå£“åŠ›æ¸¬è©¦ (ä¿®æ­£ Python 3.13 å¤šé€²ç¨‹å´©æ½°ç‰ˆ)

import os
import sys

# ==========================================
# [CRITICAL FIX] ç’°å¢ƒè®Šæ•¸è¨­å®š
# å¿…é ˆåœ¨åŒ¯å…¥ numpy/pandas ä¹‹å‰è¨­å®šï¼Œå¼·åˆ¶æ•¸å€¼é‹ç®—åº«åœ¨æ¯å€‹å­é€²ç¨‹ä¸­åªä½¿ç”¨å–®ä¸€åŸ·è¡Œç·’ã€‚
# é€™èƒ½é¿å… 30 å€‹ workers x N æ ¸å¿ƒå°è‡´çš„åŸ·è¡Œç·’çˆ†ç‚¸ (Thread Oversubscription) å’Œè§£é‡‹å™¨å´©æ½°ã€‚
# ==========================================
os.environ['OMP_NUM_THREADS'] = '1'
os.environ['OPENBLAS_NUM_THREADS'] = '1'
os.environ['MKL_NUM_THREADS'] = '1'
os.environ['VECLIB_MAXIMUM_THREADS'] = '1'
os.environ['NUMEXPR_NUM_THREADS'] = '1'

import time
import shutil
import logging
import multiprocessing
import psutil
import traceback
import threading
from collections import Counter
from datetime import datetime
from typing import Dict, List, Any

# å¼•å…¥ Pandas ç”¨æ–¼æ•¸æ“šå„²å­˜
try:
    import pandas as pd
except ImportError:
    print("éŒ¯èª¤: ç¼ºå°‘ pandas å¥—ä»¶ã€‚è«‹åŸ·è¡Œ pip install pandas pyarrow")
    sys.exit(1)

# å‡è¨­å°ˆæ¡ˆæ ¹ç›®éŒ„åœ¨å…©å±¤ä¹‹ä¸Š
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))

try:
    from app.services.team_creator import TeamCreator
    from app.utils.game_config_loader import GameConfigLoader
    from app import create_app 
except ImportError as e:
    print(f"åš´é‡éŒ¯èª¤: ç„¡æ³•åŒ¯å…¥å°ˆæ¡ˆæ¨¡çµ„ã€‚ {e}")
    sys.exit(1)

# ==========================================
# é…ç½®å¸¸æ•¸
# ==========================================
TARGET_TEAMS = 10000     # æ¸¬è©¦ç¸½æ•¸é‡
BATCH_SIZE = 1000          # æ‰¹æ¬¡å¤§å°
# [å»ºè­°] Windows ä¸‹å»ºè­°ä¸è¦è¶…é CPU æ ¸å¿ƒæ•¸ï¼Œé€™è£¡å‹•æ…‹èª¿æ•´
MAX_WORKERS = min(30, os.cpu_count() or 4) 
SAVE_THRESHOLD = 1000     # æ¯ç´¯ç©å¤šå°‘ç­†è³‡æ–™å°±å¯«å…¥ç¡¬ç¢Ÿä¸€æ¬¡

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_ROOT = os.path.join(BASE_DIR, 'data')
CONFIG_PATH = os.path.abspath(os.path.join(BASE_DIR, '../../config/game_config.yaml'))

STAT_WEIGHTS = {
    'talent_offiq': 1.08, 'talent_defiq': 1.07, 'ath_speed': 1.07,
    'off_move': 1.05, 'ath_strength': 1.05, 'ath_jump': 1.05,
    'off_pass': 1.04, 'def_contest': 1.04, 'off_handle': 1.04,
    'off_dribble': 1.04, 'def_disrupt': 1.04, 'shot_touch': 1.03,
    'shot_release': 1.03, 'def_boxout': 1.03, 'shot_range': 1.02,
    'def_rebound': 1.02, 'shot_accuracy': 1.02,
}

# ==========================================
# å…¨åŸŸè®Šæ•¸ (Worker å…§éƒ¨ä½¿ç”¨)
# ==========================================
shared_counter = None # ç”¨æ–¼è·¨é€²ç¨‹è¨ˆæ•¸

# ==========================================
# å·¥å…·é¡åˆ¥ (Static Methods Pattern)
# ==========================================
class SimulationUtils:
    
    @staticmethod
    def setup_environment():
        """å»ºç«‹å¸¶æœ‰æ™‚é–“æˆ³è¨˜çš„ç¨ç«‹åŸ·è¡Œç›®éŒ„èˆ‡æš«å­˜ç›®éŒ„"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        run_dir = os.path.join(DATA_ROOT, timestamp)
        temp_dir = os.path.join(run_dir, "temp_parts")
        
        os.makedirs(run_dir, exist_ok=True)
        os.makedirs(temp_dir, exist_ok=True)
        
        log_file = os.path.join(run_dir, f"simulation.log")
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
            ]
        )
        
        if os.path.exists(CONFIG_PATH):
            shutil.copy(CONFIG_PATH, os.path.join(run_dir, "game_config.yaml"))
        
        return run_dir, temp_dir

    @staticmethod
    def calculate_team_weighted_score(roster: List[Dict[str, Any]]) -> float:
        total_score = 0.0
        for player in roster:
            stats = player.get('raw_stats', {})
            if not stats and 'detailed_stats' in player:
                stats = {}
                for cat in player['detailed_stats'].values():
                    stats.update(cat)
            
            player_score = 0.0
            for attr, weight in STAT_WEIGHTS.items():
                val = stats.get(attr, 0)
                player_score += val * weight
            total_score += player_score
        return total_score

    @staticmethod
    def save_chunk(data: List[Dict], temp_dir: str, chunk_id: int):
        """å°‡ç›®å‰çš„ç·©è¡å€è³‡æ–™å¯«å…¥æš«å­˜ Parquet æª”"""
        if not data:
            return
        try:
            df = pd.DataFrame(data)
            file_path = os.path.join(temp_dir, f"part_{chunk_id:05d}.parquet")
            df.to_parquet(file_path, engine='pyarrow')
            logging.info(f"å·²å¯«å…¥åˆ†å¡Šæª”æ¡ˆ: {os.path.basename(file_path)} ({len(data)} ç­†)")
        except Exception as e:
            logging.error(f"å¯«å…¥åˆ†å¡Šæª”æ¡ˆå¤±æ•—: {e}")

# ==========================================
# Worker é‚è¼¯
# ==========================================

def init_worker(counter_val):
    """Worker åˆå§‹åŒ–ï¼Œæ¥æ”¶å…±äº«è¨ˆæ•¸å™¨"""
    global shared_counter
    shared_counter = counter_val 
    
    try:
        # éŒ¯é–‹å•Ÿå‹•æ™‚é–“ï¼Œæ¸›å°‘åŒæ™‚è®€å–æª”æ¡ˆçš„ IO ç«¶çˆ­
        time.sleep(os.getpid() % 5 * 0.1) 
        
        app = create_app()
        app.app_context().push()
        GameConfigLoader.load()
        
        from app.services.player_generator import PlayerGenerator
        PlayerGenerator.initialize_class()
    except Exception as e:
        # ä½¿ç”¨ logging è€Œä¸æ˜¯ printï¼Œé¿å… stdout ç«¶çˆ­
        logging.error(f"[Worker Error] Init failed (PID {os.getpid()}): {e}")

def simulation_task(batch_count: int) -> Dict[str, Any]:
    """å–®ä¸€ Worker çš„åŸ·è¡Œä»»å‹™"""
    local_records = [] 
    local_name_counter = Counter()
    error_count = 0
    
    for _ in range(batch_count):
        start_time = time.perf_counter()
        try:
            # å¢åŠ éè¿´æ·±åº¦é™åˆ¶ä¿è­·ï¼Œé›–ç„¶ Python é è¨­æœ‰ï¼Œä½†æ˜ç¢ºè¨­å®šå¯é¿å…æŸäº› C-stack overflow
            # sys.setrecursionlimit(2000) 
            
            roster = TeamCreator.create_valid_roster(max_attempts=100000)
            end_time = time.perf_counter()
            duration = end_time - start_time
            
            # æ›´æ–°å…±äº«è¨ˆæ•¸å™¨
            if shared_counter:
                with shared_counter.get_lock():
                    shared_counter.value += 1

            w_score = SimulationUtils.calculate_team_weighted_score(roster)
            names = [p['name'] for p in roster]
            
            local_records.append({
                'weighted_score': w_score,
                'generation_time': duration,
                'player_names': names, 
                'roster_size': len(roster)
            })
            
            local_name_counter.update(names)
            
        except RecursionError:
            logging.warning(f"ç”Ÿæˆå¤±æ•— (RecursionError) PID {os.getpid()}")
            error_count += 1
        except Exception as e:
            error_count += 1
            # é™ä½éŒ¯èª¤æ—¥èªŒé »ç‡ï¼Œé¿å…ç£ç¢Ÿ I/O å°è‡´æ›´åš´é‡çš„å»¶é²
            if error_count <= 5: 
                logging.warning(f"ç”Ÿæˆå¤±æ•— (PID {os.getpid()}): {e}")
            continue
            
    return {
        'records': local_records,
        'names': local_name_counter,
        'errors': error_count
    }

def monitor_progress(counter, total, start_time, stop_event):
    """ç¨ç«‹çš„ç›£æ§åŸ·è¡Œç·’ï¼Œè² è²¬æ›´æ–° UI"""
    while not stop_event.is_set():
        current = counter.value
        if current > 0:
            elapsed = time.time() - start_time
            rate = current / elapsed if elapsed > 0 else 0
            
            try:
                proc = psutil.Process(os.getpid())
                mem = proc.memory_info().rss / 1024 / 1024
            except:
                mem = 0
            
            sys.stdout.write(
                f"\ré€²åº¦: {current:,}/{total:,} ({current/total:.1%}) | "
                f"é€Ÿåº¦: {rate:.1f} éšŠ/ç§’ | "
                f"RAM: {mem:.0f} MB"
            )
            sys.stdout.flush()
        
        if current >= total:
            break
            
        time.sleep(0.5) # é™ä½æ›´æ–°é »ç‡ä»¥æ¸›å°‘è³‡æºæ¶ˆè€—

# ==========================================
# ä¸»ç¨‹å¼
# ==========================================

def main():
    # ç¢ºä¿ Windows ä¸‹ multiprocessing æ­£å¸¸é‹ä½œ
    multiprocessing.freeze_support()
    
    run_dir, temp_dir = SimulationUtils.setup_environment()
    print(f"é–‹å§‹åŸ·è¡Œ {TARGET_TEAMS:,} æ”¯éšŠä¼çš„æ¨¡æ“¬ç”Ÿæˆ")
    print(f"è¼¸å‡ºç›®éŒ„: {run_dir}")
    print(f"è¨­å®š: Batch={BATCH_SIZE}, Workers={MAX_WORKERS}")
    print(f"Python ç‰ˆæœ¬: {sys.version.split()[0]}")
    print("-" * 60)

    total_batches = TARGET_TEAMS // BATCH_SIZE
    tasks = [BATCH_SIZE] * total_batches
    if TARGET_TEAMS % BATCH_SIZE > 0:
        tasks.append(TARGET_TEAMS % BATCH_SIZE)

    global_counter = multiprocessing.Value('i', 0)
    stop_monitor = threading.Event()
    start_global = time.time()
    
    monitor_thread = threading.Thread(
        target=monitor_progress, 
        args=(global_counter, TARGET_TEAMS, start_global, stop_monitor)
    )
    monitor_thread.start()
    
    buffer_records = []
    global_name_counter = Counter()
    total_errors = 0
    chunk_counter = 0
    
    logging.info("æ­£åœ¨å•Ÿå‹• Worker Pool...")
    
    try:
        # ä½¿ç”¨ spawn (Windows é è¨­)
        ctx = multiprocessing.get_context('spawn')
        with ctx.Pool(processes=MAX_WORKERS, initializer=init_worker, initargs=(global_counter,)) as pool:
            results = pool.imap_unordered(simulation_task, tasks)
            
            for res in results:
                buffer_records.extend(res['records'])
                global_name_counter.update(res['names'])
                total_errors += res.get('errors', 0)
                
                if len(buffer_records) >= SAVE_THRESHOLD:
                    SimulationUtils.save_chunk(buffer_records, temp_dir, chunk_counter)
                    buffer_records = []
                    chunk_counter += 1
    except KeyboardInterrupt:
        print("\nä½¿ç”¨è€…ä¸­æ–·åŸ·è¡Œï¼Œæ­£åœ¨ä¿å­˜ç¾æœ‰é€²åº¦...")
        logging.warning("ä½¿ç”¨è€…ä¸­æ–·åŸ·è¡Œ")
    except Exception as e:
        print(f"\nä¸»é€²ç¨‹ç™¼ç”ŸéŒ¯èª¤: {e}")
        logging.error(f"ä¸»é€²ç¨‹ç™¼ç”ŸéŒ¯èª¤: {e}")
        traceback.print_exc()
    finally:
        stop_monitor.set()
        monitor_thread.join()
    
    # å¯«å…¥å‰©é¤˜è³‡æ–™
    if buffer_records:
        SimulationUtils.save_chunk(buffer_records, temp_dir, chunk_counter)
        
    print("\n" + "-" * 60)
    total_duration = time.time() - start_global
    print(f"æ¨¡æ“¬çµæŸã€‚ç¸½è€—æ™‚ {total_duration:.2f} ç§’ã€‚é–‹å§‹åˆä½µæ•¸æ“š...")
    logging.info(f"æ¨¡æ“¬çµæŸã€‚ç¸½è€—æ™‚ {total_duration:.2f} ç§’ã€‚")

    # ==========================================
    # åˆä½µ Parquet æ•¸æ“š
    # ==========================================
    final_parquet_path = os.path.join(run_dir, 'teams_data.parquet')
    
    try:
        # æª¢æŸ¥æ˜¯å¦æœ‰ç”Ÿæˆçš„æª”æ¡ˆ
        if not os.listdir(temp_dir):
            print("è­¦å‘Š: æ²’æœ‰ç”Ÿæˆä»»ä½•æ•¸æ“šæª”æ¡ˆã€‚")
            return

        df_all = pd.read_parquet(temp_dir)
        df_all.to_parquet(final_parquet_path, engine='pyarrow')
        logging.info(f"æ‰€æœ‰åˆ†å¡Šå·²åˆä½µè‡³: {final_parquet_path}")
        
        shutil.rmtree(temp_dir)
        logging.info("æš«å­˜ç›®éŒ„å·²æ¸…ç†ã€‚")
        
        # ==========================================
        # å ±å‘Šç”Ÿæˆ
        # ==========================================
        logging.info("æ­£åœ¨åˆ†ææ•¸æ“šä¸¦ç”Ÿæˆå ±å‘Š...")
        
        scores = df_all['weighted_score']
        times = df_all['generation_time']
        
        avg_score = scores.mean()
        stdev_score = scores.std()
        min_score = scores.min()
        max_score = scores.max()
        avg_time = times.mean()
        
        total_players = sum(global_name_counter.values())
        unique_names = len(global_name_counter)
        duplicate_ratio = ((total_players - unique_names) / total_players) * 100 if total_players > 0 else 0
        top_duplicates = global_name_counter.most_common(10)

        report_file = os.path.join(run_dir, "report.md")
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(f"# ASBL éšŠä¼ç”Ÿæˆå¤§æ•¸æ“šå£“åŠ›æ¸¬è©¦å ±å‘Š\n")
            f.write(f"**åŸ·è¡Œæ™‚é–“**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"**Python ç‰ˆæœ¬**: {sys.version}\n")
            f.write(f"**è³‡æ–™è·¯å¾‘**: `{run_dir}`\n")
            f.write(f"**ç›®æ¨™/å¯¦éš›**: {TARGET_TEAMS:,} / {len(df_all):,}\n")
            f.write(f"**å¤±æ•—æ¬¡æ•¸**: {total_errors}\n\n")
            
            f.write(f"## 1. çµ±è¨ˆæ•¸æ“š\n")
            f.write(f"- **å¹³å‡åŠ æ¬Šåˆ†**: {avg_score:.4f}\n")
            f.write(f"- **æ¨™æº–å·®**: {stdev_score:.4f}\n")
            f.write(f"- **æœ€å°/æœ€å¤§åˆ†**: {min_score:.4f} / {max_score:.4f}\n")
            f.write(f"- **å¹³å‡ç”Ÿæˆæ™‚é–“**: {avg_time:.6f} ç§’/éšŠ\n")
            f.write(f"- **åå­—é‡è¤‡ç‡**: {duplicate_ratio:.4f}%\n")
            
            f.write(f"## 2. å‰ 10 åé‡è¤‡åå­—\n")
            f.write(f"| åå­— | æ¬¡æ•¸ |\n|---|---|\n")
            for name, count in top_duplicates:
                f.write(f"| {name} | {count} |\n")
                
        print(f"å ±å‘Šå·²ç”Ÿæˆæ–¼ï¼š{report_file}")
        logging.info(f"å ±å‘Šå·²ç”Ÿæˆæ–¼ï¼š{report_file}")

    except Exception as e:
        logging.error(f"åˆä½µ Parquet æˆ–ç”Ÿæˆå ±å‘Šå¤±æ•—: {e}")
        traceback.print_exc()

if __name__ == '__main__':
    main()
```

---

### ğŸ“„ File: `tests\__init__.py`

```python
# app/routes/__init__.py
```

---

### ğŸ“„ File: `tools\code_merger.py`

```python
# tools/code_merger.py
# -*- coding: utf-8 -*-
"""
å°ˆæ¡ˆåç¨±ï¼šASBL-Basketball-Manager (ç±ƒçƒæ•¸æ“šéŠæˆ²)
æ¨¡çµ„åç¨±ï¼šç¨‹å¼ç¢¼åˆä½µå·¥å…· (Code Merger)
åŠŸèƒ½æè¿°ï¼š
    æ­¤è…³æœ¬ç”¨æ–¼å°‡å°ˆæ¡ˆä¸­æŒ‡å®šçš„ã€Œæ ¸å¿ƒé‚è¼¯ã€èˆ‡ã€Œè¦æ ¼æ–‡ä»¶ã€åˆä½µç‚ºå–®ä¸€æ–‡å­—æª”ã€‚
    ä¾¿æ–¼é–‹ç™¼è€…é€²è¡Œä¸Šä¸‹æ–‡æª¢è¦–æˆ–æä¾›çµ¦ AI é€²è¡Œæ¶æ§‹å¯©æŸ¥ã€‚
    
ä½¿ç”¨èªªæ˜ï¼š
    1. è«‹å°‡æ­¤æª”æ¡ˆæ”¾ç½®æ–¼å°ˆæ¡ˆæ ¹ç›®éŒ„ä¸‹çš„ tools/ è³‡æ–™å¤¾ä¸­ã€‚
    2. æ–¼å°ˆæ¡ˆæ ¹ç›®éŒ„åŸ·è¡ŒæŒ‡ä»¤ï¼špython tools/code_merger.py
    
ä½œè€…ï¼šMonica (AI Assistant)
æ—¥æœŸï¼š2026-01-04
"""

import os

# ==========================================
# é…ç½®å€åŸŸ (Configuration)
# ==========================================

# å°ˆæ¡ˆæ ¹ç›®éŒ„ (å‡è¨­æ­¤è…³æœ¬ä½æ–¼ tools/ ç›®éŒ„ä¸‹ï¼Œæ•…å‘ä¸Šå°‹æ‰¾å…©å±¤)
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# è¼¸å‡ºæª”æ¡ˆåç¨±
OUTPUT_FILE = "project_context.txt"

# æŒ‡å®šè¦åŒ…å«çš„æª”æ¡ˆæ¸…å–® (ç™½åå–®)
# ä¾æ“š ASBL å°ˆæ¡ˆçµæ§‹é…ç½®ï¼ŒåŒ…å«æ ¸å¿ƒå¼•æ“ã€ç”Ÿæˆå™¨ã€è¨­å®šæª”èˆ‡è¦æ ¼æ›¸
SPECIFIC_FILES = [
    # --- æ–‡ä»¶ (Documentation) ---
    "ASBL_Match_Engine_Specification.md",
    "ASBL_Player_System_Specification.md",

    # --- è¨­å®šæª” (Configuration) ---
    "config/game_config.yaml",
    "config.py",
    "run.py",

    # --- æ‡‰ç”¨ç¨‹å¼æ¨¡çµ„å±¤ (App Models) ---
    "app/models/player.py",
    "app/models/system.py",
    "app/models/user.py",

    # --- æ‡‰ç”¨ç¨‹å¼æœå‹™å±¤ (App Services) ---
    "app/services/player_generator.py",
    "app/services/team_creator.py",

    # --- æ¯”è³½å¼•æ“æ ¸å¿ƒ (Match Engine Core) ---
    "app/services/match_engine/core.py",
    "app/services/match_engine/service.py",
    "app/services/match_engine/structures.py",

    # --- æ¯”è³½å¼•æ“å­ç³»çµ± (Match Engine Systems) ---
    "app/services/match_engine/systems/attribution.py",
    "app/services/match_engine/systems/play_logic.py",
    "app/services/match_engine/systems/stamina.py",
    "app/services/match_engine/systems/substitution.py",

    # --- æ¯”è³½å¼•æ“å·¥å…· (Match Engine Utils) ---
    "app/services/match_engine/utils/calculator.py",
    "app/services/match_engine/utils/rng.py",

    # --- æ¸¬è©¦å·¥å…· (Test Utils) ---
    "tests/match_bigdata_test/run_core_bigdata_test.py",
    "tests/player_generator_big_data/analyzer.py",
    "tests/player_generator_big_data/check_data_integrity.py",
    "tests/player_generator_big_data/run_test.py",
    "tests/player_generator_big_data/test_config.yaml",
    "tests/team_bigdata_test/manual_merge.py",
    "tests/team_bigdata_test/run_simulation.py",

    # --- é–‹ç™¼ç´€éŒ„ (DEV_LOG.md) ---
    "DEV_LOG.md",
]

# ==========================================
# ä¸»ç¨‹å¼é‚è¼¯ (Main Logic)
# ==========================================

def merge_files():
    """
    åŸ·è¡Œæª”æ¡ˆåˆä½µä½œæ¥­
    """
    output_path = os.path.join(PROJECT_ROOT, OUTPUT_FILE)
    total_files = 0
    missing_files = []
    
    print(f"ğŸš€ [ASBL] é–‹å§‹åŸ·è¡Œç¨‹å¼ç¢¼åˆä½µä½œæ¥­...")
    print(f"ğŸ“‚ å°ˆæ¡ˆæ ¹ç›®éŒ„: {PROJECT_ROOT}")
    print(f"ğŸ“„ ç›®æ¨™æª”æ¡ˆæ•¸: {len(SPECIFIC_FILES)}")
    
    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            # å¯«å…¥æª”é ­è³‡è¨Š
            outfile.write(f"ASBL Basketball Manager - å°ˆæ¡ˆç¨‹å¼ç¢¼åŒ¯ç¸½\n")
            outfile.write(f"ç”Ÿæˆæ™‚é–“: {os.popen('date').read().strip() if os.name != 'nt' else 'N/A'}\n")
            outfile.write("=" * 60 + "\n\n")

            # éæ­·æŒ‡å®šæ¸…å–®é€²è¡Œè™•ç†
            for rel_path in SPECIFIC_FILES:
                full_path = os.path.join(PROJECT_ROOT, rel_path)
                
                if os.path.exists(full_path):
                    process_file(full_path, outfile, PROJECT_ROOT)
                    total_files += 1
                else:
                    print(f"âš ï¸  è­¦å‘Š: æ‰¾ä¸åˆ°æª”æ¡ˆ -> {rel_path}")
                    missing_files.append(rel_path)
                    # å³ä½¿æª”æ¡ˆéºå¤±ï¼Œä¹Ÿåœ¨è¼¸å‡ºæª”ä¸­æ¨™è¨˜ï¼Œä»¥ä¾¿é–‹ç™¼è€…å¯Ÿè¦º
                    outfile.write(f"File: {rel_path}\n")
                    outfile.write(f"!!! FILE NOT FOUND !!!\n")
                    outfile.write("\n" + "=" * 60 + "\n\n")

        print(f"\nâœ… åˆä½µå®Œæˆï¼")
        print(f"ğŸ“Š æˆåŠŸè™•ç†: {total_files}/{len(SPECIFIC_FILES)} å€‹æª”æ¡ˆ")
        
        if missing_files:
            print(f"âŒ éºå¤±æª”æ¡ˆåˆ—è¡¨:")
            for mf in missing_files:
                print(f"   - {mf}")
                
        print(f"ğŸ’¾ è¼¸å‡ºæª”æ¡ˆä½ç½®: {output_path}")

    except Exception as e:
        print(f"\nâŒ ç™¼ç”Ÿè‡´å‘½éŒ¯èª¤: {str(e)}")

def process_file(file_path, outfile, root_path):
    """
    è®€å–å–®å€‹æª”æ¡ˆä¸¦å¯«å…¥è¼¸å‡ºæª”
    
    Args:
        file_path (str): æª”æ¡ˆçµ•å°è·¯å¾‘
        outfile (file object): è¼¸å‡ºæª”æ¡ˆç‰©ä»¶
        root_path (str): å°ˆæ¡ˆæ ¹ç›®éŒ„
    """
    rel_path = os.path.relpath(file_path, root_path)
    print(f"   æ­£åœ¨è™•ç†: {rel_path}")
    
    outfile.write(f"File: {rel_path}\n")
    outfile.write("-" * 60 + "\n")
    
    try:
        with open(file_path, 'r', encoding='utf-8') as infile:
            content = infile.read()
            outfile.write(content)
    except UnicodeDecodeError:
        outfile.write(f"[éŒ¯èª¤: ç„¡æ³•ä»¥ UTF-8 æ ¼å¼è®€å–æ­¤æª”æ¡ˆï¼Œå¯èƒ½æ˜¯äºŒé€²åˆ¶æ–‡ä»¶]\n")
    except Exception as e:
        outfile.write(f"[éŒ¯èª¤: è®€å–æª”æ¡ˆæ™‚ç™¼ç”Ÿç•°å¸¸ - {str(e)}]\n")
        
    outfile.write("\n\n" + "=" * 60 + "\n\n")

if __name__ == "__main__":
    merge_files()
```

---

### ğŸ“„ File: `ASBL_Database_Schema.md`

```markdown
# ASBL è³‡æ–™åº«æ¶æ§‹è¦æ ¼æ›¸ (Database Schema Specification)

**ç‰ˆæœ¬**: 1.1
**æœ€å¾Œæ›´æ–°**: 2026-02-16
**èªªæ˜**: æœ¬æ–‡ä»¶å®šç¾© ASBL ç±ƒçƒç¶“ç†éŠæˆ²çš„æ ¸å¿ƒè³‡æ–™åº«çµæ§‹ï¼Œå°æ‡‰ SQLAlchemy Models èˆ‡å¯¦éš› DDLã€‚

---

## 1. å¯¦é«”é—œè¯åœ– (ER Diagram)

```mermaid
erDiagram
    USERS ||--|| TEAMS : owns
    TEAMS ||--|{ PLAYERS : has
    TEAMS ||--|{ CONTRACTS : pays
    PLAYERS ||--|| CONTRACTS : signs
    PLAYERS ||--|{ PLAYER_GROWTH_LOGS : tracks

    USERS {
        int id PK
        string username
        string email
        string password_hash
    }

    TEAMS {
        int id PK
        int user_id FK
        string name
        bigint funds
        int reputation
    }

    PLAYERS {
        int id PK
        int team_id FK
        string name
        string nationality
        string grade "New v1.1"
        int age
        int height
        string position
        int rating
        json detailed_stats "ç•¶å‰èƒ½åŠ›å€¼"
        json initial_stats "åˆå§‹/å·”å³°èƒ½åŠ›å€¼"
        int training_points "å¯ç”¨è¨“ç·´é»æ•¸"
    }

    CONTRACTS {
        int id PK
        int player_id FK
        int team_id FK
        int salary
        int years
        int years_left
        string role
    }

    PLAYER_GROWTH_LOGS {
        int id PK
        int player_id FK
        int season_id
        string event_type
        json change_delta
        datetime created_at
    }

    SYSTEM_NAME_LIBRARY {
        int id PK
        string language
        string category
        string content
        int weight
        int length
    }
```

---

## 2. è³‡æ–™è¡¨è©³æƒ… (Table Details)

### 2.1 Users (ä½¿ç”¨è€…)
| æ¬„ä½åç¨± | é¡å‹ | å±¬æ€§ | èªªæ˜ |
| :--- | :--- | :--- | :--- |
| `id` | Integer | PK, Auto Inc | ä½¿ç”¨è€… ID |
| `username` | String(64) | Unique, Not Null | å¸³è™Ÿåç¨± |
| `email` | String(120) | Unique, Not Null | é›»å­ä¿¡ç®± |
| `password_hash` | String(256) | Nullable | åŠ å¯†å¯†ç¢¼ (DDL å…è¨±ç‚ºç©ºï¼Œé‚è¼¯ä¸Šæ‡‰å¿…å¡«) |
| `created_at` | DateTime | Nullable | è¨»å†Šæ™‚é–“ (ç”± App å¯«å…¥) |

### 2.2 Teams (çƒéšŠ)
| æ¬„ä½åç¨± | é¡å‹ | å±¬æ€§ | èªªæ˜ |
| :--- | :--- | :--- | :--- |
| `id` | Integer | PK, Auto Inc | çƒéšŠ ID |
| `user_id` | Integer | FK(users.id), Unique | æ“æœ‰è€… ID |
| `name` | String(64) | Not Null | çƒéšŠåç¨± |
| `funds` | BigInteger | Nullable | çƒéšŠè³‡é‡‘ (App é è¨­ 10000000) |
| `reputation` | Integer | Nullable | çƒéšŠè²æœ› (App é è¨­ 100) |

### 2.3 Players (çƒå“¡)
*è¨­è¨ˆé‡é»ï¼šé‡å°è€åŒ–æ©Ÿåˆ¶ï¼Œä¿ç•™ `initial_stats` ä½œç‚ºå°ç…§çµ„ã€‚*

| æ¬„ä½åç¨± | é¡å‹ | å±¬æ€§ | èªªæ˜ |
| :--- | :--- | :--- | :--- |
| `id` | Integer | PK, Auto Inc | çƒå“¡ ID |
| `team_id` | Integer | FK(teams.id), Nullable | æ‰€å±¬çƒéšŠ (è‡ªç”±çƒå“¡ç‚º Null) |
| `name` | String(64) | Not Null | å§“å |
| `nationality` | String(16) | Not Null | åœ‹ç±/èªç³» (App é è¨­ 'zh') |
| `grade` | String(5) | Not Null | **[v1.1 æ–°å¢]** çƒå“¡ç­‰ç´š (SSR, SS, S...) |
| `age` | Integer | Nullable | å¹´é½¡ (App é è¨­ 18) |
| `height` | Integer | Not Null | èº«é«˜ (cm) |
| `position` | String(10) | Not Null | è¨»å†Šä½ç½® (C, PF, SF, SG, PG) |
| `rating` | Integer | Nullable | ç¶œåˆè©•åƒ¹åˆ†æ•¸ |
| `detailed_stats` | **JSON** | Not Null | **ç•¶å‰èƒ½åŠ›å€¼** (æ¯”è³½å¼•æ“è®€å–æ­¤æ¬„ä½) |
| `initial_stats` | **JSON** | Nullable | **åˆå§‹/å·”å³°èƒ½åŠ›å€¼** (ç”¨æ–¼è¨ˆç®—è€åŒ–è¡°é€€å¹…åº¦) |
| `training_points`| Integer | Not Null | **è¨“ç·´é»æ•¸** (ç”¨æ–¼å‡ç´šæˆ–ç¶­æŒèƒ½åŠ›) |
| `created_at` | DateTime | Default Now | ç”Ÿæˆæ™‚é–“ |

> **è€åŒ–æ©Ÿåˆ¶è¨­è¨ˆèªªæ˜**:
> ç•¶çƒå“¡é€²å…¥è€åŒ–æœŸï¼Œç³»çµ±æœƒæ¯”è¼ƒ `detailed_stats` èˆ‡ `initial_stats`ã€‚
> è‹¥ `detailed_stats` ä¸­çš„é‹å‹•èƒ½åŠ›ä¸‹é™ï¼Œç©å®¶å¯æ¶ˆè€— `training_points` å°‡å…¶è£œå›ï¼Œä¸Šé™ä¸è¶…é `initial_stats` (é™¤éæ˜¯æŠ€è¡“æˆé•·)ã€‚

### 2.4 Contracts (åˆç´„)
| æ¬„ä½åç¨± | é¡å‹ | å±¬æ€§ | èªªæ˜ |
| :--- | :--- | :--- | :--- |
| `id` | Integer | PK, Auto Inc | åˆç´„ ID |
| `player_id` | Integer | FK(players.id), Unique | çƒå“¡ ID |
| `team_id` | Integer | FK(teams.id) | çƒéšŠ ID (å†—é¤˜å„²å­˜ä»¥åˆ©æŸ¥è©¢) |
| `salary` | Integer | Not Null | è³½å­£è–ªè³‡ |
| `years` | Integer | Nullable | ç¸½åˆç´„å¹´é™ (App é è¨­ 1) |
| `years_left` | Integer | Nullable | å‰©é¤˜å¹´é™ (App é è¨­ 1) |
| `role` | String(20) | Not Null | è§’è‰²å®šä½ (Star, Starter...) |
| `option_type` | String(10)| Nullable | çƒå“¡/çƒéšŠé¸é … (PO/TO) |

### 2.5 Player Growth Logs (çƒå“¡æˆé•·/è€åŒ–ç´€éŒ„)
*ç”¨é€”ï¼šè¨˜éŒ„çƒå“¡æ¯ä¸€å­£æˆ–æ¯æ¬¡è¨“ç·´çš„æ•¸å€¼è®Šå‹•ï¼Œæ–¹ä¾¿è¿½æº¯æ­·å²ã€‚*

| æ¬„ä½åç¨± | é¡å‹ | å±¬æ€§ | èªªæ˜ |
| :--- | :--- | :--- | :--- |
| `id` | Integer | PK, Auto Inc | ç´€éŒ„ ID |
| `player_id` | Integer | FK(players.id) | çƒå“¡ ID |
| `season_id` | Integer | Not Null | ç™¼ç”Ÿè³½å­£ |
| `event_type` | String(20) | Not Null | é¡å‹: 'AGE_DECLINE'(è€åŒ–), 'TRAINING'(è¨“ç·´) |
| `change_delta` | JSON | Not Null | è®Šå‹•æ•¸å€¼ (ä¾‹å¦‚: `{"speed": -2, "strength": -1}`) |
| `created_at` | DateTime | Default Now | ç´€éŒ„æ™‚é–“ |

### 2.6 System Name Library (ç³»çµ±å§“ååº«)
*å°æ‡‰è³‡æ–™è¡¨: `system_name_library`*

| æ¬„ä½åç¨± | é¡å‹ | å±¬æ€§ | èªªæ˜ |
| :--- | :--- | :--- | :--- |
| `id` | Integer | PK, Auto Inc, Unsigned | å”¯ä¸€è­˜åˆ¥ç¢¼ |
| `language` | String(16) | Not Null | èªç³»ä»£ç¢¼ (en, zh, jp...) |
| `category` | String(16) | Not Null | é¡åˆ¥ (surname, given_name) |
| `content` | String(64) | Not Null | åå­—å…§å®¹ |
| `length` | Integer | Nullable | **[v1.1 ä¿®æ­£]** å…§å®¹å­—æ•¸ (ç”± App è¨ˆç®—å¯«å…¥) |
| `weight` | Integer | Default 10, Unsigned | å‡ºç¾æ¬Šé‡ |
```

---

### ğŸ“„ File: `ASBL_League_Simulation_Design.md`

```markdown
# ASBL è¯è³½è³½å­£æ¨¡æ“¬ç³»çµ±è¨­è¨ˆæ–‡ä»¶ (League Simulation Design Document)

**ç‰ˆæœ¬**: 1.7 (Final with Spec-Compliant Attributes)
**æ—¥æœŸ**: 2025-12-24
**ç‹€æ…‹**: å¾…å¯¦ä½œ (Ready for Implementation)

---

## 1. ç³»çµ±æ¦‚è¿° (Overview)
æœ¬ç³»çµ±æ—¨åœ¨åˆ©ç”¨ç¾æœ‰çš„ `TeamCreator` (çƒå“¡ç”Ÿæˆ) èˆ‡ `MatchEngine` (æ¯”è³½å¼•æ“)ï¼Œæ¨¡æ“¬ ASBL è¯ç›Ÿ 36 æ”¯çƒéšŠçš„å®Œæ•´è³½å­£é‹ä½œã€‚

**æ ¸å¿ƒç›®æ¨™**ï¼š
1.  é©—è­‰æ¯”è³½å¼•æ“åœ¨å¤§è¦æ¨¡æ¨£æœ¬ä¸‹çš„æ•¸æ“šç©©å®šæ€§ (Pace, FG%, Score)ã€‚
2.  å»ºç«‹é•·æœŸè¿½è¹¤æ©Ÿåˆ¶ï¼Œè§€å¯Ÿçƒå“¡èƒ½åŠ›å€¼åˆ†ä½ˆå°æ¯”è³½æ•¸æ“šçš„å½±éŸ¿ã€‚
3.  **é©—è­‰é«”åŠ›ç³»çµ±å¹³è¡¡æ€§**ï¼šåˆ†æå€‹åˆ¥çƒå“¡çš„ä¸Šå ´æ™‚é–“èˆ‡å‰©é¤˜é«”åŠ›ä¹‹é—œè¯ã€‚
4.  **è¿½è¹¤çƒå“¡æµå‹•**ï¼šè¨˜éŒ„çƒå“¡çš„åŠ å…¥èˆ‡é›¢é–‹ï¼ˆé¸ç§€ã€è£å“¡ï¼‰ã€‚

---

## 2. è®Šæ›´æ­·ç¨‹ (Change Log)
è¨˜éŒ„å¾åˆç‰ˆéœ€æ±‚åˆ°å®šæ¡ˆçš„è¨è«–éç¨‹ã€‚

### v1.0 ~ v1.3 (å‰æœŸè¦åŠƒ)
*   ç¢ºç«‹ 36 éšŠã€1307 å ´æ¯”è³½ (ä¾‹è¡Œè³½+å­£å¾Œè³½) çš„è¦æ¨¡ã€‚
*   ç¢ºç«‹çƒå“¡ 8 ä½æ•¸éš¨æ©Ÿç·¨è™Ÿæ©Ÿåˆ¶ã€‚
*   ç¢ºç«‹å­£å¾Œè³½å¼·åˆ¶æ‰“æ»¿ã€ä¼‘è³½å­£è£äºº (Drop) æ©Ÿåˆ¶ã€‚
*   åŠ å…¥å›åˆæ•¸ (Possessions) èˆ‡é«”åŠ›è¿½è¹¤ã€‚

### v1.4 (é«”åŠ›è¿½è¹¤ä¿®æ­£)
*   ä¿®æ­£é«”åŠ›è¿½è¹¤ç¶­åº¦è‡³ã€Œçƒå“¡å±¤ç´šã€ï¼Œé©—è­‰ä¸Šå ´æ™‚é–“èˆ‡å‰©é¤˜é«”åŠ›çš„é—œä¿‚ã€‚

### v1.5 (äº¤æ˜“è¨˜éŒ„èˆ‡ä¸­æ–‡åŒ–)
*   æ–°å¢ `roster_transactions.parquet`ã€‚
*   æ¬„ä½èªªæ˜å…¨é¢ä¸­æ–‡åŒ–ã€‚

### v1.6 (è©³ç´°èƒ½åŠ›å€¼)
*   åœ¨ `player_stats.parquet` ä¸­åŠ å…¥è©³ç´°èƒ½åŠ›å€¼ã€‚

### v1.7 (èƒ½åŠ›å€¼è¦æ ¼å°é½Š - Current)
*   **ä¿®æ­£æ¬„ä½**: ä¾æ“š ASBL v3.2 è¦æ ¼æ›¸ï¼Œå°‡èƒ½åŠ›å€¼æ¬„ä½ç²¾ç¢ºæ‹†åˆ†ç‚º 10 é …å¯è¨“ç·´èƒ½åŠ›èˆ‡ 10 é …ä¸å¯è¨“ç·´èƒ½åŠ›ã€‚

---

## 3. åŸ·è¡Œæµç¨‹ (Execution Flow)

### Phase 1: è¯ç›Ÿåˆå§‹åŒ– (Initialization)
*(åƒ…åœ¨æ¨¡æ“¬é–‹å§‹æ™‚åŸ·è¡Œä¸€æ¬¡)*

1.  **å»ºç«‹çƒéšŠ**: ç”¢ç”Ÿ `TEAM_01` ~ `TEAM_36` å…± 36 å€‹çƒéšŠç‰©ä»¶ã€‚
2.  **ç”Ÿæˆçƒå“¡**:
    *   å‘¼å« `TeamCreator.create_valid_roster()` ç”Ÿæˆ 15 äººåå–®ã€‚
    *   **æ³¨å…¥ ID**: ç‚ºæ¯ä½çƒå“¡ç”Ÿæˆå”¯ä¸€ `8ä½æ•¸éš¨æ©Ÿç·¨è™Ÿ` (Key)ã€‚
    *   **ç‰©ä»¶è½‰æ›**: å°‡ Payload è½‰ç‚º `EnginePlayer`ã€‚
    *   **è¨˜éŒ„ç•°å‹•**: å¯«å…¥ `INITIAL` é¡å‹çš„äº¤æ˜“ç´€éŒ„ã€‚
3.  **åå–®ç¢ºèª**: ä¾ `attr_sum` (èƒ½åŠ›ç¸½å’Œ) æ’åºï¼Œæäº¤æœ€å¼· 15 äººåå–®çµ¦å¼•æ“ã€‚

### Phase 2: ä¾‹è¡Œè³½æ¨¡æ“¬ (Regular Season)
*(å…± 1260 å ´æ¯”è³½)*

1.  **è³½ç¨‹ç”¢ç”Ÿ**: 36 éšŠé›™å¾ªç’° (Double Round-Robin)ï¼Œéš¨æ©Ÿæ‰“äº‚é †åºã€‚
2.  **æ¯”è³½åŸ·è¡Œ**:
    *   é€å ´å‘¼å« `MatchEngine.simulate()`ã€‚
    *   **æ•¸æ“šå¯«å…¥**:
        *   æ›´æ–°çƒéšŠæˆ°ç¸¾ (Wins, Losses, PF, PA, Possessions)ã€‚
        *   ç´¯ç©çƒå“¡ **ä¾‹è¡Œè³½æ•¸æ“š** (Regular Stats)ã€‚
        *   **ç´¯ç©é«”åŠ›æ•¸æ“š**: è¨˜éŒ„æ¯ä½çƒå“¡è©²å ´æ¯”è³½çµæŸæ™‚çš„ `current_stamina`ã€‚

### Phase 3: å­£å¾Œè³½æ¨¡æ“¬ (Playoffs)
*(å…± 47 å ´æ¯”è³½ - å¼·åˆ¶æ‰“æ»¿)*

1.  **ç¨®å­æ’åº**: ä¾ `å‹ç‡ > æ·¨åˆ†å·®` å–å‰ 16 åã€‚
2.  **ç³»åˆ—è³½åŸ·è¡Œ**:
    *   **R1 (16å¼·)**: 8 çµ„ x 3 å ´ã€‚
    *   **R2 (8å¼·)**: 4 çµ„ x 3 å ´ã€‚
    *   **R3 (4å¼·)**: 2 çµ„ x 3 å ´ã€‚
    *   **Finals**: 1 çµ„ x 5 å ´ã€‚
3.  **æ•¸æ“šå¯«å…¥**:
    *   ç´¯ç©çƒå“¡ **å­£å¾Œè³½æ•¸æ“š** (Playoff Stats)ã€‚

### Phase 4: ä¼‘è³½å­£æ¼”ç·´ (Offseason - Future Prep)
*(ç‚ºå¤šè³½å­£æ¸¬è©¦åšæº–å‚™)*

1.  **é¸ç§€ (Draft)**:
    *   ç”Ÿæˆ 36 åæ–°ç§€ã€‚
    *   ä¾ä¾‹è¡Œè³½æˆ°ç¸¾ **å€’åº** åˆ†é…ã€‚
    *   **è¨˜éŒ„ç•°å‹•**: å¯«å…¥ `DRAFT` é¡å‹çš„äº¤æ˜“ç´€éŒ„ã€‚
2.  **åå–®èª¿æ•´ (Roster Cut)**:
    *   å…¨éšŠæ’åº (16äºº)ã€‚
    *   ä¿ç•™å‰ 15 å¼·ã€‚
    *   **å¼·åˆ¶åˆè¦æª¢æŸ¥**: è‹¥ Star > 3 æˆ– Star+Starter > 5ï¼Œç›´æ¥**æ‹‹æ£„**èƒ½åŠ›æœ€ä½çš„é•è¦çƒå“¡ï¼Œç”±ç¬¬ 16 äººéè£œã€‚
    *   **è¨˜éŒ„ç•°å‹•**: é‡å°è¢«æ‹‹æ£„çš„çƒå“¡ï¼Œå¯«å…¥ `DROP` é¡å‹çš„äº¤æ˜“ç´€éŒ„ã€‚

---

## 4. æª”æ¡ˆè¼¸å‡ºè¦æ ¼ (Output Schema)
æ‰€æœ‰æª”æ¡ˆçš†è¼¸å‡ºç‚º `.parquet` æ ¼å¼ (Snappy Compression)ã€‚

### A. è³½å­£ç¸½çµå ±å‘Š (`season_summary.parquet`)
*   **ç”¨é€”**: è¿½è¹¤è¯ç›Ÿæ•´é«”çš„è¶¨å‹¢è®ŠåŒ– (Macro Level)ã€‚
*   **æ¬„ä½èªªæ˜**:
    *   `season_id`: **è³½å­£ç·¨è™Ÿ** (ä¾‹å¦‚: 1, 2, 3...)
    *   `total_games`: **ç¸½å ´æ¬¡** (è©²å­£é€²è¡Œçš„ç¸½æ¯”è³½å ´æ•¸)
    *   `avg_attr_sum`: **å¹³å‡èƒ½åŠ›ç¸½å’Œ** (å…¨è¯ç›Ÿæ‰€æœ‰çƒå“¡çš„èƒ½åŠ›å€¼å¹³å‡)
    *   `avg_pace`: **å¹³å‡ç¯€å¥** (å…¨è¯ç›Ÿæ¯ 48 åˆ†é˜çš„å¹³å‡å›åˆæ•¸)
    *   `avg_pts`: **å ´å‡å¾—åˆ†** (å…¨è¯ç›Ÿå¹³å‡æ¯å ´å¾—åˆ†)
    *   `avg_fg_pct`: **å¹³å‡æŠ•ç±ƒå‘½ä¸­ç‡** (å…¨è¯ç›Ÿ FG%)
    *   `avg_3p_pct`: **å¹³å‡ä¸‰åˆ†å‘½ä¸­ç‡** (å…¨è¯ç›Ÿ 3P%)
    *   `avg_end_stamina`: **å¹³å‡è³½å¾Œå‰©é¤˜é«”åŠ›** (å…¨è¯ç›Ÿæ¯”è³½çµæŸæ™‚çš„å¹³å‡é«”åŠ›ï¼Œç”¨æ–¼ç›£æ§é«”åŠ›æ¶ˆè€—)

### B. çƒéšŠæˆ°ç¸¾è¡¨ (`team_standings.parquet`)
*   **ç”¨é€”**: è¨˜éŒ„å„éšŠè³½å­£è¡¨ç¾ã€‚
*   **æ¬„ä½èªªæ˜**:
    *   `season_id`: **è³½å­£ç·¨è™Ÿ**
    *   `team_id`: **éšŠä¼ä»£ç¢¼** (ä¾‹å¦‚: TEAM_01)
    *   `wins`: **å‹å ´æ•¸**
    *   `losses`: **æ•—å ´æ•¸**
    *   `win_pct`: **å‹ç‡**
    *   `pf`: **ç¸½å¾—åˆ†** (Points For)
    *   `pa`: **ç¸½å¤±åˆ†** (Points Against)
    *   `diff`: **æ·¨åˆ†å·®** (PF - PA)
    *   `possessions`: **è³½å­£ç¸½å›åˆæ•¸** (ç”¨æ–¼è¨ˆç®—é€²éšæ•¸æ“š)
    *   `rank_seed`: **ä¾‹è¡Œè³½æ’å** (1-36)
    *   `playoff_result`: **å­£å¾Œè³½æœ€çµ‚æˆç¸¾** (Champion, Finals, R2, R1, None)

### C. çƒå“¡è³½å­£æ•¸æ“šè¡¨ (`player_stats.parquet`)
*   **ç”¨é€”**: è¨˜éŒ„çƒå“¡å€‹äººæ•¸æ“š (Micro Level)ï¼Œå«è©³ç´°èƒ½åŠ›å€¼èˆ‡é«”åŠ›è¿½è¹¤ã€‚
*   **æ¬„ä½èªªæ˜**:
    *   `season_id`: **è³½å­£ç·¨è™Ÿ**
    *   `player_id`: **çƒå“¡è­˜åˆ¥ç¢¼** (8ä½æ•¸éš¨æ©Ÿç·¨è™Ÿ, Key)
    *   `name`: **çƒå“¡å§“å**
    *   `team_id`: **æ‰€å±¬çƒéšŠ**
    *   `grade`: **çƒå“¡ç­‰ç´š** (SSR, SS, S, A, B)
    *   `role`: **çƒéšŠè§’è‰²** (Star, Starter, Rotation, Bench)
    *   `attr_sum`: **èƒ½åŠ›ç¸½å’Œ** (Trainable + Untrainable)
    *   **[Trainable Stats - å¯è¨“ç·´èƒ½åŠ›]** (v3.2 Spec):
        *   `attr_shot_accuracy`: **æŠ•ç±ƒæº–å¿ƒ**
        *   `attr_shot_range`: **å°„ç¨‹**
        *   `attr_off_pass`: **å‚³çƒ**
        *   `attr_off_dribble`: **é‹çƒ**
        *   `attr_off_handle`: **æ§çƒ**
        *   `attr_off_move`: **è·‘ä½**
        *   `attr_def_rebound`: **ç±ƒæ¿**
        *   `attr_def_boxout`: **å¡ä½**
        *   `attr_def_contest`: **å¹²æ“¾**
        *   `attr_def_disrupt`: **æŠ„æˆª**
    *   **[Untrainable Stats - ä¸å¯è¨“ç·´èƒ½åŠ›]** (v3.2 Spec):
        *   `attr_ath_stamina`: **é«”åŠ›**
        *   `attr_ath_strength`: **åŠ›é‡**
        *   `attr_ath_speed`: **é€Ÿåº¦**
        *   `attr_ath_jump`: **å½ˆè·³**
        *   `attr_talent_health`: **å¥åº·**
        *   `attr_shot_touch`: **æ‰‹æ„Ÿ**
        *   `attr_shot_release`: **å‡ºæ‰‹é€Ÿåº¦**
        *   `attr_talent_offiq`: **é€²æ”»æ™ºå•†**
        *   `attr_talent_defiq`: **é˜²å®ˆæ™ºå•†**
        *   `attr_talent_luck`: **é‹æ°£**
    *   **[Regular Season Stats - ä¾‹è¡Œè³½æ•¸æ“š]**:
        *   `reg_gp`: **å‡ºè³½å ´æ¬¡**
        *   `reg_min`: **ç¸½ä¸Šå ´æ™‚é–“**
        *   `reg_avg_min`: **å¹³å‡ä¸Šå ´æ™‚é–“**
        *   `reg_avg_end_stamina`: **å¹³å‡è³½å¾Œå‰©é¤˜é«”åŠ›** (é©—è­‰é«˜å·¥æ™‚æ˜¯å¦å°è‡´ä½é«”åŠ›)
        *   `reg_pts`: **ç¸½å¾—åˆ†**
        *   `reg_reb`: **ç¸½ç±ƒæ¿**
        *   `reg_ast`: **ç¸½åŠ©æ”»**
        *   `reg_stl`: **ç¸½æŠ„æˆª**
        *   `reg_blk`: **ç¸½ç«é‹**
        *   `reg_fgm`: **æŠ•ç±ƒå‘½ä¸­æ•¸**
        *   `reg_fga`: **æŠ•ç±ƒå‡ºæ‰‹æ•¸**
        *   `reg_3pm`: **ä¸‰åˆ†å‘½ä¸­æ•¸**
        *   `reg_3pa`: **ä¸‰åˆ†å‡ºæ‰‹æ•¸**
    *   **[Playoff Stats - å­£å¾Œè³½æ•¸æ“š]**:
        *   `po_gp`: **å‡ºè³½å ´æ¬¡**
        *   `po_min`: **ç¸½ä¸Šå ´æ™‚é–“**
        *   `po_avg_end_stamina`: **å¹³å‡è³½å¾Œå‰©é¤˜é«”åŠ›**
        *   `po_pts` ~ `po_3pa`: (åŒä¸Šï¼Œå­£å¾Œè³½ç‰ˆæœ¬)

### D. æ¯”è³½çµæœæ˜ç´°è¡¨ (`match_results.parquet`)
*   **ç”¨é€”**: 1307 å ´æ¯”è³½çš„æµæ°´å¸³ã€‚
*   **æ¬„ä½èªªæ˜**:
    *   `season_id`: **è³½å­£ç·¨è™Ÿ**
    *   `game_id`: **æ¯”è³½è­˜åˆ¥ç¢¼** (ä¾‹å¦‚: S1_REG_0001)
    *   `stage`: **æ¯”è³½éšæ®µ** (Regular / Playoff)
    *   `home_team`: **ä¸»éšŠä»£ç¢¼**
    *   `away_team`: **å®¢éšŠä»£ç¢¼**
    *   `home_score`: **ä¸»éšŠå¾—åˆ†**
    *   `away_score`: **å®¢éšŠå¾—åˆ†**
    *   `winner`: **å‹æ–¹ä»£ç¢¼**
    *   `pace`: **æ¯”è³½ç¯€å¥** (è©²å ´æ¯”è³½æ¯ 48 åˆ†é˜å›åˆæ•¸)
    *   `possessions`: **ç¸½å›åˆæ•¸** (è©²å ´æ¯”è³½å¯¦éš›å›åˆæ•¸)
    *   `is_ot`: **æ˜¯å¦å»¶é•·è³½** (True/False)

### E. çƒå“¡æµå‹•è¨˜éŒ„è¡¨ (`roster_transactions.parquet`)
*   **ç”¨é€”**: è¿½è¹¤çƒå“¡çš„é€²å‡ºç‹€æ³ã€‚
*   **æ¬„ä½èªªæ˜**:
    *   `season_id`: **è³½å­£ç·¨è™Ÿ**
    *   `team_id`: **ç›¸é—œçƒéšŠä»£ç¢¼**
    *   `player_id`: **çƒå“¡è­˜åˆ¥ç¢¼**
    *   `player_name`: **çƒå“¡å§“å**
    *   `transaction_type`: **ç•°å‹•é¡å‹**
        *   `INITIAL`: è¯ç›Ÿå‰µç«‹æ™‚çš„åˆå§‹åˆ†é…
        *   `DRAFT`: é¸ç§€æœƒé¸ä¸­åŠ å…¥
        *   `DROP`: å› åå–®é™åˆ¶è¢«è£å“¡/æ‹‹æ£„
    *   `timestamp`: **ç™¼ç”Ÿæ™‚é–“é»** (ä¾‹å¦‚: "Pre-Season", "Offseason")
```

---

### ğŸ“„ File: `ASBL_Match_Engine_Specification.md`

```markdown
# ASBL æ¯”è³½å¼•æ“è¦æ ¼æ›¸ (v2.4) ASBL_Match_Engine_Specification.md

**ç‰ˆæœ¬**ï¼š2.4
**ç‹€æ…‹**ï¼šå·²ç¢ºèª (Confirmed)
**æœ€å¾Œæ›´æ–°**2026-01-23
**è®Šæ›´è¨˜éŒ„**ï¼š
*   **v1.0 (2025-12-04)**ï¼šåˆå§‹ç‰ˆæœ¬
*   **v1.2 (2025-12-07)**ï¼šé«”åŠ›æ¶ˆè€—å…¬å¼ä¿‚æ•¸èª¿æ•´ã€åŸºç¤å‘½ä¸­ç‡èª¿æ•´ (Base Shooting Percentage)
*   **v1.3 (2025-12-07)**ï¼šå†åº¦èª¿æ•´é«”åŠ›æ¶ˆè€—å…¬å¼ä¿‚æ•¸
*   **v1.4 (2025-12-07)**ï¼šæ–°å¢æ•¸æ“šæ­¸å±¬åˆ¤å®šæ©Ÿåˆ¶ (Data Attribution)ï¼Œå®šç¾©çƒå“¡å€‹äººæ•¸æ“šåˆ†é…é‚è¼¯ã€‚
*   **v1.5 (2025-12-13)**ï¼šæ–°å¢çŠ¯è¦é›¢å ´è¦å‰‡ (6çŠ¯)ï¼Œå®šç¾©çŠ¯æ»¿å¾Œçš„ä¸Šå ´æ™‚é–“é‡åˆ†é…æ©Ÿåˆ¶ã€‚
*   **v1.6 (2025-12-16)**ï¼šæ–°å¢é–‹å ´è·³çƒæ©Ÿåˆ¶ã€ç¯€æ¬¡çƒæ¬Šè¼ªæ›¿è¦å‰‡ (Q2/Q3è² æ–¹, Q4å‹æ–¹)ã€é¦–å›åˆå¼·åˆ¶å¾Œå ´æ™‚é–“ã€‚
*   **v1.7 (2025-12-20)**ï¼šä¿®æ­£ä¸‰åˆ†çƒåŸºç¤å‘½ä¸­ç‡ã€‚
*   **v1.8 (2025-12-20)**ï¼šé‡æ§‹æŠ•ç±ƒçµç®—æµç¨‹ (Section 5)ï¼Œèª¿æ•´åˆ¤å®šé †åºç‚ºï¼šé¡å‹åˆ¤å®š -> å‘½ä¸­è¨ˆç®— -> çŠ¯è¦åˆ¤å®šï¼›**æ–°å¢è¼¸å‡ºæ•¸æ“šå®šç¾© (Section 7)**ã€‚
*   **v2.1 (2025-12-28)**ï¼š
    *   **æ–°å¢**: è³½å‰èº«é«˜ä¿®æ­£æ©Ÿåˆ¶ (Height Correction)ã€‚
    *   **èª¿æ•´**: é«”åŠ›ç³»çµ±å¼•å…¥ã€Œå¹´é½¡è¡°é€€ã€åƒæ•¸ (20æ­²/1%)ï¼›ä¸­å ´èˆ‡ç¯€é–“ä¼‘æ¯æ”¹ç‚ºæ™‚é–“æ¢å¾©åˆ¶ã€‚
    *   **èª¿æ•´**: å¾Œå ´äº‹ä»¶ (Backcourt) å¼•å…¥èº«é«˜æ‡²ç½°ã€‚
    *   **èª¿æ•´**: å‰å ´å°è“‹ (Block) é›™æ–¹çš†å—èº«é«˜åŠ æˆã€‚
    *   **èª¿æ•´**: å‰å ´æŠ„æˆª (Steal) é›™æ–¹çš†å—èº«é«˜æ‡²ç½°ï¼Œé˜²å®ˆæ–¹æ–°å¢ã€Œè·‘ä½ã€ `off_move`ã€‚
    *   **èª¿æ•´**: æŠ•ç±ƒåˆ¤å®š (Shooting) å¼•å…¥èº«é«˜åŠ æˆï¼›ä¸‰åˆ†çƒåŠ æ¬Š `shot_accuracy` èˆ‡ `shot_range`ï¼›é˜²å®ˆæ–¹ç§»é™¤ `def_rebound`ã€‚
    *   **èª¿æ•´**: ç±ƒæ¿åˆ¤å®š (Rebound) é›™æ–¹çš†å—èº«é«˜åŠ æˆã€‚
    *   **å„ªåŒ–**: å…¨æ–‡å±¬æ€§åç¨±çµ±ä¸€ç‚º Config Key æ ¼å¼ã€‚
*   **v2.2 (2026-01-07)**ï¼š
    *   **æ–°å¢**: æŠ•ç±ƒå‘½ä¸­ç‡å…¬å¼åŠ å…¥ **æŠ€å·§åŠ æˆ (Skill Bonus)** æ©Ÿåˆ¶ï¼Œå…¬å¼ç‚º `1 + (accuracy+range+off_move)/800`ï¼Œå¼·åŒ–é«˜æ•¸å€¼å°„æ‰‹å„ªå‹¢ï¼Œä¸¦ä¸”å°‡ä¸‰åˆ†åŠ æˆåŒæ­¥åŠ ä¸Š `off_move`ã€‚
*   **v2.3 (2026-01-07)**ï¼š
    *   **æ–°å¢**: æŠ„æˆªå¾Œçš„æ”»å®ˆè½‰æ›ã€‚
*   **v2.4 (2026-01-23)**ï¼š
    *   **èª¿æ•´**: å¾Œå ´æ™‚é–“è¨ˆç®—åŠ å…¥ **é€Ÿåº¦æŠ˜æ‰£ (Speed Discount)** æ©Ÿåˆ¶ã€‚
    *   **æ–°å¢**: å¾Œå ´ **8ç§’é•ä¾‹** åˆ¤å®šè¦å‰‡ã€‚
    *   **èª¿æ•´**: å‰å ´æ™‚é–“è¨ˆç®—åŠ å…¥ **é€Ÿåº¦æŠ˜æ‰£ (Speed Discount)** æ©Ÿåˆ¶ã€‚
    *   **æ–°å¢**: å…¨å ´ **24ç§’é•ä¾‹** åˆ¤å®šè¦å‰‡ã€‚
    *   **æ›´æ–°**: Section 7 è¼¸å‡ºæ•¸æ“šå®šç¾©ï¼Œè£œå…¨ Paceã€å¿«æ”»ã€+/- å€¼èˆ‡é€²éšåœ˜éšŠæ•¸æ“šã€‚

---

## 0. å…¨åŸŸè¦å‰‡ (General Rules)
*   **æ•¸å€¼å¼•ç”¨**: å¼•æ“ä¸­æ‰€æœ‰æ¶‰åŠå±¬æ€§çš„è¨ˆç®— (å‘½ä¸­ã€å°æŠ—ã€åˆ¤å®š)ï¼Œçš†å¿…é ˆä½¿ç”¨ç¶“ç”± **é«”åŠ›è¡°é€€ä¿®æ­£å¾Œ** çš„ã€Œç•¶å‰èƒ½åŠ›å€¼ã€ã€‚
*   **å¹³æ‰‹è™•ç†**: è‹¥æ­£è¦æ™‚é–“ (4ç¯€) çµæŸå¹³æ‰‹ï¼Œé€²å…¥å»¶é•·è³½ (OT)ã€‚
    *   OT æ™‚é–“: 5 åˆ†é˜ã€‚
    *   é«”åŠ›: **ä¸é‡ç½®** (å»¶çºŒæ­£è¦è³½ç‹€æ…‹)ã€‚

---

## 1. è³½å‰æº–å‚™ (Pre-Game Setup)

### 1.1 ä½ç½®èƒ½åŠ›è©•åˆ† (Positional Scoring)
æ¯”è³½é–‹å§‹å‰ï¼Œç³»çµ±éœ€é‡å°æ¯ä½çƒå“¡è¨ˆç®—äº”å€‹ä½ç½®çš„é©æ€§åˆ†æ•¸ï¼Œç”¨æ–¼æ±ºå®šè¼ªæ›¿é †åºã€‚
*   **æœ€å¼·é™£å®¹ (Best 5)**: ç³»çµ±éœ€æ¨™è¨˜å‡ºè©²éšŠäº”å€‹ä½ç½®åˆ†æ•¸æœ€é«˜çš„çµ„åˆï¼Œç”¨æ–¼é—œéµæ™‚åˆ»ã€‚

| ä½ç½®                | è¨ˆç®—å…¬å¼ (ç”±é«˜è‡³ä½æ’åº)                                        |
| :------------------ | :----------------------------------------------------------- |
| **ä¸­é‹’ (C)**        | èº«é«˜ + åŠ›é‡ + ç±ƒæ¿ + å¡ä½ + å¹²æ“¾                               |
| **å¤§å‰é‹’ (PF)**     | èº«é«˜ + åŠ›é‡ + ç±ƒæ¿ + å¡ä½ + å¹²æ“¾ + å½ˆè·³ + é€Ÿåº¦                  |
| **å°å‰é‹’ (SF)**     | **å…¨éƒ¨ 20 é …å±¬æ€§ç¸½å’Œ + èº«é«˜**                                  |
| **å¾—åˆ†å¾Œè¡› (SG)**   | æ‰‹æ„Ÿ + å‡ºæ‰‹é€Ÿåº¦ + é€²æ”»æ™ºå•† + é˜²å®ˆæ™ºå•† + å¹²æ“¾ + æŠ„æˆª + å°„ç¨‹       |
| **æ§çƒå¾Œè¡› (PG)**   | é€Ÿåº¦ + é€²æ”»æ™ºå•† + æŠ„æˆª + é‹çƒ + æ§çƒ + å‚³çƒ - **èº«é«˜**          |

### 1.2 å…ˆç™¼é™£å®¹æ±ºå®šé‚è¼¯ (Starting Lineup)
ç³»çµ±ä¾æ“šä»¥ä¸‹å„ªå…ˆé †åºå¡«å…¥å…ˆç™¼äº”äºº (PG, SG, SF, PF, C)
å¡«å…¥é †åºæŒ‰ç…§**æ˜æ˜Ÿ**->**å…ˆç™¼**->å…¶ä»–(PG, C, SG, SF, PF)ï¼š

1.  **æ˜æ˜Ÿå„ªå…ˆ (Star Priority)**
    *   éšŠä¼ä¸­çš„ `Star` çƒå“¡æ“æœ‰æœ€é«˜å„ªå…ˆæ¬Šã€‚
    *   è‹¥æœ‰å¤šä½ `Star`ï¼Œä¾æ“šã€Œä½ç½®è©•åˆ†ã€æœ€é«˜çš„é †ä½å„ªå…ˆé–å®šä½ç½®ã€‚

2.  **å…ˆç™¼å¡«è£œ (Starter Fill)**
    *   `Star` åˆ†é…å®Œç•¢å¾Œï¼Œç”± `Starter` çƒå“¡å¡«è£œå‰©é¤˜ç©ºç¼ºã€‚

3.  **å‰©é¤˜å¡«è£œ (Fill Gaps)**
    *   è‹¥ 5 å€‹ä½ç½®ä»æœ‰ç©ºç¼ºï¼Œç”±å‰©é¤˜çƒå“¡ä¸­ã€Œè©²ä½ç½®è©•åˆ†æœ€é«˜è€…ã€å¡«è£œã€‚

### 1.3 è¼ªæ›¿æ’åº (Rotation Order)
*   éå…ˆç™¼çƒå“¡ä¾æ“šå„ä½ç½®è©•åˆ†é«˜ä½åˆ—å…¥æ›¿è£œåå–®ã€‚
*   å¯¦éš›æ›äººæ™‚æ©Ÿç”±é«”åŠ›ç³»çµ±æ§åˆ¶ã€‚
*   è‹¥çƒå“¡å·²é”æ™‚é–“ä¸Šé™ï¼Œéå¿…è¦ä¸ä¸Šå ´

### 1.4 æ¯”è³½æ™‚é–“åˆ†é…è¦å‰‡è£œå…… (Minutes Distribution)
ç³»çµ±éœ€å°‡ 240 åˆ†é˜åˆ†é…çµ¦ç™»éŒ„çƒå“¡ï¼Œä½œç‚ºæ›äººåƒè€ƒã€‚
*   **åˆ†é…æ¼”ç®—æ³•**: `å€‹äººæ™‚é–“ = ä¿åº•æ™‚é–“ + (æ¬Šé‡ * å–®ä½æ™‚é–“åƒ¹å€¼)`ã€‚
*   **è§’è‰²åƒæ•¸**:
    *   **Star**: ä¿åº• 30min, æ¬Šé‡ -1~5ã€‚
    *   **Starter**: ä¿åº• 20min, æ¬Šé‡ -2~7ã€‚
    *   **Rotation**: ä¿åº• 10min, æ¬Šé‡ 5~15ã€‚
    *   **Role**: ä¿åº• 0min, æ¬Šé‡ 5~12ã€‚
    *   **Bench**: ä¿åº• 0min, æ¬Šé‡ 0~10ã€‚
*   **è¨ˆç®—é‚è¼¯**:
    1.  æ‰£é™¤ç¸½ä¿åº•æ™‚é–“ï¼Œå‰©é¤˜æ™‚é–“ä¾æ¬Šé‡æ¯”ä¾‹åˆ†é…ã€‚
    2.  è¨ˆç®—çµæœç„¡æ¢ä»¶æ¨å»è‡³å°æ•¸é»ç¬¬ä¸€ä½ã€‚
    3.  å°¾æ•¸èª¤å·®è£œçµ¦æœ€å¾Œä¸€ä½çƒå“¡ã€‚

### 1.5 èº«é«˜å±¬æ€§ä¿®æ­£ (Initial Height Correction) [New v2.1]
åœ¨æ¯”è³½è¼‰å…¥éšæ®µï¼Œé‡å°ç‰¹å®šå±¬æ€§é€²è¡ŒåŸºæ–¼èº«é«˜çš„ç‰©ç†ä¿®æ­£ã€‚æ­¤ä¿®æ­£ç‚ºã€Œæ°¸ä¹…æ€§ä¿®æ­£ã€(é‡å°è©²å ´æ¯”è³½)ï¼Œå…ˆæ–¼é«”åŠ›ä¿®æ­£è¨ˆç®—ã€‚

*   **ä¿®æ­£å…¬å¼**:
    `ä¿®æ­£å±¬æ€§ = ä¿®æ­£å±¬æ€§ * (1+(max(BONUS_H - hight,min(NERF_H - hight, 0))) * Coeff`

*   **åƒæ•¸è¨­å®š (Parameters)**:
    *   `BONUS_H` (çŸ®å€‹åŠ æˆé–¾å€¼): **190** (cm)
    *   `NERF_H` (é«˜å€‹æ¸›ç›Šé–¾å€¼): **210** (cm)
    *   **å—å½±éŸ¿å±¬æ€§èˆ‡ä¿‚æ•¸ (Coeff)**:
        *   `é€Ÿåº¦ (ath_speed)`, `é‹çƒ (off_dribble)`: **0.02**
        *   `æ§çƒ (off_handle)`, `æŠ„æˆª (def_disrupt)`: **0.01**

### 1.6 é–‹å ´è·³çƒèˆ‡çƒæ¬Šè¼ªæ›¿ (Jump Ball & Possession) [New v1.6]
æ±ºå®šæ¯”è³½é–‹å§‹çš„çƒæ¬Šæ­¸å±¬ä»¥åŠå„ç¯€æ¬¡çš„é–‹çƒæ–¹ã€‚

*   **è·³çƒåƒèˆ‡è€… (Participants)**:
    *   å…©éšŠåˆ†åˆ¥é¸å‡º **(èº«é«˜ + å½ˆè·³ + é€²æ”»æ™ºå•†)** ç¸½å’Œæœ€é«˜çš„çƒå“¡ä»£è¡¨è·³çƒã€‚
*   **ç²å‹åˆ¤å®š (Winning Logic)**:
    *   è¨ˆç®—å…©ä½åƒèˆ‡è€…çš„æ•¸å€¼ç¸½å’Œ (Score_Home, Score_Away)ã€‚
    *   **ç²å‹æ©Ÿç‡**: `P(Home) = Score_Home / (Score_Home + Score_Away)`ã€‚
    *   ç³»çµ±ä¾æ“šæ­¤æ©Ÿç‡éš¨æ©Ÿæ±ºå®šè·³çƒç²å‹æ–¹ (Winner)ã€‚
*   **ç¯€æ¬¡çƒæ¬Šæ­¸å±¬ (Quarter Possession)**:
    *   **ç¬¬ 1 ç¯€ (Q1)**: **è·³çƒç²å‹æ–¹** ç²å¾—çƒæ¬Šã€‚
    *   **ç¬¬ 2 ç¯€ (Q2)**: **è·³çƒå¤±æ•—æ–¹** ç²å¾—çƒæ¬Šã€‚
    *   **ç¬¬ 3 ç¯€ (Q3)**: **è·³çƒå¤±æ•—æ–¹** ç²å¾—çƒæ¬Šã€‚
    *   **ç¬¬ 4 ç¯€ (Q4)**: **è·³çƒç²å‹æ–¹** ç²å¾—çƒæ¬Šã€‚
    *   **å»¶é•·è³½ (OT)**: é‡æ–°è·³çƒ (è¦å‰‡åŒ Q1)ã€‚

---

## 2. é«”åŠ›ç³»çµ± (Stamina System)

### 2.1 åŸºç¤åƒæ•¸
*   **åˆå§‹é«”åŠ›**: 100 (æ¯å ´æ¯”è³½é‡ç½®)ã€‚
*   **ä¸­å ´å›å¾©**: ç§»é™¤å›ºå®šå¢åŠ ï¼Œæ”¹ç”±é«”åŠ›æ¢å¾©ç« ç¯€å›å¾©ã€‚ **[New v2.1]**
*   **æ›äººé–€æª»**: ç•¶å ´ä¸Šçƒå“¡é«”åŠ› **< 80** æ™‚ï¼Œè§¸ç™¼æ›äººæª¢æŸ¥ã€‚

### 2.2 èƒ½åŠ›å€¼å‹•æ…‹ä¿®æ­£ (Dynamic Nerf)
é«”åŠ›ä¸‹é™æœƒç›´æ¥å‰Šå¼±çƒå“¡ç•¶ä¸‹çš„èƒ½åŠ›å€¼ã€‚

| ç•¶å‰é«”åŠ›   | ä¿®æ­£ä¿‚æ•¸ (Multiplier)        | èªªæ˜                                               |
| :--------- | :--------------------------- | :----------------------------------------------- |
| **80~100** | **1.0x** (100%)              | ç‹€æ…‹è‰¯å¥½ï¼Œç„¡å½±éŸ¿ã€‚                                 |
| **< 80**   | **1.0 - (80-é«”åŠ›)*0.01**     | ç·šæ€§è¡°é€€ (ä¾‹: 70é«”åŠ›=90%èƒ½åŠ›; 40é«”åŠ›=60%èƒ½åŠ›)ã€‚     |
| **1**      | **0.21x** (21%)              | æ¥µé™ç‹€æ…‹ï¼Œèƒ½åŠ›å€¼åƒ…å‰© 21%ã€‚                         |

### 2.3 é«”åŠ›æ¶ˆè€— (Drain) - *ä¸Šå ´æ™‚*
*   **å…¬å¼**: `æ¶ˆè€—é‡/åˆ† = (3.0 * (1 + (1 - é«”èƒ½%) + (1 - å¥åº·%))) * ((1 + (Age - AGE_THRESHOLD)) * AGE_DECAY_RATE)` 
        **(V1.2 å¾2.0å¢åŠ è‡³2.5ï¼ŒV1.3å¾2.5å¢åŠ è‡³3.0ï¼Œv2.1å¢åŠ å¹´é½¡ä¿®æ­£)**
*   **è®Šæ•¸è½‰æ›**:
    *   `é«”èƒ½%`: å±¬æ€§ `ath_stamina` (1~99 è½‰ç‚º 0.01~0.99)ã€‚
    *   `å¥åº·%`: å±¬æ€§ `talent_health` (1~99 è½‰ç‚º 0.01~0.99)ã€‚
    *   `AGE_THRESHOLD` (è¡°é€€èµ·å§‹å¹´é½¡): **20**        **[New v2.1]**
    *   `AGE_DECAY_RATE` (è¡°é€€ä¿‚æ•¸): **0.01**         **[New v2.1]**
*   **æ¨¡å‹é©—è­‰ (ä»¥å¥åº· 60 ç‚ºä¾‹)**:
    *   **é«”èƒ½ 10 (å·®)**: æ¯åˆ†é˜æ¶ˆè€—ç´„ **3.75** (ä¸Šå ´ç´„ 5.3 åˆ†é˜é–‹å§‹è¡°é€€)ã€‚
    *   **é«”èƒ½ 60 (ä¸­)**: æ¯åˆ†é˜æ¶ˆè€—ç´„ **3.20** (ä¸Šå ´ç´„ 6.2 åˆ†é˜é–‹å§‹è¡°é€€)ã€‚
    *   **é«”èƒ½ 99 (å„ª)**: æ¯åˆ†é˜æ¶ˆè€—ç´„ **2.42** (ä¸Šå ´ç´„ 8.2 åˆ†é˜é–‹å§‹è¡°é€€)ã€‚

### 2.4 é«”åŠ›æ¢å¾© (Recovery) - *æ¿å‡³æ™‚*
*   **å…¬å¼**: `æ¢å¾©é‡/åˆ† = (1.0 + (é«”èƒ½%) - (1 - å¥åº·%)) * ((1 - (Age - AGE_THRESHOLD)) * AGE_DECAY_RATE)`
            **[New v2.1 å¢åŠ å¹´é½¡ä¿®æ­£]**
*   **é‚è¼¯**: é«”èƒ½è¶Šå¥½ã€å¥åº·è¶Šå¥½ï¼Œé«”åŠ›å›å¾—è¶Šå¿«ã€‚
*   **æ¨¡å‹é©—è­‰ (ä»¥å¥åº· 60 ç‚ºä¾‹)**:
    *   **é«”èƒ½ 10**: æ¯åˆ†é˜æ¢å¾© **0.7**ã€‚
    *   **é«”èƒ½ 60**: æ¯åˆ†é˜æ¢å¾© **1.2**ã€‚
    *   **é«”èƒ½ 99**: æ¯åˆ†é˜æ¢å¾© **1.59**ã€‚
*   **ä¼‘æ¯äº‹ä»¶æ¢å¾© [New v2.1]**:
    *   **ç¯€èˆ‡ç¯€ä¹‹é–“ (Quarter Break)**: æ¨¡æ“¬ä¼‘æ¯ **2 åˆ†é˜**ã€‚
        *   `Recovery = æ¢å¾©ç‡ * 2.0`
    *   **ä¸­å ´ä¼‘æ¯ (Halftime)**: æ¨¡æ“¬ä¼‘æ¯ **20 åˆ†é˜**ã€‚
        *   `Recovery = æ¢å¾©ç‡ * 20.0`
*   **é™åˆ¶**: é«”åŠ›å€¼æœ€ä½ç‚º 1ï¼Œä¸Šé™ç‚º 100ã€‚

### 2.5 æ›äººåŸ·è¡Œ (Substitution Execution)
æ¯”è³½é€²è¡Œä¸­ï¼Œä¾æ“šä»¥ä¸‹å„ªå…ˆé †åºåŸ·è¡Œæ›äººï¼š

1.  **é—œéµæ™‚åˆ»å¼·åˆ¶èª¿åº¦ (Clutch Override)**
    *   **æ™‚æ©Ÿ**: ç¬¬ 4 ç¯€æœ€å¾Œ 2 åˆ†é˜ (å‰©é¤˜æ™‚é–“ <= 2:00) åŠ å»¶é•·è³½ (OT) æœ€å¾Œ 2 åˆ†é˜ (å‰©é¤˜æ™‚é–“ <= 2:00)ã€‚
                **[New v2.1 ä¿®æ­£]**
    *   **åŸ·è¡Œ**: **å¼·åˆ¶æ›ä¸Šã€Œæœ€å¼·é™£å®¹ (Best 5)ã€**ã€‚
    *   *ä¾‹å¤–*: é™¤éè©²çƒå“¡çŠ¯æ»¿é›¢å ´æˆ–å—å‚·ï¼Œå¦å‰‡ç„¡è¦–é«”åŠ›ç‹€æ³èˆ‡æ™‚é–“é™åˆ¶ã€‚

2.  **å¸¸è¦æ›äºº (Regular Rotation)**
    *   **è§¸ç™¼æ¢ä»¶**:
        *   å ´ä¸Šçƒå“¡é«”åŠ› **< 80**ã€‚
        *   æˆ– å ´ä¸Šçƒå“¡å·²è¶…éã€Œç›®æ¨™ä¸Šå ´æ™‚é–“ã€ã€‚
    *   **æ›¿è£œé¸æ“‡**:
        *   é¸æ“‡åŒä½ç½®ä¸­ã€Œé«”åŠ› > å ´ä¸Šçƒå“¡ã€ä¸”ã€Œæœªé”æ™‚é–“ä¸Šé™ã€èƒ½åŠ›æœ€å¼·è€…ã€‚

#### **2.6 çŠ¯è¦èˆ‡é›¢å ´ (Fouls & Disqualification)**
*   **å€‹äººçŠ¯è¦ä¸Šé™**: æ¯ä½çƒå“¡å–®å ´æ¯”è³½ç´¯è¨ˆçŠ¯è¦æ¬¡æ•¸é”åˆ° **6 æ¬¡** æ™‚ï¼Œå³åˆ¤å®šç‚ºã€ŒçŠ¯æ»¿é›¢å ´ (Fouled Out)ã€ã€‚
*   **é›¢å ´è™•ç½®**:
    *   è©²çƒå“¡å¿…é ˆç«‹å³è¢«æ›¿æ›ä¸‹å ´ã€‚
    *   è©²çƒå“¡åœ¨å‰©é¤˜æ¯”è³½æ™‚é–“å…§ï¼ˆå«å»¶é•·è³½ï¼‰ä¸å¾—å†æ¬¡ä¸Šå ´ã€‚
*   **æ™‚é–“é‡åˆ†é… (Time Redistribution)**:
    *   ç•¶çƒå“¡é›¢å ´å¾Œï¼Œå…¶å‰©é¤˜çš„ã€Œç›®æ¨™ä¸Šå ´æ™‚é–“ã€éœ€åˆ†é…çµ¦å…¶ä»–éšŠå‹ï¼Œä»¥ç¢ºä¿æ¯”è³½èƒ½é †åˆ©é€²è¡Œã€‚
    *   **åˆ†é…é‚è¼¯**:
        1.  ç³»çµ±ä¾åºæª¢æŸ¥ C -> PF -> SF -> SG -> PG äº”å€‹ä½ç½®ã€‚
        2.  æ¯å€‹ä½ç½®é¸å‡ºã€Œä½ç½®è©•åˆ†ã€æœ€é«˜çš„å‰ 3 åçƒå“¡ (æ’é™¤å·²é›¢å ´è€…)ã€‚
        3.  å°‡é›¢å ´çƒå“¡çš„å‰©é¤˜æ™‚é–“ï¼Œå¹³å‡åˆ†é…çµ¦é€™ 15 å€‹åé¡ (è‹¥çƒå“¡åŒæ™‚æ˜¯å¤šå€‹ä½ç½®çš„å‰ 3 åï¼Œå‰‡ç²å¾—å¤šä»½æ™‚é–“)ã€‚
        4.  *å…¬å¼*: `æ¯ä»½æ™‚é–“ = é›¢å ´è€…å‰©é¤˜æ™‚é–“ / 15`ã€‚

## 3. æ¯”è³½å¼•æ“ï¼šå¾Œå ´éšæ®µ (Backcourt Phase)

### 3.1 åŸºç¤è¨­å®š
*   **åƒèˆ‡è€…**:
    *   **é€²æ”»æ–¹**: PG + SG + éš¨æ©Ÿ 1 åçƒå“¡ (å…± 3 äºº)ã€‚
    *   **é˜²å®ˆæ–¹**: å°æ‡‰çš„ 3 åé˜²å®ˆè€…ã€‚
*   **å±¬æ€§æ± **: **[New v2.1 å¢åŠ èº«é«˜ä¿®æ­£]**
    *   `é€²æ”»ç¸½å€¼ (Off_Sum)` = 3 äººçš„ (é‹çƒ + å‚³çƒ + é€²æ”»æ™ºå•† - èº«é«˜) ç¸½å’Œã€‚
    *   `é˜²å®ˆç¸½å€¼ (Def_Sum)` = 3 äººçš„ (æŠ„æˆª + å¹²æ“¾ + é˜²å®ˆæ™ºå•† - èº«é«˜) ç¸½å’Œã€‚
    *   `å¾Œå ´é€Ÿåº¦ç¸½å€¼ (Backcourt_Speed_Sum)` = é€²æ”»æ–¹ 3 äººçš„ `é€Ÿåº¦ (ath_speed)` ç¸½å’Œã€‚ **[New v2.4]**

### 3.2 æ™‚é–“è¨ˆç®— (Time Calculation) [Update v2.4]
1.  **åŸºç¤æ™‚é–“**: éš¨æ©Ÿéª° **1.0 ~ 8.0** ç§’ (å–è‡³å°æ•¸é»ç¬¬ä¸€ä½)ã€‚
2.  **å°æŠ—ä¿®æ­£**:
    *   `å°æŠ—ä¿®æ­£ç§’æ•¸ = (Def_Sum - Off_Sum) * 0.008`
3.  **é€Ÿåº¦æŠ˜æ‰£ (Speed Discount)**:
    *   `é€²æ”»æŠ˜æ‰£ = Random(0, (é€²æ”»æ–¹_Backcourt_Speed_Sum / 3) * 0.1)`
    *   `é˜²å®ˆæ‹–å»¶ = Random(0, (é˜²å®ˆæ–¹_Backcourt_Speed_Sum / 3) * 0.1) * 0.5`
    *   *èªªæ˜*: é€²æ”»æ–¹é€Ÿåº¦è¶Šå¿«ï¼Œæ™‚é–“è¶ŠçŸ­ï¼›é˜²å®ˆæ–¹é€Ÿåº¦è¶Šå¿«ï¼Œçµ¦äºˆçš„å£“è¿«ä½¿æ™‚é–“è®Šé•·ã€‚
4.  **æœ€çµ‚æ™‚é–“**: `åŸºç¤æ™‚é–“ + å°æŠ—ä¿®æ­£ç§’æ•¸ - é€²æ”»æŠ˜æ‰£ + é˜²å®ˆæ‹–å»¶`ã€‚
    *   **ä¸‹é™**: é–å®šåœ¨ **0.5** ç§’ (ç‰©ç†æ¥µé™)ã€‚

### 3.3 äº‹ä»¶åˆ¤å®š
æ ¹æ“š `æœ€çµ‚æ™‚é–“` è§¸ç™¼å°æ‡‰äº‹ä»¶ï¼š

| æœ€çµ‚æ™‚é–“     | è§¸ç™¼äº‹ä»¶     | åˆ¤å®šé‚è¼¯                |
| :----------- | :----------- | :---------------------- |
| **> 8.0 ç§’** | **8ç§’é•ä¾‹**  | é€²æ”»æ–¹å¤±èª¤ï¼Œçƒæ¬Šè½‰æ›ã€‚  |
| **> 3.0 ç§’** | **æŠ„æˆªåˆ¤å®š** | é€²å…¥æŠ„æˆªæª¢å®š (è¦‹ 3.4)ã€‚ |
| **1.0 ~ 3.0**| **æ­£å¸¸æ¨é€²** | å®‰å…¨éåŠå ´ã€‚            |
| **< 1.0 ç§’** | **å¿«æ”»**     | é€²å…¥å¿«æ”»æª¢å®š (è¦‹ 3.5)ã€‚ |

### 3.4 æŠ„æˆªåˆ¤å®š (Backcourt Steal)
*   **åŸºç¤æ©Ÿç‡**: **1%**ã€‚
*   **æ©Ÿç‡åŠ æˆ**: `(Def_Sum - Off_Sum) * 0.1%`ã€‚
*   **çµç®—**: éª° `1-100` <= æœ€çµ‚æ©Ÿç‡å‰‡å¤±èª¤ã€‚

### 3.4.1 æŠ„æˆªå¾Œçš„æ”»å®ˆè½‰æ› (Transition after Steal) [Update v2.3]

ç•¶å¾Œå ´æŠ„æˆªåˆ¤å®šæˆåŠŸæ™‚ï¼Œç³»çµ±éœ€åˆ¤å®šæ˜¯ç™¼å‹•ã€Œè½‰æ›å¿«æ”»ã€é‚„æ˜¯é€²å…¥ã€Œå‰å ´é™£åœ°æˆ°ã€ã€‚

*   **è§¸ç™¼æ¢ä»¶**: `3.4` æŠ„æˆªåˆ¤å®šæˆåŠŸã€‚
*   **è½‰æ›å¿«æ”»åˆ¤å®šå…¬å¼**:
    *   **å±¬æ€§å®šç¾©**: å–é›™æ–¹ **å ´ä¸Š5äºº** çš„ `é€Ÿåº¦ (ath_speed)` ç¸½å’Œã€‚
    *   **æ©Ÿç‡**: `50% + (åŸå®ˆæ–¹é€Ÿåº¦ç¸½å’Œ - åŸæ”»æ–¹é€Ÿåº¦ç¸½å’Œ) / åŸæ”»æ–¹é€Ÿåº¦ç¸½å’Œ`ã€‚
    *   *èªªæ˜*: è‹¥é˜²å®ˆæ–¹æ•´é«”é€Ÿåº¦å¿«æ–¼é€²æ”»æ–¹ï¼Œå¿«æ”»æ©Ÿç‡æå‡ï¼›åä¹‹å‰‡å‚¾å‘ç©©ç´®ç©©æ‰“ã€‚
*   **æµç¨‹åˆ†æ”¯**:
    1.  **åˆ¤å®šé€šé (Fastbreak)**:
        *   ç«‹å³åŸ·è¡Œ **3.5 å¿«æ”»åˆ¤å®š**ã€‚
        *   æ”»å®ˆè§’è‰²äº’æ› (åŸå®ˆæ–¹è®Šé€²æ”»æ–¹)ã€‚
    2.  **åˆ¤å®šå¤±æ•— (Set Play)**:
        *   **è·³éå¾Œå ´éšæ®µ**ï¼Œç›´æ¥é€²å…¥ **4. å‰å ´éšæ®µ**ã€‚
        *   æ”»å®ˆè§’è‰²äº’æ› (åŸå®ˆæ–¹è®Šé€²æ”»æ–¹)ã€‚
        *   *èªªæ˜*: æ¨¡æ“¬æŠ„æˆªå¾Œå°æ–¹å¿«é€Ÿå›é˜²ï¼Œé›–æœªå½¢æˆå¿«æ”»ï¼Œä½†å·²æ¨é€²è‡³å‰å ´ã€‚

### 3.5 å¿«æ”»åˆ¤å®š (Fastbreak)
ç•¶æ¨é€²æ¥µå¿«æ™‚è§¸ç™¼ï¼Œç”±é›™æ–¹ã€Œè·‘æœ€å¿«ã€çš„çƒå“¡é€²è¡Œ 1v1 ç¶œåˆèƒ½åŠ›å°æ±ºã€‚

#### A. åƒèˆ‡è€…å±¬æ€§è¨ˆç®— **[New v2.1 å¢åŠ æŠ•ç±ƒæŠ€å·§ä¿®æ­£]**
*   **é€²æ”»è€… (Off)**: å–å ´ä¸Š `(é€Ÿåº¦ + é‹çƒ)` æœ€é«˜è€…ã€‚
    *   `Off_Stat` = åŠ›é‡ + é€Ÿåº¦ + å½ˆè·³ + æ‰‹æ„Ÿ + å‡ºæ‰‹é€Ÿåº¦ + é€²æ”»æ™ºå•† + é‹æ°£ + è·‘ä½ + é‹çƒ + æŠ•ç±ƒæŠ€å·§
*   **é˜²å®ˆè€… (Def)**: å–å ´ä¸Š `(é€Ÿåº¦ + é˜²å®ˆæ™ºå•†)` æœ€é«˜è€…ã€‚
    *   `Def_Stat` = åŠ›é‡ + é€Ÿåº¦ + å½ˆè·³ + æ‰‹æ„Ÿ + å‡ºæ‰‹é€Ÿåº¦ + é˜²å®ˆæ™ºå•† + é‹æ°£ + å¹²æ“¾ + æŠ„æˆª + æŠ•ç±ƒæŠ€å·§

#### B. é€²çƒæˆåŠŸç‡ (Success Rate)
*   **åŸºç¤æˆåŠŸç‡ (Base)**: éš¨æ©Ÿç”¢ç”Ÿ **0.3 ~ 1.0** (30% ~ 100%)ã€‚
    *   *ä»£è¡¨å¿«æ”»ç•¶ä¸‹çš„æ··äº‚ç¨‹åº¦èˆ‡æ©Ÿæœƒå¥½å£ã€‚*
*   **å±¬æ€§ä¿®æ­£**: `(Off_Stat - Def_Stat) * 0.5%`ã€‚
*   **æœ€çµ‚æˆåŠŸç‡**: `Base + å±¬æ€§ä¿®æ­£` (ä¸Šé™ 100%)ã€‚
*   **é€²çƒåˆ¤å®š**: éª° `1-100` <= æœ€çµ‚æˆåŠŸç‡ -> **é€²çƒ**ã€‚

#### C. çŠ¯è¦åˆ¤å®š (Foul Check)
ç„¡è«–æ˜¯å¦é€²çƒï¼Œçš†éœ€é€²è¡ŒçŠ¯è¦æª¢å®šã€‚
*   **æ ¸å¿ƒå±¬æ€§**: `é€²æ”»æ™ºå•† (Off_IQ)` vs `é˜²å®ˆæ™ºå•† (Def_IQ)`ã€‚
*   **çŠ¯è¦æ©Ÿç‡**: `1% + (Off_IQ - Def_IQ) * 1%`ã€‚
    *   *èªªæ˜*: åŸºç¤ 1%ï¼Œæ™ºå•†æ¯é«˜å°æ‰‹ 1 é»ï¼Œå¤š 1% è¦åˆ°çŠ¯è¦æ©Ÿç‡ã€‚
    *   *ä¸‹é™*: æœ€ä½ 0.1%ã€‚
*   **çŠ¯è¦åˆ¤å®š**: éª° `0-100` <= çŠ¯è¦æ©Ÿç‡ -> **è§¸ç™¼çŠ¯è¦**ã€‚

#### D. æœ€çµ‚çµæœçµç®— (Outcome)
| é€²çƒåˆ¤å®š | çŠ¯è¦åˆ¤å®š | çµæœæè¿° | å¾—åˆ† | å¾ŒçºŒ |
| :--- | :--- | :--- | :--- | :--- |
| **æˆåŠŸ** | **ç„¡** | **å¿«æ”»å¾—åˆ†** | +2 | æ”»å®ˆäº¤æ› |
| **æˆåŠŸ** | **æœ‰** | **é€²ç®—åŠ ç½° (And-1)** | +2 | åŸ·è¡Œ 1 æ¬¡ç½°çƒ |
| **å¤±æ•—** | **æœ‰** | **é˜»æ“‹/æ‰“æ‰‹çŠ¯è¦** | 0 | åŸ·è¡Œ 2 æ¬¡ç½°çƒ |
| **å¤±æ•—** | **ç„¡** | **é˜²å®ˆæˆåŠŸ** | 0 | æ”»å®ˆäº¤æ› (è¦–ç‚ºç±ƒæ¿/ç«é‹) |

## 4. æ¯”è³½å¼•æ“ï¼šå‰å ´éšæ®µ (Frontcourt Phase)

### 4.1 é€²æ”»æ™‚é–“èˆ‡å‡ºæ‰‹å“è³ª [Update v2.4]
*   **åŸºç¤æ™‚é–“ç¯„åœ**: `8.0` ~ `ä¸Šé™` ç§’ã€‚
    *   **ä¸Šé™**: ä¸€èˆ¬å›åˆç‚º `24.0 - å¾Œå ´èŠ±è²»æ™‚é–“`ï¼›å‰å ´ç±ƒæ¿å›åˆç‚º `14.0`ã€‚
*   **æ™‚é–“ä¸‹é™ä¿®æ­£**:
    *   **å½±éŸ¿å±¬æ€§**: `é€Ÿåº¦`, `é€²æ”»æ™ºå•†`, `å‚³çƒ`ã€‚
    *   **é‚è¼¯**: åœ˜éšŠä¸Šè¿°ä¸‰é …å±¬æ€§è¶Šé«˜ï¼Œèƒ½é™ä½æ™‚é–“èŠ±è²»çš„ä¸‹é™ (æœ€ä½ä¸ä½æ–¼ 4.0 ç§’)ã€‚
*   **åˆæ­¥èŠ±è²»æ™‚é–“**: åœ¨ `ä¿®æ­£å¾Œä¸‹é™` èˆ‡ `ä¸Šé™` ä¹‹é–“éš¨æ©Ÿç”¢ç”Ÿã€‚
*   **é€Ÿåº¦æŠ˜æ‰£ (Speed Discount)**:
    *   `å‰å ´é€Ÿåº¦ç¸½å€¼ (Frontcourt_Speed_Sum)` = æ”»å®ˆé›™æ–¹å ´ä¸Š 5 äººçš„ `é€Ÿåº¦ (ath_speed)` ç¸½å’Œã€‚
    *   `é€²æ”»æŠ˜æ‰£ = Random(0, (é€²æ”»æ–¹_Frontcourt_Speed_Sum / 5) * 0.01)`
    *   `é˜²å®ˆæ‹–å»¶ = Random(0, (é˜²å®ˆæ–¹_Frontcourt_Speed_Sum / 5) * 0.01)`
    *   **å¯¦éš›èŠ±è²»æ™‚é–“** = `åˆæ­¥èŠ±è²»æ™‚é–“ - é€²æ”»æŠ˜æ‰£ + é˜²å®ˆæ‹–å»¶`ã€‚
    *   **ä¸‹é™**: å¯¦éš›èŠ±è²»æ™‚é–“æœ€ä½ä¸ä½æ–¼ **1.0** ç§’ã€‚
*   **24ç§’é•ä¾‹åˆ¤å®š**:
    *   è‹¥ `å¾Œå ´æ™‚é–“ + å¯¦éš›èŠ±è²»æ™‚é–“ > 24.0`ï¼Œå‰‡åˆ¤å®šç‚º **24ç§’é•ä¾‹** (Team Turnover)ï¼Œçƒæ¬Šè½‰æ›ã€‚
*   **å‡ºæ‰‹å“è³ªåŠ æˆ**:
    *   æ™‚é–“èŠ±è²»è¶Šå°‘ -> å‡ºæ‰‹å“è³ªåŠ æˆè¶Šé«˜ã€‚
    *   å…¬å¼ï¼š`æ™‚é–“åŠ æˆ = (7 - å¯¦éš›èŠ±è²»æ™‚é–“) * 0.01`ã€‚

### 4.2 ç©ºé–“èˆ‡è·‘ä½ (Spacing)
*   **å½±éŸ¿å±¬æ€§**:
    *   **é€²æ”»æ–¹ (Off_Sum)**: `è·‘ä½` (å¯è¨“ç·´) + `é€²æ”»æ™ºå•†` (ä¸å¯è¨“ç·´)ã€‚
    *   **é˜²å®ˆæ–¹ (Def_Sum)**: `è·‘ä½` (å¯è¨“ç·´) + `é˜²å®ˆæ™ºå•†` (ä¸å¯è¨“ç·´)ã€‚
*   **ç©ºé–“åŠ æˆä¿‚æ•¸ (Spacing Bonus)**:
    *   **å…¬å¼**: `(Off_Sum - Def_Sum) / Def_Sum`ï¼Œä»¥25%ç‚ºä¸‹é™ã€125%ç‚ºä¸Šé™ï¼Œéš¨æ©Ÿç”¢ç”Ÿã€‚
    *   **ä¸Šé™**: æœ€å¤§å€¼ç‚º **1.0**ã€‚
*   **ç©ºé–“æ•ˆæœåˆ¤å®š**:
    *   **åŠ æˆ > 0.5**: **å®Œå…¨ç©ºæª” (Wide Open)**ï¼Œå°è“‹ä¸æœƒç™¼ç”Ÿ (æ©Ÿç‡ = 0%)ã€‚
    *   **åŠ æˆ < 0**: **ç©ºé–“æ“æ“ **ï¼Œå¢åŠ è¢«å°è“‹çš„æ©Ÿç‡ã€‚
    *   **ä¸€èˆ¬æƒ…æ³ (0 ~ 0.5)**: æ­£å¸¸è¨ˆç®—å°è“‹æ©Ÿç‡ã€‚

### 4.3 é˜²å®ˆäº‹ä»¶ï¼šå°è“‹ (Block)
å°è“‹åˆ¤å®šåˆ†ç‚ºå…©å€‹éšæ®µï¼š**è§¸ç™¼åˆ¤å®š** èˆ‡ **å°æŠ—åˆ¤å®š**ã€‚

#### éšæ®µä¸€ï¼šè§¸ç™¼åˆ¤å®š (Attempt Check)
æ±ºå®šé˜²å®ˆè€…æ˜¯å¦èƒ½è·Ÿä¸Šä¸¦å˜—è©¦å°è“‹ã€‚
*   **å‰æ**: è‹¥ `ç©ºé–“åŠ æˆ > 0.5`ï¼Œæ­¤éšæ®µç›´æ¥å¤±æ•— (ç„¡æ³•å°è“‹)ã€‚
*   **åŸºç¤æ©Ÿç‡**: **1%**ã€‚
*   **æ©Ÿç‡ä¿®æ­£**:
    *   **é™ä½**: é€²æ”»æ–¹ `è·‘ä½`ã€‚
    *   **æå‡**: é˜²å®ˆæ–¹ `å¹²æ“¾` + `é˜²å®ˆæ™ºå•†`ã€‚
    *   **ç©ºé–“æ‡²ç½°**: è‹¥ `ç©ºé–“åŠ æˆ < 0`ï¼Œé¡å¤–å¤§å¹…æå‡è§¸ç™¼æ©Ÿç‡ã€‚
*   **çµæœ**: è‹¥åˆ¤å®šé€šéï¼Œé€²å…¥éšæ®µäºŒï¼›å¦å‰‡ç„¡å°è“‹ã€‚

#### éšæ®µäºŒï¼šå°æŠ—åˆ¤å®š (Success Check)
æ±ºå®šæ˜¯ã€ŒæˆåŠŸè“‹ç«é‹ã€é‚„æ˜¯ã€Œé€²æ”»æ–¹å¼·è¡Œå‡ºæ‰‹/çŒç±ƒã€ã€‚
*   **å°æŠ—å…¬å¼**: **[New v2.1 å¢åŠ èº«é«˜ä¿®æ­£]**
    *   `é€²æ”»åŠ› (Off_Power)` = åŠ›é‡ + å½ˆè·³ + é€²æ”»æ™ºå•† + èº«é«˜
    *   `é˜²å®ˆåŠ› (Def_Power)` = åŠ›é‡ + å½ˆè·³ + å¹²æ“¾ + é˜²å®ˆæ™ºå•† + èº«é«˜
    *   **åˆ¤å®šæ¨™æº– (Ratio)** = `Off_Power / Def_Power`
*   **çµç®—é‚è¼¯**:
    *   **Ratio æ•¸å€¼è¶Šä½**: é˜²å®ˆæ–¹å„ªå‹¢è¶Šå¤§ -> **å°è“‹æˆåŠŸ (Block)**ã€‚
    *   **Ratio æ•¸å€¼è¶Šé«˜**: é€²æ”»æ–¹å„ªå‹¢è¶Šå¤§ -> **å°è“‹å¤±æ•—** (å¯èƒ½è½‰ç‚ºçŠ¯è¦æˆ–å¼·è¡Œé€²çƒ)ã€‚

### 4.4 é˜²å®ˆäº‹ä»¶ï¼šæŠ„æˆª (Steal)
*   **åŸºç¤æ©Ÿç‡**: **1%**ã€‚
*   **å½±éŸ¿å±¬æ€§**: **[New v2.1 å¢åŠ èº«é«˜ã€æ™ºå•†ã€è·‘ä½ä¿®æ­£]**
    *   **é€²æ”»æ–¹ (Off_Ball)**: `é‹çƒ` + `æ§çƒ` + `å‚³çƒ` - `èº«é«˜` + `é€²æ”»æ™ºå•†` ã€‚
    *   **é˜²å®ˆæ–¹ (Def_Steal)**: `é€Ÿåº¦` (ä¸å¯è¨“ç·´) + `æŠ„æˆª` (å¯è¨“ç·´) + `é˜²å®ˆæ™ºå•†` (ä¸å¯è¨“ç·´) - `èº«é«˜` + `è·‘ä½` (å¯è¨“ç·´)ã€‚
*   **åˆ¤å®šæµç¨‹**:
    *   è¨ˆç®—é›™æ–¹å±¬æ€§å·®å€¼ã€‚
    *   **æœ€çµ‚æ©Ÿç‡** = `1% + (Def_Steal - Off_Ball) * ä¿‚æ•¸`ã€‚
    *   éª° `1-100` <= æœ€çµ‚æ©Ÿç‡ -> **æŠ„æˆªæˆåŠŸ (Turnover)**ã€‚

## 5. æ¯”è³½å¼•æ“ï¼šæŠ•ç±ƒå‘½ä¸­èˆ‡çµç®— (Shooting & Scoring) **(v1.8 é‡æ§‹æŠ•ç±ƒåˆ¤å®šæ©Ÿåˆ¶)**

### 5.1 æŠ•ç±ƒé¡å‹åˆ¤å®š (Shot Type Determination)
è‹¥å‰å ´éšæ®µæœªç™¼ç”Ÿå¤±èª¤æˆ–è¢«å°è“‹ï¼Œé¦–å…ˆæ±ºå®šé€™æ˜¯ä¸€è¨˜ 2 åˆ†çƒé‚„æ˜¯ 3 åˆ†çƒã€‚

*   **é–¾å€¼è¨ˆç®—**: `Threshold = 1 / (é€²æ”»æ–¹å°„ç¨‹ç¸½å’Œ / 100)`ã€‚
*   **åˆ¤å®š**: éª°ä¸€å€‹éš¨æ©Ÿæ•¸ `R` (0.0 ~ 1.0)ã€‚
    *   è‹¥ `R > Threshold`: **+3 åˆ†** (ä¸‰åˆ†çƒ)ã€‚
    *   è‹¥ `R <= Threshold`: **+2 åˆ†** (å…©åˆ†çƒ)ã€‚
*   *é‚è¼¯é©—è­‰*: å°„ç¨‹è¶Šé«˜ -> Threshold è¶Šå° -> R å¤§æ–¼å®ƒçš„æ©Ÿç‡è¶Šé«˜ -> è¶Šå®¹æ˜“æ˜¯ä¸‰åˆ†ã€‚
*   **è¼¸å‡º**: æ±ºå®šæœ¬å›åˆçš„ **åŸºç¤å‘½ä¸­ç‡ (Base Rate)**ã€‚ **(v1.7 æ–°å¢ä¸‰åˆ†çƒ)**
    *   **å…©åˆ†çƒ**: **40%**
    *   **ä¸‰åˆ†çƒ**: **20%**

### 5.2 å‘½ä¸­ç‡åˆ¤å®š (Hit Rate Calculation)
ä¾æ“šæŠ•ç±ƒé¡å‹èˆ‡é›™æ–¹å±¬æ€§è¨ˆç®—æœ€çµ‚å‘½ä¸­ç‡ã€‚

#### A. å±¬æ€§æ± å®šç¾© **[New v2.1 å¢åŠ èº«é«˜ã€ä¸‰åˆ†çƒåŠ æˆä¿®æ­£]**
*   **é€²æ”»æ–¹ç¸½å’Œ (Off_Total)**:
    *   `åŠ›é‡` + `é€Ÿåº¦` + `å½ˆè·³` + `æ‰‹æ„Ÿ` + `å‡ºæ‰‹é€Ÿåº¦` + `é€²æ”»æ™ºå•†` + `é‹æ°£` + `æŠ•ç±ƒæŠ€å·§` + `å°„ç¨‹` + `è·‘ä½` + `é‹çƒ` + `å‚³çƒ` + `æ§çƒ` + `èº«é«˜` (å…± 14 é …)ã€‚
    *   **3åˆ†çƒç‰¹æ®ŠåŠ æˆ**: è‹¥åˆ¤å®šç‚º 3åˆ†çƒï¼Œå‰‡ `shot_accuracy` ã€ `shot_range` èˆ‡ `off_move` çš„æ•¸å€¼ **x 1.2** è¨ˆç®—ã€‚
*   **é˜²å®ˆæ–¹ç¸½å’Œ (Def_Total)**:
    *   `åŠ›é‡` + `é€Ÿåº¦` + `å½ˆè·³` + `æ‰‹æ„Ÿ` + `å‡ºæ‰‹é€Ÿåº¦` + `é˜²å®ˆæ™ºå•†` + `é‹æ°£` + `èº«é«˜` + `å¡ä½` + `å¹²æ“¾` + `æŠ„æˆª` + `è·‘ä½` (å…± 12 é …)ã€‚

#### B. æŠ€å·§åŠ æˆ (Skill Bonus) [New v2.2]
é‡å°å‡ºæ‰‹è€…å€‹äººèƒ½åŠ›é€²è¡Œé¡å¤–ä¿®æ­£ï¼Œä½¿é«˜æ•¸å€¼å°„æ‰‹æ›´å…·å„ªå‹¢ã€‚
*   **å…¬å¼**: `Skill_Bonus = 1 + (å‡ºæ‰‹è€….shot_accuracy + å‡ºæ‰‹è€….shot_range + å‡ºæ‰‹è€….off_move) / 800`
*   *èªªæ˜*: ä¸‰é …å±¬æ€§æ»¿å€¼ (99+99+99) ç´„æä¾› 1.37 å€ç‡ï¼›å±¬æ€§å’Œ 100 ç´„æä¾› 1.12 å€ç‡ã€‚

#### C. æœ€çµ‚è¨ˆç®—å…¬å¼
*   **å°æŠ—ä¿®æ­£**: `Diff_Mod = (Off_Total - Def_Total) / Def_Total`
*   **å‘½ä¸­ç‡**: `(åŸºç¤å‘½ä¸­ç‡ + Diff_Mod) * Skill_Bonus * (1 + ç©ºé–“åŠ æˆ*0.1) * (1 + å“è³ªåŠ æˆ)`ã€‚
*   **çµç®—**: éª° `0.0 ~ 1.0` <= å‘½ä¸­ç‡ -> **æŠ•ç±ƒå‘½ä¸­**ã€‚

### 5.3 çŠ¯è¦åˆ¤å®š (Foul Check)
ç„¡è«–æ˜¯å¦å‘½ä¸­ï¼Œçš†éœ€é€²è¡ŒçŠ¯è¦æª¢å®šã€‚

*   **å…¬å¼**: `çŠ¯è¦ç‡ = (é€²æ”»æ–¹ IQç¸½å’Œ - é˜²å®ˆæ–¹ IQç¸½å’Œ) / é˜²å®ˆæ–¹ IQç¸½å’Œ`ã€‚
*   **çµç®—**: éª° `0.0 ~ 1.0` <= çŠ¯è¦ç‡ -> **è§¸ç™¼çŠ¯è¦**ã€‚
*   **çµæœ**:
    *   **é€²çƒ + çŠ¯è¦**: And-1 (åŠ ç½° 1 çƒ)ã€‚
    *   **æ²’é€² + çŠ¯è¦**: ç½°çƒ (ä¾æ“š 5.1 åˆ¤å®šç½° 2 çƒæˆ– 3 çƒ)ã€‚
    *   **æ²’é€² + æ²’çŠ¯**: é€²å…¥ç±ƒæ¿åˆ¤å®š (5.4)ã€‚
    *   **é€²çƒ + æ²’çŠ¯**: é€²å…¥åŠ©æ”»åˆ¤å®š (5.5)ã€‚
*   **ç½°çƒå‘½ä¸­ç‡å…¬å¼**:
    *   `éš¨æ©ŸåŸºæ•¸`: åœ¨ **40% ~ 95%** ä¹‹é–“éš¨æ©Ÿç”¢ç”Ÿä¸€å€‹æµ®é»æ•¸ã€‚
    *   `å±¬æ€§åŠ æˆ`: `(ç½°çƒè€…é‹æ°£ + ç½°çƒè€…æ‰‹æ„Ÿ) * 0.01`ã€‚
        *   *è¨»: å…©é …å±¬æ€§ç›¸åŠ  100 é»ç´„æä¾› +1% ä¿®æ­£ã€‚*
        *   *è¨»2: å¦‚æœæ˜¯å¿«æ”»ç™¼ç”Ÿç½°çƒï¼Œå‰‡ç½°çƒè€…=å¿«æ”»åŸ·è¡Œè€…ï¼Œè‹¥éå‰‡ç½°çƒè€…å‰‡ç‚ºåœ˜éšŠç¸½åˆè¨ˆç®—ã€‚*
    *   `æœ€çµ‚ç½°çƒç‡` = `éš¨æ©ŸåŸºæ•¸ + å±¬æ€§åŠ æˆ`ã€‚

### 5.4 ç±ƒæ¿åˆ¤å®š (Rebound) **[New v2.1 å¢åŠ èº«é«˜åŠ æˆä¿®æ­£]**
è‹¥æŠ•ç±ƒæœªä¸­ä¸”æœªçŠ¯è¦ï¼Œé€²è¡Œç±ƒæ¿çˆ­å¥ªã€‚

#### A. å±¬æ€§æ± å®šç¾©
*   **é€²æ”»æ–¹ (Off_Reb_Stat)**: `é€²æ”»æ™ºå•†` + `ç±ƒæ¿` + `å¡ä½` + `èº«é«˜`ã€‚
*   **é˜²å®ˆæ–¹ (Def_Reb_Stat)**: `é˜²å®ˆæ™ºå•†` + `ç±ƒæ¿` + `å¡ä½` + `èº«é«˜`ã€‚

#### B. é˜²å®ˆç±ƒæ¿æ©Ÿç‡ (Def_Reb_Rate)
*   **å…¬å¼**: `10% + Def_Reb_Stat / (Off_Reb_Stat + Def_Reb_Stat)`ã€‚
*   *èªªæ˜*: åŸºç¤ 10% å„ªå‹¢ + é›™æ–¹å±¬æ€§ä½”æ¯”ã€‚é˜²å®ˆæ–¹é€šå¸¸ä½”å„ªã€‚

#### C. çµç®—
*   éª° `0.0 ~ 1.0` <= é˜²å®ˆç±ƒæ¿æ©Ÿç‡ -> **é˜²å®ˆç±ƒæ¿** (æ”»å®ˆäº¤æ›)ã€‚
*   éª° `0.0 ~ 1.0` > é˜²å®ˆç±ƒæ¿æ©Ÿç‡ -> **é€²æ”»ç±ƒæ¿** (é€²æ”»æ–¹é‡ç½®æ™‚é–“ç‚º 14ç§’ï¼Œç¹¼çºŒé€²æ”»)ã€‚

### 5.5 åŠ©æ”»åˆ¤å®š (Assist) - *åƒ…é€²çƒå¾Œè¨ˆç®—*
*   **A. åŠ©æ”»ç™¼ç”Ÿåˆ¤å®š**:
    *   **åœ˜éšŠå±¬æ€§**: `Team_Stat` = é€²æ”»æ–¹ 5 äºº (`é€²æ”»æ™ºå•†`+`æ§çƒ`+`å‚³çƒ`+`è·‘ä½`) ç¸½å’Œã€‚
    *   **æ©Ÿç‡**: `(Team_Stat / åŠ©æ”»ä¿‚æ•¸) * 0.01` (åŠ©æ”»ä¿‚æ•¸ = 1 / åœ˜éšŠ5äººå¹¸é‹ç¸½å’Œ)ã€‚
    *   è‹¥åˆ¤å®šé€šéï¼Œå‰‡è©²æ¬¡å¾—åˆ†è¨˜ç‚ºåŠ©æ”»ã€‚
*   **B. åŠ©æ”»è€…åˆ†é…**:
    *   **æ¬Šé‡**: å ´ä¸ŠéšŠå‹çš„ (`æ§çƒ` + `å‚³çƒ`) æ•¸å€¼ã€‚
    *   **åˆ†é…**: ä¾æ¬Šé‡æ¯”ä¾‹éš¨æ©Ÿåˆ†é…çµ¦å…¶ä¸­ä¸€äºº ((`æ§çƒ` + `å‚³çƒ`) è¶Šé«˜è€… æ©Ÿç‡è¼ƒé«˜)ã€‚

## 6. æ•¸æ“šæ­¸å±¬åˆ¤å®š (Data Attribution)
ç•¶æ¯”è³½å¼•æ“ç”¢ç”Ÿäº‹ä»¶ï¼ˆå¦‚å¾—åˆ†ã€ç±ƒæ¿ã€å¤±èª¤ï¼‰æ™‚ï¼Œç³»çµ±éœ€ä¾æ“šä»¥ä¸‹è¦å‰‡å°‡æ•¸æ“šåˆ†é…çµ¦ç‰¹å®šçƒå“¡ã€‚

### 6.1 æŠ•ç±ƒå‡ºæ‰‹èˆ‡å¾—åˆ† (FGA, FGM, PTS, 3PA, 3PM)
*   è§¸ç™¼æ™‚æ©Ÿ: é€²å…¥ Spec 5.1 æŠ•ç±ƒé¡å‹åˆ¤å®šä¹‹å‰ã€‚
*   å€™é¸äºº: é€²æ”»æ–¹å ´ä¸Š 5 äººã€‚
*   æ¬Šé‡è¨ˆç®— (Weight):
*   åŸºç¤æ¬Šé‡: å¼•ç”¨ Spec 5.2.A ä¹‹ Off_Total å±¬æ€§æ±  (å…±13é …å±¬æ€§ç¸½å’Œ)ã€‚
*   ç‰¹æ®ŠåŠ æˆ:
    *   è‹¥åˆ¤å®šç‚º 3åˆ†çƒå›åˆ: å‡ºæ‰‹é€Ÿåº¦ã€å°„ç¨‹ã€è·‘ä½ æ•¸å€¼ x 2ã€‚
    *   è‹¥åˆ¤å®šç‚º 2åˆ†çƒå›åˆ: ç„¡é¡å¤–å±¬æ€§åŠ æˆã€‚
*   æˆ°è¡“åŠ æˆ:
    *   è§’è‰²ç‚º Star: æœ€çµ‚æ¬Šé‡ x 1.5ã€‚
    *   è§’è‰²ç‚º Starter: æœ€çµ‚æ¬Šé‡ x 1.2ã€‚
*   åˆ†é…é‚è¼¯:
    *   è¨ˆç®—å ´ä¸Š 5 äººæ¬Šé‡ç¸½å’Œã€‚
    *   è¨ˆç®—æ¯äººæ¬Šé‡ä½”æ¯” (Weight / Total)ã€‚
    *   ç”¢ç”Ÿéš¨æ©Ÿæ•¸ R (0.0 ~ 1.0)ã€‚
    *   ç”±æ¬Šé‡ä½”æ¯”æœ€å°çš„çƒå“¡é–‹å§‹ä¾æ¬¡åˆ¤å®šï¼Œè‹¥ R è½åœ¨å…¶å€é–“å…§å‰‡é¸ä¸­ã€‚
*   çµç®—:
    *   é¸ä¸­è€…ç‚º å‡ºæ‰‹è€… (Shooter)ã€‚
    *   è‹¥å‘½ä¸­: ç²å¾— PTS, FGM, (3PM)ã€‚
    *   ç„¡è«–å‘½ä¸­èˆ‡å¦: ç²å¾— FGA, (3PA)ã€‚
### 6.2 ç½°çƒ (FTA, FTM)
*   è§¸ç™¼æ™‚æ©Ÿ: Spec 3.5 (å¿«æ”»çŠ¯è¦) æˆ– Spec 5.3 (æŠ•ç±ƒçŠ¯è¦)ã€‚
*   æ­¸å±¬é‚è¼¯:
    *   å¿«æ”» (Fastbreak): æ­¸å±¬æ–¼ å¿«æ”»åŸ·è¡Œè€… (Runner)ã€‚
    *   é™£åœ°æˆ° (Set Play): æ­¸å±¬æ–¼ å‡ºæ‰‹è€… (Shooter)ã€‚
*   çµç®—: åŸ·è¡Œç½°çƒç²å¾— FTAï¼Œç½°é€²ç²å¾— FTM èˆ‡ PTSã€‚
### 6.3 ç±ƒæ¿çƒ (REB, OR, DR)
*   è§¸ç™¼æ™‚æ©Ÿ: Spec 5.4 åˆ¤å®šæŠ•ç±ƒä¸é€²ä¸”ç„¡çŠ¯è¦ã€‚
*   å€™é¸äºº:
    *   é˜²å®ˆç±ƒæ¿ (DR): é˜²å®ˆæ–¹å ´ä¸Š 5 äººã€‚
    *   é€²æ”»ç±ƒæ¿ (OR): é€²æ”»æ–¹å ´ä¸Š 5 äººã€‚
    *   æ¬Šé‡è¨ˆç®— (Weight):
    *   é€šç”¨å±¬æ€§: åŠ›é‡ + é€Ÿåº¦ + è·‘ä½ã€‚
    *   åŠ æ¬Šå±¬æ€§: èº«é«˜ (*1.5) + å½ˆè·³ (*1.5) + ç±ƒæ¿ (*1.5) + å¡ä½ (*1.5)ã€‚
    *   æ™ºå•†å±¬æ€§: è‹¥ç‚º DR å‰‡åŠ  é˜²å®ˆæ™ºå•†ï¼›è‹¥ç‚º OR å‰‡åŠ  é€²æ”»æ™ºå•†ã€‚
*   åˆ†é…é‚è¼¯:
    *   è¨ˆç®— 5 äººæ¬Šé‡ä½”æ¯”ã€‚
    *   ç”¢ç”Ÿéš¨æ©Ÿæ•¸ R (0.0 ~ 1.0)ã€‚
    *   ç”±æ¬Šé‡ä½”æ¯”æœ€å°çš„çƒå“¡é–‹å§‹ä¾æ¬¡åˆ¤å®š (åŒæŠ•ç±ƒé‚è¼¯)ã€‚
### 6.4 åŠ©æ”» (AST)
*   è§¸ç™¼æ™‚æ©Ÿ: Spec 5.5 åˆ¤å®šã€ŒåŠ©æ”»ç™¼ç”Ÿã€ä¸”æŠ•ç±ƒå‘½ä¸­ã€‚
*   å€™é¸äºº: é€²æ”»æ–¹å ´ä¸Š 5 äºº (æ’é™¤å‡ºæ‰‹è€…)ã€‚
*   æ¬Šé‡è¨ˆç®— (Weight):
    *   AST_Weight = æ§çƒ + å‚³çƒ + é€²æ”»æ™ºå•†ã€‚
*   åˆ†é…é‚è¼¯:
    *   è¨ˆç®—å€™é¸äººæ¬Šé‡ä½”æ¯”ã€‚
    *   ç”¢ç”Ÿéš¨æ©Ÿæ•¸ R (0.0 ~ 1.0)ã€‚
    *   å›ºå®šåˆ¤å®šé †åº: ä¾åºæª¢æŸ¥ C -> PF -> SF -> SG -> PG çš„ç´¯ç©æ©Ÿç‡å€é–“ã€‚
        èªªæ˜: æ­¤é †åºç¢ºä¿åœ¨æµ®é»æ•¸é‚Šç•Œæˆ–åŒæ¬Šé‡ä¸‹ï¼ŒPG æ“æœ‰æœ€å¾Œçš„åˆ¤å®šå„ªå‹¢ (é€šå¸¸æ©Ÿç‡å€é–“æœ€å¤§)ã€‚
### 6.5 æŠ„æˆª (STL)
*   è§¸ç™¼æ™‚æ©Ÿ: Spec 3.4 (å¾Œå ´) æˆ– Spec 4.4 (å‰å ´) åˆ¤å®šæˆåŠŸã€‚
*   å€™é¸äºº: é˜²å®ˆæ–¹å ´ä¸Š 5 äººã€‚
*   æ¬Šé‡è¨ˆç®—:
    *   STL_Weight = æŠ„æˆª + é˜²å®ˆæ™ºå•† + é€Ÿåº¦ + å¹²æ“¾ã€‚
*   åˆ†é…é‚è¼¯: è¨ˆç®—æ¬Šé‡ä½”æ¯”å¾Œéš¨æ©Ÿåˆ†é…ã€‚
### 6.6 å°è“‹ (BLK)
*   è§¸ç™¼æ™‚æ©Ÿ: Spec 4.3 åˆ¤å®šã€Œå°è“‹æˆåŠŸã€ã€‚
*   æ­¸å±¬é‚è¼¯: ç›´æ¥å°ä½åˆ†é…ã€‚
    *   åˆ¤å®š å‡ºæ‰‹è€… (Shooter) çš„ä½ç½® (ä¾‹å¦‚ PG)ã€‚
    *   æ­¸å±¬æ–¼é˜²å®ˆæ–¹ ç›¸åŒä½ç½® çš„çƒå“¡ (é˜²å®ˆæ–¹çš„ PG)ã€‚
### 6.7 å¤±èª¤ (TOV)
*   A. è¢«æŠ„æˆª (Stolen):
    *   è§¸ç™¼: ç™¼ç”Ÿ STL äº‹ä»¶ã€‚
    *   æ­¸å±¬: æŠ„æˆªè€… (Defender) çš„ å°ä½é€²æ”»çƒå“¡ (ä¾‹å¦‚ Defender PG æŠ„æˆª -> Offender PG å¤±èª¤)ã€‚
*   B. 8ç§’/24ç§’é•ä¾‹ (Violation):
    *   æ­¸å±¬: åœ˜éšŠå¤±èª¤ (Team TOV)ã€‚
    *   èªªæ˜: æ­¤é¡å¤±èª¤è¨ˆå…¥çƒéšŠç¸½å¤±èª¤æ•¸ï¼Œä½†ä¸è¨ˆå…¥ä»»ä½•çƒå“¡çš„å€‹äººæ•¸æ“šã€‚

## 7. è¼¸å‡ºæ•¸æ“šå®šç¾© (Output Data Definition) [Update v2.4]
æ¯”è³½å¼•æ“åŸ·è¡Œå®Œç•¢å¾Œï¼Œå°‡å›å‚³ä»¥ä¸‹çµæ§‹åŒ–æ•¸æ“šã€‚

### 7.1 æ¯”è³½çµæœæ‘˜è¦ (Match Result)
*   **è³‡æ–™ä¾†æº**ï¼š`MatchEngine.simulate()` å›å‚³ä¹‹ `MatchResult` ç‰©ä»¶ã€‚

| æ¬„ä½åç¨± | é¡å‹ | èªªæ˜ | å‚™è¨» |
| :--- | :---: | :--- | :--- |
| `game_id` | `str` | æ¯”è³½è­˜åˆ¥ç¢¼ | |
| `home_score` | `int` | ä¸»éšŠå¾—åˆ† | |
| `away_score` | `int` | å®¢éšŠå¾—åˆ† | |
| `is_ot` | `bool` | æ˜¯å¦å»¶é•· | |
| `pace` | `float` | **æ¯”è³½ç¯€å¥** | Pace (Possessions / 48min) |
| `home_possessions` | `int` | **ä¸»éšŠå›åˆæ•¸** | |
| `away_possessions` | `int` | **å®¢éšŠå›åˆæ•¸** | |
| `home_avg_seconds_per_poss` | `float` | **ä¸»éšŠå¹³å‡æ¯å›åˆç§’æ•¸** | |
| `away_avg_seconds_per_poss` | `float` | **å®¢éšŠå¹³å‡æ¯å›åˆç§’æ•¸** | |
| `home_fb_made` | `int` | **ä¸»éšŠå¿«æ”»é€²çƒ** | |
| `home_fb_attempt` | `int` | **ä¸»éšŠå¿«æ”»å˜—è©¦** | |
| `away_fb_made` | `int` | **å®¢éšŠå¿«æ”»é€²çƒ** | |
| `away_fb_attempt` | `int` | **å®¢éšŠå¿«æ”»å˜—è©¦** | |
| `home_violation_8s` | `int` | **ä¸»éšŠ8ç§’é•ä¾‹** | [New v2.4] |
| `home_violation_24s` | `int` | **ä¸»éšŠ24ç§’é•ä¾‹** | [New v2.4] |
| `away_violation_8s` | `int` | **å®¢éšŠ8ç§’é•ä¾‹** | [New v2.4] |
| `away_violation_24s` | `int` | **å®¢éšŠ24ç§’é•ä¾‹** | [New v2.4] |

### 7.2 çƒå“¡çµ±è¨ˆæ•¸æ“š (Player Statistics / Box Score)
*   **è³‡æ–™ä¾†æº**ï¼š`EnginePlayer` ç‰©ä»¶ã€‚

| åˆ†é¡ | æ¬„ä½ä»£è™Ÿ | åç¨± | èªªæ˜ |
| :--- | :--- | :--- | :--- |
| **åŸºç¤** | `stat_pts` | å¾—åˆ† | |
| | `stat_reb` | ç±ƒæ¿ | |
| | `stat_ast` | åŠ©æ”» | |
| | `stat_stl` | æŠ„æˆª | |
| | `stat_blk` | é˜»æ”» | |
| | `stat_tov` | å¤±èª¤ | |
| | `fouls` | çŠ¯è¦ | |
| | `stat_plus_minus` | **æ­£è² å€¼ (+/-)** | çƒå“¡åœ¨å ´æœŸé–“çƒéšŠæ·¨å‹åˆ† |
| **æŠ•ç±ƒ** | `stat_fgm` / `stat_fga` | æŠ•ç±ƒå‘½ä¸­/å‡ºæ‰‹ | |
| | `stat_3pm` / `stat_3pa` | ä¸‰åˆ†å‘½ä¸­/å‡ºæ‰‹ | |
| | `stat_ftm` / `stat_fta` | ç½°çƒå‘½ä¸­/å‡ºæ‰‹ | |
| **é€²éš** | `stat_orb` / `stat_drb` | é€²/é˜²ç±ƒæ¿ | |
| | `stat_fb_made` | **å¿«æ”»é€²çƒ** | |
| | `stat_fb_attempt` | **å¿«æ”»å˜—è©¦** | |
| | `stat_remaining_stamina` | **å‰©é¤˜é«”åŠ›** | |
| | `seconds_played` | ä¸Šå ´æ™‚é–“ | |

### 7.3 åœ˜éšŠçµ±è¨ˆæ•¸æ“š (Team Statistics)
*   **è³‡æ–™ä¾†æº**ï¼š`EngineTeam` ç‰©ä»¶ã€‚

| æ¬„ä½ä»£è™Ÿ | åç¨± | èªªæ˜ |
| :--- | :--- | :--- |
| `score` | åœ˜éšŠç¸½åˆ† | |
| `stat_tov` | åœ˜éšŠå¤±èª¤ | åŒ…å« 8ç§’/24ç§’é•ä¾‹ç­‰éå€‹äººå¤±èª¤ |
| `stat_violation_8s` | **8ç§’é•ä¾‹** | [New v2.4] åœ˜éšŠé•ä¾‹è¨ˆæ•¸ |
| `stat_violation_24s` | **24ç§’é•ä¾‹** | [New v2.4] åœ˜éšŠé•ä¾‹è¨ˆæ•¸ |
| `stat_possessions` | **ç¸½å›åˆæ•¸** | |
| `stat_possession_seconds` | **ç¸½æ§çƒæ™‚é–“** | å–®ä½ï¼šç§’ |
| `stat_fb_made` | **åœ˜éšŠå¿«æ”»é€²çƒ** | |
| `stat_fb_attempt` | **åœ˜éšŠå¿«æ”»å˜—è©¦** | |
```

---

### ğŸ“„ File: `ASBL_Player_System_Specification.md`

```markdown
# ASBL ç±ƒçƒéŠæˆ²çƒå“¡ç³»çµ±è¦æ ¼æ›¸ (v3.5)

**ç‰ˆæœ¬**ï¼š3.5
**æ–‡ä»¶é¡å‹**ï¼šæ ¸å¿ƒé‚è¼¯è¦æ ¼ (Core Logic Specification)
**ç‹€æ…‹**ï¼šå·²å®šæ¡ˆ (Confirmed)
**æœ€å¾Œæ›´æ–°**ï¼š2026-01-30
**è®Šæ›´è¨˜éŒ„**ï¼š
*   **v1.0 (2025-12-03)**ï¼šåˆå§‹ç‰ˆæœ¬ï¼Œå®šç¾©ç”Ÿæˆã€æˆé•·ã€è€åŒ–é‚è¼¯ã€‚
*   **v2.0 (2025-12-03)**ï¼š
    *   **ç§»é™¤**ï¼šé«”é‡ (Weight) ç”Ÿæˆç³»çµ±ã€‚
    *   **ä¿®æ”¹**ï¼šå¯è¨“ç·´èƒ½åŠ›ç”Ÿæˆé‚è¼¯ï¼Œç”±ã€Œå£“ç¸®æ©Ÿåˆ¶ã€æ”¹ç‚ºã€Œé‡éª°æ©Ÿåˆ¶ (Reroll)ã€ï¼Œå…è¨±æ¥µç«¯åç§‘æ•¸å€¼å‡ºç¾ã€‚
*   **v2.1 (2025-12-03)**ï¼š
    *   **ä¿®æ­£**ï¼šç§»é™¤è–ªè³‡å…¬å¼ä¸­çš„ `* 100` å€ç‡ã€‚
    *   **æ ¼å¼**ï¼šå°‡æ•¸å­¸å…¬å¼æ”¹ç‚ºç´”æ–‡å­—æ ¼å¼ä»¥ä¾¿é–±è®€ã€‚
*   **v2.2 (2025-12-03)**ï¼š
    *   **ä¿®æ”¹**ï¼šå§“åç”Ÿæˆé‚è¼¯ï¼Œé‡å°ã€Œå§“æ°ã€è¨­å®šé•·åº¦æ©Ÿç‡ (80/15/5)ã€‚
    *   **æ–°å¢**ï¼šå®šç¾©é–‹éšŠé™£å®¹æª¢æ ¸æ¨™æº– (C>=2, PG>=2, G>=4, F>=4)ã€‚
*   **v2.4 (2025-12-04)**ï¼š
    *   **æ–°å¢**ï¼šçƒå“¡åˆå§‹å¹´é½¡ç”Ÿæˆè¦å‰‡ (SSR å›ºå®š 18 æ­²ï¼Œéš¨ç­‰ç´šä¸‹é™ç¯„åœæ“´å¤§)ã€‚
    *   **æ–°å¢**ï¼šåˆå§‹åˆç´„è¦å‰‡ (å¹´é™èˆ‡è§’è‰²å®šä½èˆ‡ç­‰ç´šæ›é‰¤)ã€‚
*   **v2.5 (2025-12-04)**ï¼š
    *   **æ–°å¢**ï¼šç¬¬ 6 ç« ã€Œä¸Šå ´æ™‚é–“åˆ†é…ç³»çµ± (Minutes Distribution System)ã€ã€‚
    *   **å®šç¾©**ï¼šå„è§’è‰²å®šä½ (Role) çš„ä¿åº•æ™‚é–“èˆ‡æ¬Šé‡æµ®å‹•ç¯„åœã€‚
    *   **æ¼”ç®—æ³•**ï¼šå®šç¾©åŸºæ–¼æ¬Šé‡çš„å‹•æ…‹æ™‚é–“åˆ†é…å…¬å¼ã€‚
*   **v2.6 (2025-12-11)**ï¼š
    *   **æ–°å¢**ï¼šçƒå“¡å±¬æ€§çš„æ¬„ä½å®šç¾©ã€‚
    *   **ç”¨é€”**ï¼šç¢ºä¿å¾ŒçºŒè¨­è¨ˆç¨‹å¼æ™‚èƒ½ä¿æŒä¸€è‡´æ€§ã€‚
*   **v3.1 (2025-12-22)**ï¼š
    *   **é‡æ§‹**ï¼šé‡æ–°å®šç¾©çƒå“¡ç”Ÿæˆæµç¨‹é †åº (å§“å -> ç­‰ç´š -> å¤©è³¦ -> èº«é«˜ -> ä½ç½® -> èƒ½åŠ› -> å¹´é½¡)ã€‚
    *   **æ¢å¾©**ï¼šåŠ å› `2.3.1` å¤©è³¦ (Untrainable) çš„è©³ç´°æ•¸å€¼å€é–“å®šç¾© (Sum/Stat Range)ã€‚
    *   **æ–°å¢**ï¼š`2.4.2` å¯è¨“ç·´èƒ½åŠ› (Trainable) çš„ **ä½ç½®æª¢æ ¸æ©Ÿåˆ¶ (Position Validation)**ã€‚
    *   **æ–°å¢**ï¼š`2.4.3` å¯è¨“ç·´èƒ½åŠ› (Trainable) çš„ **èº«é«˜ä¿®æ­£æ©Ÿåˆ¶ (Height Modifier)**ï¼ŒåŒ…å«è£œå„Ÿ (Bonus) èˆ‡æ‡²ç½° (Penalty) é‚è¼¯ã€‚
*   **v3.2 (2025-12-24)**ï¼š
    *   **æ–°å¢**ï¼š`5.4` é–‹éšŠçƒå“¡ç‰¹æ®Šç”Ÿæˆè¦å‰‡ (Initial Roster Rules)ï¼Œå®šç¾©åƒ…åœ¨é–‹éšŠæ™‚å¥—ç”¨ **50% èƒ½åŠ›ä¸‹é™**ï¼Œä»¥ç¸®å°åˆå§‹éš¨æ©Ÿç¯„åœã€‚
*   **v3.3 (2025-12-28)**ï¼š
    *   **æ–°å¢**ï¼š`5.2` ä½ç½®æª¢æ ¸æ¢ä»¶æ–°å¢é«˜éšä½ç½®è¦†è“‹ã€‚
*   **v3.4 (2026-01-25)**ï¼š
    *   **ä¿®æ”¹**ï¼šå§“åç”Ÿæˆé‚è¼¯é‡æ§‹ã€‚
*   **v3.5 (2026-01-30)**ï¼š
    *   **ä¿®æ”¹**ï¼šé–‹éšŠé™£å®¹æª¢æ ¸é‚è¼¯é‡æ§‹ã€‚

---

## 1. ç³»çµ±æ¦‚è¿°
æœ¬æ–‡ä»¶å®šç¾©äº† ASBL (Advanced Simulation Basketball League) ä¸­çƒå“¡ç”Ÿæˆã€èƒ½åŠ›å€¼åˆ†é…ã€æˆé•·èˆ‡è€åŒ–æ©Ÿåˆ¶çš„æ ¸å¿ƒé‚è¼¯ã€‚è¨­è¨ˆç›®æ¨™æ˜¯å‰µé€ ä¸€å€‹å…·å‚™é«˜åº¦ç­–ç•¥æ€§ã€éš¨æ©Ÿæ€§èˆ‡ç¶“ç‡Ÿæ·±åº¦çš„ç±ƒçƒæ¨¡æ“¬ç’°å¢ƒã€‚

---

## 2. çƒå“¡ç”Ÿæˆç³»çµ± (Player Generation)

### 2.0 çƒå“¡ç”Ÿæˆæµç¨‹ (Player Generation Workflow)
æœ¬ç« ç¯€æè¿°å–®ä¸€çƒå“¡ç”Ÿæˆçš„æ¨™æº–ä½œæ¥­ç¨‹åº (SOP)ï¼Œç¨‹å¼å¯¦ä½œéœ€åš´æ ¼éµå®ˆæ­¤é †åºï¼Œå› ç‚ºå¾ŒçºŒæ­¥é©Ÿä¾è³´å‰åºæ­¥é©Ÿçš„ç”¢å‡ºã€‚

**åŸ·è¡Œé †åº**ï¼š
1.  **æ±ºå®šå§“å** (Name)
2.  **æ±ºå®šç­‰ç´š** (Grade)
3.  **ç”Ÿæˆå¤©è³¦** (Untrainable Stats - ä¾æ“šç­‰ç´š)
4.  **æ±ºå®šèº«é«˜** (Height)
5.  **æ±ºå®šä½ç½®** (Position - ä¾æ“šèº«é«˜)
6.  **ç”Ÿæˆèƒ½åŠ›** (Trainable Stats - ä¾æ“šç­‰ç´šã€ä½ç½®ã€èº«é«˜)
7.  **ç”Ÿæˆå¹´é½¡** (Age - ä¾æ“šç­‰ç´š)

---

### 2.1 å§“åç”Ÿæˆ (Name Generation)

*   **è³‡æ–™ä¾†æº**ï¼š`system_name_library` è³‡æ–™è¡¨ã€‚
*   **ç”Ÿæˆæµç¨‹**ï¼š
    1.  **æ±ºå®šèªç³»**ï¼šå¾è³‡æ–™åº«ç¾æœ‰ `language` åˆ—è¡¨ä¸­ï¼Œä¾ç…§ `weight` æ¬Šé‡éš¨æ©ŸæŠ½å– 1 å€‹èªç³»ä»£ç¢¼ã€‚
    2.  **ä¾èªç³»åŸ·è¡Œç­–ç•¥**ï¼šæ ¹æ“šæŠ½å–åˆ°çš„èªç³»ï¼Œé¸æ“‡å°æ‡‰çš„ç”Ÿæˆç­–ç•¥ (A, B, æˆ– C)ã€‚
    3.  **çµ„åˆè¼¸å‡º**ï¼šç”¢å‡ºæœ€çµ‚çš„ `FullName`ã€‚

---

#### ç­–ç•¥ Aï¼šæ­ç¾èªç³» (Western Style)
*   **é©ç”¨èªç³»**ï¼š`en` (è‹±), `es` (è¥¿), `pt` (è‘¡), `ru` (ä¿„), `de` (å¾·), `fr` (æ³•), `it` (ç¾©)
*   **è¦å‰‡**ï¼š
    1.  åœ¨è©²èªç³»ç¯„åœå…§ï¼ˆä¸åˆ† `category`ï¼‰ï¼Œä¾ç…§æ¬Šé‡éš¨æ©ŸæŠ½å– **3 å€‹** å…§å®¹ã€‚
*   **çµ„åˆ**ï¼š
    *   å°‡ 3 å€‹å…§å®¹çµ„åˆæˆä¸€å€‹åå­—ã€‚
    *   **æ ¼å¼**ï¼šåŠ å…¥é–“éš”è™Ÿ`ãƒ»` (å¦‚ï¼š`æ›¼å¼—é›·å¾·ãƒ»æå¥§ãƒ»å–¬ä¸¹`)ï¼Œè¦–å…·é«”éœ€æ±‚å¯èª¿æ•´åˆ†éš”ç¬¦ã€‚

#### ç­–ç•¥ Bï¼šæ±äºèªç³» (East Asian Style)
*   **é©ç”¨èªç³»**ï¼š`zh` (ä¸­), `ja` (æ—¥), `ko` (éŸ“)
*   **è¦å‰‡**ï¼š
    1.  **æŠ½å§“æ°**ï¼šå¾è©²èªç³»ä¸” `category = 'surname'` çš„ç¯„åœä¸­ï¼Œä¾ç…§æ¬Šé‡æŠ½å– 1 å€‹ã€‚
    2.  **æŠ½åå­— (å­—1)**ï¼šå¾è©²èªç³»ä¸” `category = 'given_name'` çš„ç¯„åœä¸­ï¼Œä¾ç…§æ¬Šé‡æŠ½å– 1 å€‹ã€‚
    3.  **åˆ¤å®šåå­— (å­—2)**ï¼š
        *   **70% æ©Ÿç‡**ï¼šå†å¾ `given_name` æŠ½å–ç¬¬ 2 å€‹åå­—ï¼ˆæ§‹æˆé›™å­—åï¼‰ã€‚
        *   **30% æ©Ÿç‡**ï¼šä¸æŠ½å–ï¼ˆæ§‹æˆå–®å­—åï¼‰ã€‚
*   **çµ„åˆ**ï¼š
    *   ä¾åºæ‹¼æ¥ï¼š`å§“` + `å1` [+ `å2`] (å¦‚ï¼š`æ—è±ª` æˆ– `æ—å¿—è±ª`)ã€‚
    *   **æ ¼å¼**ï¼šç„¡åˆ†éš”ç¬¦ã€‚

#### ç­–ç•¥ Cï¼šå°ç£åŸä½æ°‘èªç³» (Indigenous Style)
*   **é©ç”¨èªç³»**ï¼š`tw_aboriginal` (æˆ–å…¶ä»–å®šç¾©çš„åŸä½æ°‘èªç³»ä»£ç¢¼)
*   **è¦å‰‡**ï¼š
    1.  åœ¨è©²èªç³»ç¯„åœå…§ï¼Œéš¨æ©ŸæŠ½å– **2 å€‹** **ä¸é‡è¤‡** çš„å…§å®¹ã€‚
*   **çµ„åˆ**ï¼š
    *   æ‹¼æ¥é€™å…©å€‹å…§å®¹ã€‚
    *   **æ ¼å¼**ï¼šåŠ å…¥é–“éš”è™Ÿ`ãƒ»` (å¦‚ï¼š`ç“¦æ­·æ–¯ãƒ»è«¾å¹¹`)ã€‚

---

#### è³‡æ–™åº«çµæ§‹åƒè€ƒ (Reference)

```sql
CREATE TABLE `system_name_library` (
  `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT 'å”¯ä¸€è­˜åˆ¥ç¢¼',
  `language` varchar(16) NOT NULL COMMENT 'èªç³»ä»£ç¢¼ (en, cn, jp, tw_indigenous...)',
  `category` varchar(16) NOT NULL COMMENT 'é¡åˆ¥ (surname, given_name, template)',
  `content` varchar(64) NOT NULL COMMENT 'ä¸­æ–‡éŸ³è­¯å…§å®¹',
  `length` int unsigned GENERATED ALWAYS AS (char_length(`content`)) STORED COMMENT 'å…§å®¹å­—æ•¸',
  `weight` int unsigned NOT NULL DEFAULT '10' COMMENT 'å‡ºç¾æ¬Šé‡',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uq_lang_content` (`language`,`content`),
  KEY `idx_lang_cat_weight` (`language`,`category`,`weight`)
) COMMENT='[ç³»çµ±] å¤šåœ‹èªç³»å§“åè©åº«';
```

---

### 2.2 ç­‰ç´šèˆ‡å¤©è³¦ç”Ÿæˆ (Grade & Untrainable Stats)

#### 2.2.1 æ±ºå®šç­‰ç´š
*   **æ©Ÿç‡åˆ†ä½ˆ**ï¼š
    *   **G**: 28% | **C**: 26% | **B**: 22% | **A**: 14%
    *   **S**: 7% | **SS**: 2.5% | **SSR**: 0.5%

#### 2.2.2 ç”Ÿæˆä¸å¯è¨“ç·´èƒ½åŠ› (Untrainable Stats)
*   **å®šç¾©**ï¼šä»£è¡¨çƒå“¡çš„å¤©è³¦ï¼Œç”Ÿæˆå¾Œç„¡æ³•é€éè¨“ç·´æå‡ã€‚
*   **é …ç›® (10é …)**ï¼š`é«”åŠ›`, `åŠ›é‡`, `é€Ÿåº¦`, `å½ˆè·³`, `æ‰‹æ„Ÿ`, `å‡ºæ‰‹é€Ÿåº¦`, `é€²æ”»æ™ºå•†`, `é˜²å®ˆæ™ºå•†`, `å¥åº·`, `é‹æ°£`ã€‚
*   **ç”Ÿæˆè¦å‰‡**ï¼šä¾æ“šç­‰ç´šè¨­å®šçš„ã€Œç¸½å’Œç¯„åœã€èˆ‡ã€Œå–®é …ç¯„åœã€é€²è¡Œéš¨æ©Ÿç”Ÿæˆã€‚

**(V2.6 æ–°å¢)**

| ä¸­æ–‡åç¨± | Config Key (YAML) | DB Field (Storage) | å‚™è¨»èªªæ˜ |
| :--- | :--- | :--- | :--- |
| **é«”åŠ›** | `ath_stamina` | `physical.stamina` | å½±éŸ¿é«”åŠ›ä»¥åŠæ¯”è³½ä¸­èƒ½åŠ›è®ŠåŒ– |
| **åŠ›é‡** | `ath_strength` | `physical.strength` | åŸºæœ¬é‹å‹•èƒ½åŠ›ï¼Œå½±éŸ¿æ¯”è³½è¡¨ç¾ |
| **é€Ÿåº¦** | `ath_speed` | `physical.speed` | åŸºæœ¬é‹å‹•èƒ½åŠ›ï¼Œå½±éŸ¿æ¯”è³½è¡¨ç¾ |
| **å½ˆè·³** | `ath_jump` | `physical.jumping` | åŸºæœ¬é‹å‹•èƒ½åŠ›ï¼Œå½±éŸ¿æ¯”è³½è¡¨ç¾ |
| **å¥åº·** | `talent_health` | `physical.health` | å½±éŸ¿å—å‚·æ©Ÿç‡èˆ‡é«”åŠ›æ¢å¾©åŠ æˆ (éš±è—æ•¸å€¼) |
| **æ‰‹æ„Ÿ** | `shot_touch` | `offense.touch` | å½±éŸ¿æŠ•ç±ƒå‘½ä¸­åˆ¤å®š |
| **å‡ºæ‰‹é€Ÿåº¦** | `shot_release` | `offense.release` | å½±éŸ¿æŠ•ç±ƒå‘½ä¸­åˆ¤å®š |
| **é€²æ”»æ™ºå•†** | `talent_offiq` | `mental.off_iq` | å½±éŸ¿æŠ•ç±ƒå‘½ä¸­åˆ¤å®šèˆ‡é€²æ”»äº‹ä»¶ |
| **é˜²å®ˆæ™ºå•†** | `talent_defiq` | `mental.def_iq` | å½±éŸ¿æŠ•ç±ƒå‘½ä¸­åˆ¤å®šèˆ‡é˜²å®ˆäº‹ä»¶ |
| **é‹æ°£** | `talent_luck` | `mental.luck` | å½±éŸ¿æ‰€æœ‰æ©Ÿç‡äº‹ä»¶çš„å¾®å¹…ä¿®æ­£ (éš±è—æ•¸å€¼) |

| ç­‰ç´š | ç¸½å’Œä¸‹é™ (Sum Min) | ç¸½å’Œä¸Šé™ (Sum Max) | å–®é …ä¸‹é™ (Stat Min) | å–®é …ä¸Šé™ (Stat Max) |
| :--- | :--- | :--- | :--- | :--- |
| **G** | 10 | 400 | 1 | 99 |
| **C** | 399 | 600 | 1 | 99 |
| **B** | 599 | 700 | 1 | 99 |
| **A** | 699 | 800 | 10 | 99 |
| **S** | 799 | 900 | 20 | 99 |
| **SS** | 900 | 950 | 30 | 99 |
| **SSR**| 951 | 990 | 91 | 99 |

---

### 2.3 èº«é«˜èˆ‡ä½ç½® (Height & Position)
*   **2.3.1 èº«é«˜ç”Ÿæˆ**ï¼š
    *   æ¼”ç®—æ³•ï¼šBox-Muller Transform (å¸¸æ…‹åˆ†ä½ˆ)ã€‚
    *   åƒæ•¸ï¼šå¹³å‡å€¼ (Mean) **195cm**ï¼Œæ¨™æº–å·® (SD) **10**ã€‚
    *   ç¯„åœé™åˆ¶ï¼š**160cm ~ 230cm** (è¶…å‡ºç¯„åœéœ€é‡éª°)ã€‚
*   **2.3.2 ä½ç½®åˆ¤å®š**ï¼šç”±èº«é«˜æ±ºå®šæ©Ÿç‡åˆ†ä½ˆ (éçµ•å°åˆ‡æ–·)ã€‚
    *   **< 190cm**ï¼šPG (60%), SG (40%)
    *   **190-199cm**ï¼šPG (35%), SG (45%), SF (20%)
    *   **200-209cm**ï¼šPF (50%), C (15%), SF (20%), SG (10%), PG (5%)
    *   **>= 210cm**ï¼šC (45%), PF (30%), SF (10%), SG (10%), PG (5%)

---

### 2.4 å¯è¨“ç·´èƒ½åŠ›ç”Ÿæˆ (Trainable Stats Generation)
æ­¤æ­¥é©Ÿç‚ºç”Ÿæˆæµç¨‹ä¸­æœ€è¤‡é›œçš„ç’°ç¯€ï¼Œéœ€ç¶œåˆè€ƒé‡ç­‰ç´šä¸Šé™ã€ä½ç½®æª¢æ ¸èˆ‡èº«é«˜ä¿®æ­£ã€‚

*   **é …ç›® (10é …)**ï¼š`æŠ•ç±ƒæŠ€å·§`, `å°„ç¨‹`, `ç±ƒæ¿`, `å¡ä½`, `å¹²æ“¾`, `æŠ„æˆª`, `è·‘ä½`, `é‹çƒ`, `å‚³çƒ`, `æ§çƒ`ã€‚

**(V2.6 æ–°å¢)**

| ä¸­æ–‡åç¨± | Config Key (YAML) | DB Field (Storage) | å‚™è¨»èªªæ˜ |
| :--- | :--- | :--- | :--- |
| **æŠ•ç±ƒæŠ€å·§** | `shot_accuracy` | `offense.accuracy` | å½±éŸ¿æŠ•ç±ƒå‘½ä¸­åˆ¤å®š |
| **å°„ç¨‹** | `shot_range` | `offense.range` | å½±éŸ¿æŠ•ç±ƒå‘½ä¸­åˆ¤å®š |
| **å‚³çƒ** | `off_pass` | `offense.passing` | å½±éŸ¿é€²æ”»äº‹ä»¶ |
| **é‹çƒ** | `off_dribble` | `offense.dribble` | å½±éŸ¿é€²æ”»äº‹ä»¶ |
| **æ§çƒ** | `off_handle` | `offense.handle` | å½±éŸ¿é€²æ”»äº‹ä»¶ |
| **è·‘ä½** | `off_move` | `offense.move` | å½±éŸ¿é€²æ”»äº‹ä»¶åŠé˜²å®ˆäº‹ä»¶ |
| **ç±ƒæ¿** | `def_rebound` | `defense.rebound` | å½±éŸ¿ç±ƒæ¿äº‹ä»¶ |
| **å¡ä½** | `def_boxout` | `defense.boxout` | å½±éŸ¿ç±ƒæ¿äº‹ä»¶ |
| **å¹²æ“¾** | `def_contest` | `defense.contest` | å½±éŸ¿é˜²å®ˆäº‹ä»¶ |
| **æŠ„æˆª** | `def_disrupt` | `defense.disrupt` | å½±éŸ¿é˜²å®ˆäº‹ä»¶ |

#### 2.4.1 åŸºç¤ç”Ÿæˆè¦å‰‡ (Base Logic)
1.  **éš¨æ©Ÿç”Ÿæˆ**ï¼šæ¯é …èƒ½åŠ›åœ¨ **1~99** ä¹‹é–“éš¨æ©Ÿç”Ÿæˆã€‚
2.  **åå‘ç¸½ä¸Šé™é™åˆ¶ (Reverse Cap)**ï¼š
    *   **è¨­è¨ˆæ„åœ–**ï¼šä½ç­‰ç´šçƒå“¡ (G) æ“æœ‰è¼ƒé«˜çš„åˆå§‹èƒ½åŠ›ä¸Šé™ï¼Œä»£è¡¨ã€Œå³æˆ°åŠ›ã€ï¼›é«˜ç­‰ç´šçƒå“¡ (SSR) åˆå§‹èƒ½åŠ›å—é™ï¼Œä»£è¡¨éœ€åŸ¹é¤Šçš„ã€Œç’ç‰ã€ã€‚ (**v3.2 è£œå……**)
    *   **G**: 800 | **C**: 700 | **B**: 650 | **A**: 600 | **S/SS/SSR**: 550
    *   *é‚è¼¯*ï¼šè‹¥ç¸½å’Œ > ä¸Šé™ï¼Œå‰‡è¦–ç‚ºç„¡æ•ˆï¼Œè§¸ç™¼ **Reroll**ã€‚

#### 2.4.2 ä½ç½®æª¢æ ¸æ©Ÿåˆ¶ (Position Validation)
åœ¨åŸºç¤ç”Ÿæˆç¬¦åˆã€Œåå‘ç¸½ä¸Šé™ã€å¾Œï¼Œéœ€é¡å¤–æª¢æŸ¥æ•¸å€¼åˆ†ä½ˆæ˜¯å¦ç¬¦åˆã€Œä½ç½®ç‰¹å¾µã€ã€‚è‹¥ä¸ç¬¦åˆï¼Œè¦–ç‚ºç„¡æ•ˆï¼Œè§¸ç™¼ **Reroll**ã€‚

*   **C / PF (å…§ç·š)**ï¼š
    *   æ¢ä»¶ï¼š`(ç±ƒæ¿ + å¡ä½ + å¹²æ“¾) > (å…¶ä»– 7 é …ç¸½å’Œ)`
*   **SG (å¾—åˆ†å¾Œè¡›)**ï¼š
    *   æ¢ä»¶ï¼š`(å¹²æ“¾ + æŠ„æˆª + å°„ç¨‹) > (å…¶ä»– 7 é …ç¸½å’Œ)`
*   **PG (æ§çƒå¾Œè¡›)**ï¼š
    *   æ¢ä»¶ï¼š`(æŠ„æˆª + é‹çƒ + æ§çƒ + å‚³çƒ) > (å…¶ä»– 6 é …ç¸½å’Œ)`
*   **SF (å°å‰é‹’)**ï¼š
    *   æ¢ä»¶ï¼šç„¡é™åˆ¶ (No Restriction)

#### 2.4.3 èº«é«˜ä¿®æ­£æ©Ÿåˆ¶ (Height Modifiers)
ä¾æ“šèº«é«˜å€é–“ï¼Œå°ç”Ÿæˆçµæœé€²è¡Œã€Œæ¬¡æ•¸æ“‡å„ª/æ“‡å·®ã€èˆ‡ã€Œæ•¸å€¼åŠ æˆã€ã€‚

| èº«é«˜å€é–“ (cm) | ç”Ÿæˆæ¬¡æ•¸ (Trials) | é¸æ“‡é‚è¼¯ | é¡å¤–ä¿®æ­£ (Bonus/Penalty) |
| :--- | :--- | :--- | :--- |
| **160 ~ 169** | **3 æ¬¡** | å–**æœ€é«˜**ç¸½åˆ†è€… | å…¨èƒ½åŠ›ç¸½å’Œ **+30** (æ¬Šé‡åˆ†é…*) |
| **170 ~ 179** | **2 æ¬¡** | å–**æœ€é«˜**ç¸½åˆ†è€… | å…¨èƒ½åŠ›ç¸½å’Œ **+20** (æ¬Šé‡åˆ†é…*) |
| **180 ~ 189** | **1 æ¬¡** | N/A | å…¨èƒ½åŠ› **+1** (ç¸½å’Œ +10) |
| **190 ~ 209** | **1 æ¬¡** | N/A | ç„¡ä¿®æ­£ |
| **210 ~ 219** | **2 æ¬¡** | å–**æœ€ä½**ç¸½åˆ†è€… | ç„¡ä¿®æ­£ |
| **220 ~ 230** | **3 æ¬¡** | å–**æœ€ä½**ç¸½åˆ†è€… | ç„¡ä¿®æ­£ |

*   **æ¬Šé‡åˆ†é…è¦å‰‡ (Weighted Distribution)**ï¼š
    *   é‡å° 160-179cm çš„é¡å¤–åŠ é» (+20/+30)ï¼Œæ¡éš¨æ©Ÿåˆ†é…è‡³ 10 å€‹é …ç›®ã€‚
    *   **é™åˆ¶**ï¼šåˆ†é…æ™‚ï¼ŒPG é—œéµå››é … (`æŠ„æˆª`, `é‹çƒ`, `æ§çƒ`, `å‚³çƒ`) ç²å¾—é»æ•¸çš„æ©Ÿç‡/æ¬Šé‡éœ€ **å¤§æ–¼** å…¶ä»– 6 é …ã€‚
*   **æœ‰æ•ˆæ€§åˆ¤å®š**ï¼šä¸Šè¿°ã€Œç”Ÿæˆæ¬¡æ•¸ã€ä¸­çš„æ¯ä¸€æ¬¡å˜—è©¦ï¼Œéƒ½å¿…é ˆå…ˆé€šé **2.4.1 (ä¸Šé™)** èˆ‡ **2.4.2 (ä½ç½®)** çš„æª¢æ ¸æ‰ç®—ä¸€æ¬¡æœ‰æ•ˆå˜—è©¦ã€‚

---

### 2.5 å¹´é½¡ç”Ÿæˆ (Age Generation) **(v2.4 æ–°å¢)**
*   **åŸºç¤è¦å‰‡**ï¼šSSR ç´šå›ºå®šç‚º 18 æ­²ï¼Œæ¯é™ä¸€ç´šï¼Œå¹´é½¡æµ®å‹•ç¯„åœ (Range) å¢åŠ  1 æ­²ã€‚
*   **å…¬å¼**ï¼š`Age = 18 + Random(0, Grade_Offset)`
*   **å„ç´šå°ç…§**ï¼š
    *   **SSR**: 18 æ­² (å›ºå®š)
    *   **SS**: 18 ~ 19 æ­²
    *   **S**: 18 ~ 20 æ­²
    *   **A**: 18 ~ 21 æ­²
    *   **B**: 18 ~ 22 æ­²
    *   **C**: 18 ~ 23 æ­²
    *   **G**: 18 ~ 24 æ­²

---

## 3. æˆé•·èˆ‡è€åŒ–ç³»çµ± (Growth & Aging)

### 3.1 åŸºç¤åƒæ•¸
*   **è³½å­£è¨­å®š**ï¼š1 è³½å­£ = **91 å¤©** (70 å ´æ¯”è³½)ã€‚
*   **åˆå§‹å¹´é½¡**ï¼š18 æ­²ã€‚
*   **é«”èƒ½æ¥µé™**ï¼šå–®å ´ä¸Šå ´æ™‚é–“ä¸Šé™ç´„ **37 åˆ†é˜**ã€‚

### 3.2 æˆé•·æœŸ (18 - 25 æ­²)
*   **æ©Ÿåˆ¶**ï¼šç´¯ç©ä¸Šå ´æ™‚é–“æ›å–è¨“ç·´é»æ•¸ã€‚
*   **å…¬å¼**ï¼šæ¯ç´¯ç© 48 åˆ†é˜ -> ç²å¾— 1 é»ã€‚
*   **å¹¸é‹ä¿®æ­£ (Luck Modifier)**ï¼š
    *   åŸºæº–å€¼ï¼šLuck 80ã€‚
    *   ä¿®æ­£å…¬å¼ï¼šå¯¦éš›ç²å¾— = åŸºç¤é»æ•¸ * [1 + (Luck - 80) * 1%]ã€‚
    *   *æ•ˆæœï¼šLuck 99 çš„çƒå“¡æˆé•·é€Ÿåº¦å¿« 19%ã€‚*

### 3.3 å·”å³°æœŸ (26 - 29 æ­²)
*   **æ©Ÿåˆ¶**ï¼šæˆé•·é€Ÿåº¦æ”¾ç·©ã€‚
*   **å…¬å¼**ï¼šæ¯ç´¯ç© 144 åˆ†é˜ -> ç²å¾— 1 é»ã€‚
*   **å¹¸é‹ä¿®æ­£**ï¼šåŒä¸Šã€‚

### 3.4 é€€åŒ–æœŸ (30 æ­²ä»¥ä¸Š)
*   **æ©Ÿåˆ¶**ï¼šéç·šæ€§åŠ é€Ÿè€åŒ–ï¼ŒåŒ…å«ã€Œä¸Šå ´ç£¨æã€èˆ‡ã€Œæ­²æœˆæµé€ã€ã€‚
*   **æŠ—æ€§ç³»çµ± (Resilience)**ï¼š
    *   **å¹¸é‹æŠ—æ€§**ï¼š[(Luck - 70) * 1%] (è‹¥ Luck < 70 å‰‡ç‚º 0)ã€‚
    *   **ç­‰ç´šæŠ—æ€§**ï¼šA (1%), S (3%), SS (5%), SSR (10%)ã€‚
    *   **ç¸½æŠ—æ€§** = å¹¸é‹æŠ—æ€§ + ç­‰ç´šæŠ—æ€§ã€‚
*   **æ‰é»å…¬å¼ (è² æˆé•·)**ï¼š
    1.  **ä¸Šå ´ç£¨æ**ï¼šæ»¿ [300 / MAX(1, Age-29)] åˆ†é˜ -> æ‰£ 1 é»ã€‚
        *   *éš¨è‘—å¹´é½¡å¢åŠ ï¼Œåˆ†æ¯è®Šå°ï¼Œæ‰é»é–€æª»é™ä½ã€‚*
    2.  **æ­²æœˆæµé€**ï¼šæ¯ [10 - (Age-30)] å¤© -> æ‰£ 1 é»ã€‚
        *   *éš¨è‘—å¹´é½¡å¢åŠ ï¼Œå¤©æ•¸è®Šå°‘ï¼Œæ‰é»é »ç‡è®Šé«˜ã€‚*
    3.  **æŠ—æ€§æ‡‰ç”¨**ï¼šä¸Šè¿°å…©ç¨®æ‰£é»è¨ˆç®—å‡ºçš„æ•¸å€¼ï¼Œæ‰£é»æ•¸ * (1 - ç¸½æŠ—æ€§)ã€‚
*   **ç·´çƒè£œå„Ÿ**ï¼šæ»¿ [150 * (Age-29)] åˆ†é˜ -> è£œ 1 é»ã€‚

---

## 4. ç¶“æ¿Ÿèˆ‡å…¶ä»– (Economy & Misc)

### 4.1.1 è–ªè³‡è¨ˆç®— (Salary)
*   **å…¬å¼**ï¼šæ‰€æœ‰èƒ½åŠ›ç¸½å’Œ * ç­‰ç´šä¿‚æ•¸ã€‚**(v2.1 æ›´æ–°)**
*   **ç­‰ç´šä¿‚æ•¸**ï¼š
    *   G: 1.0
    *   C: 1.1
    *   B: 1.3
    *   A: 1.6
    *   S: 2.0
    *   SS: 2.5
    *   SSR: 3.0

### 4.1.2 åˆå§‹åˆç´„è¦å‰‡ (Initial Contract) **(v2.4 æ–°å¢)**
çƒå“¡ç”Ÿæˆæ™‚ï¼Œä¾æ“šç­‰ç´šè‡ªå‹•è³¦äºˆåˆå§‹åˆç´„å¹´é™èˆ‡è§’è‰²å®šä½ã€‚

|  ç­‰ ç´š  | åˆç´„å¹´é™  |  è§’è‰²å®šä½ (Role)    | èªªæ˜                                |
| :---    | :---     | :---               | :---                                |
| **SSR** | **4 å­£** | **æ˜æ˜Ÿ (Star)**     | çµ•å°æ ¸å¿ƒï¼Œäº«æœ‰æœ€é«˜è–ªè³‡åŠ æˆèˆ‡ä¸Šå ´æ™‚é–“ã€‚ |
| **SS**  | **4 å­£** | **å…ˆç™¼ (Starter)**  | çƒéšŠä¸»åŠ›ã€‚                           |
| **S**   | **4 å­£** | **å…ˆç™¼ (Starter)**  | çƒéšŠä¸»åŠ›ã€‚                           |
| **A**   | **2 å­£** | **ç¶ è‘‰ (Rotation)** | ä¸»è¦è¼ªæ›¿çƒå“¡ã€‚                       |
| **B**   | **2 å­£** | **ç¶ è‘‰ (Rotation)** | ä¸»è¦è¼ªæ›¿çƒå“¡ã€‚                       |
| **C**   | **1 å­£** | **åŠŸèƒ½ (Role)**     | åŠŸèƒ½æ€§çƒå“¡ï¼Œç‰¹å®šæˆ°è¡“ä½¿ç”¨ã€‚            |
| **G**   | **1 å­£** | **æ¿å‡³ (Bench)**    | é‚Šç·£çƒå“¡/é™ªç·´ï¼Œå¡«è£œåå–®ä½¿ç”¨ã€‚         |

### 4.2 é»æ•¸åˆ†é…
*   **åˆ†é…æ–¹å¼**ï¼š**æ‰‹å‹•åˆ†é… (Manual)**ã€‚
*   **å„²å­˜**ï¼šçƒå“¡ç²å¾—çš„è¨“ç·´é»æ•¸å­˜å…¥ `training_points` æ¬„ä½ï¼Œç”±ç©å®¶æ±ºå®šåŠ åˆ°å“ªä¸€é …å¯è¨“ç·´èƒ½åŠ›ä¸Šã€‚

### 4.3 é«”é‡ (Weight)
*   **(v2.0 å·²ç§»é™¤)**
*   **(v1.0 å…¬å¼ - å·²ç§»é™¤)**ï¼š~~$(\text{Height} - 100) \times 0.9 + \text{Random}(-5, 5)$ã€‚~~

## 5. é–‹éšŠé™£å®¹æª¢æ ¸ (Team Creation Validation) **(v2.2 æ–°å¢ã€v3.2 æ›´æ–°ã€v3.5 æ›´æ–°)**

### 5.1 åŸ·è¡Œé‚è¼¯
ç”Ÿæˆ 15 äººåå–® -> æª¢æŸ¥ã€Œä½ç½®æ•¸é‡ã€èˆ‡ã€Œç­‰ç´šæ•¸é‡ã€ -> è‹¥ä»»ä¸€æ¢ä»¶ä¸ç¬¦åˆï¼Œå‰‡æ•´éšŠé‡éª° (Reroll Team)ã€‚

### 5.2 ä½ç½®æª¢æ ¸æ¢ä»¶
1.  **C**  >= 2
2.  **PG** >= 2
3.  **PG + SG** >= 4
4.  **PF + SF** >= 4
5.  **åˆ†å±¤ä½ç½®è¦†è“‹ (Tiered Position Coverage) [Update v3.5]**:
    *   **é«˜éšçµ„ (High Tier)**:
        *   ç¯„åœï¼š**SSR (1äºº) + SS (1äºº) + S (1äºº) + A (2äºº)**ï¼Œå…± 5 åçƒå“¡ã€‚
        *   æ¢ä»¶ï¼šä¸Šè¿° 5 åçƒå“¡çš„çµ„åˆä¸­ï¼Œå¿…é ˆåŒ…å« **C, PF, SF, SG, PG** äº”å€‹ä½ç½®å„è‡³å°‘ 1 åã€‚
    *   **ä¸­éšçµ„ (Mid Tier)**:
        *   ç¯„åœï¼š**B (3äºº) + C (2äºº)**ï¼Œå…± 5 åçƒå“¡ã€‚
        *   æ¢ä»¶ï¼šä¸Šè¿° 5 åçƒå“¡çš„çµ„åˆä¸­ï¼Œå¿…é ˆåŒ…å« **C, PF, SF, SG, PG** äº”å€‹ä½ç½®å„è‡³å°‘ 1 åã€‚
    *   **ä½éšçµ„ (Low Tier)**:
        *   ç¯„åœï¼š**G (5äºº)**ã€‚
        *   æ¢ä»¶ï¼šç„¡ä½ç½®é™åˆ¶ã€‚
    *   *ç›®çš„ï¼šç¢ºä¿ç©å®¶çš„é«˜éšæ ¸å¿ƒèˆ‡ä¸­å …æˆ°åŠ›é™£å®¹éƒ½æ˜¯å®Œæ•´çš„ï¼Œé¿å…é–‹å±€ä½ç½®åš´é‡é‡ç–Šã€‚*

### 5.3 ç­‰ç´šæª¢æ ¸æ¢ä»¶ (å¼·åˆ¶åˆ†ä½ˆ) [Update v3.5]
*   **SSR**: 1 äºº
*   **SS**: 1 äºº
*   **S**: 1 äºº
*   **A**: 2 äºº
*   **B**: 3 äºº
*   **C**: 2 äºº
*   **G**: 5 äºº

### 5.4 é–‹éšŠçƒå“¡ç‰¹æ®Šç”Ÿæˆè¦å‰‡ (Initial Roster Stat Constraints) **(v3.3 æ–°å¢)**
ç‚ºäº†ç¸®å°é–‹å±€éš¨æ©Ÿç¯„åœï¼Œé¿å…ç©å®¶åˆå§‹éšŠä¼ä¸­å‡ºç¾éå¤šç„¡æ³•ä½¿ç”¨çš„çƒå“¡ï¼Œ**åƒ…åœ¨é–‹éšŠç”Ÿæˆéšæ®µ**å¥—ç”¨ä»¥ä¸‹è¦å‰‡ï¼š

*   **å•Ÿç”¨ä¸‹é™é™åˆ¶ (Enable Lower Bound)**ï¼š
    *   åœ¨åŸ·è¡Œ `2.4.1` åŸºç¤ç”Ÿæˆæ™‚ï¼Œé¡å¤–å¢åŠ ä¸‹é™æª¢æŸ¥ã€‚
    *   **æ¢ä»¶**ï¼š`å¯è¨“ç·´èƒ½åŠ›ç¸½å’Œ` >= `ä¸Šé™ (Upper Cap) * 50%`ã€‚
    *   **åƒæ•¸**ï¼š`initial_team_min_ratio` = **0.5** (å¯æ–¼ YAML é…ç½®)ã€‚

| ç­‰ç´š | é–‹éšŠæ™‚ä¸‹é™ (Min) | é–‹éšŠæ™‚ä¸Šé™ (Max) | èªªæ˜ |
| :--- | :--- | :--- | :--- |
| **G** | **400** | 800 | ç¢ºä¿é–‹éšŠ G ç´šçƒå“¡è‡³å°‘æœ‰åŸºç¤æˆ°åŠ› |
| **C** | **350** | 700 | |
| **B** | **325** | 650 | |
| **A** | **300** | 600 | |
| **S/SS/SSR** | **275** | 550 | |

*   **æ³¨æ„**ï¼šæ­¤è¦å‰‡ä¸é©ç”¨æ–¼éŠæˆ²é–‹å§‹å¾Œçš„é¸ç§€æˆ–è‡ªç”±çƒå“¡ç”Ÿæˆã€‚
    
---

## 6. ä¸Šå ´æ™‚é–“åˆ†é…ç³»çµ± (Minutes Distribution System) **(v2.5 æ–°å¢)**

### 6.1 ç³»çµ±æ¦‚è¿°
æ¯”è³½æ¨¡æ“¬æ™‚ï¼Œç³»çµ±éœ€å°‡ **240 åˆ†é˜** (48åˆ†é˜ x 5äºº) åˆ†é…çµ¦ç™»éŒ„åå–®ä¸­çš„çƒå“¡ã€‚åˆ†é…æ©Ÿåˆ¶æ¡ç”¨ **ã€Œä¿åº•æ™‚é–“ + æ¬Šé‡æµ®å‹•ã€** æ¼”ç®—æ³•ï¼Œç¢ºä¿æ ¸å¿ƒçƒå“¡åœ°ä½ï¼ŒåŒæ™‚ä¿ç•™å–®å ´æ¯”è³½çš„éš¨æ©Ÿæ€§èˆ‡èª¿åº¦å½ˆæ€§ã€‚

### 6.2 è§’è‰²åƒæ•¸è¨­å®š
ä¸åŒåˆç´„è§’è‰²æ“æœ‰ä¸åŒçš„ã€Œä¿åº•æ™‚é–“ (Base)ã€èˆ‡ã€Œæ¬Šé‡ç¯„åœ (Weight Range)ã€ã€‚

| è§’è‰²å®šä½ (Role) | ä¿åº•æ™‚é–“ (Base) | æ¬Šé‡ç¯„åœ (Weight) | èªªæ˜ |
| :--- | :--- | :--- | :--- |
| **æ˜æ˜Ÿ (Star)** | **30 min** | **-1 ~ 5** | çµ•å°ä¸»åŠ›ï¼Œæ³¢å‹•æ¥µå°ï¼Œæ¥µä½æ©Ÿç‡æ‰£æ™‚ã€‚ |
| **å…ˆç™¼ (Starter)** | **20 min** | **-2 ~ 7** | ä¸»åŠ›çƒå“¡ï¼Œæœ‰è¼ƒé«˜æ©Ÿç‡ç²å¾—é¡å¤–æ™‚é–“ã€‚ |
| **ç¶ è‘‰ (Rotation)**| **10 min** | **5 ~ 15** | è¼ªæ›¿æ ¸å¿ƒï¼Œä¸»è¦ç«¶çˆ­å‰©é¤˜æ™‚é–“çš„æ—ç¾¤ã€‚ |
| **åŠŸèƒ½ (Role)** | **0 min** | **5 ~ 12** | ç„¡ä¿åº•ï¼Œéœ€é æ¬Šé‡çˆ­å–ä¸Šå ´ã€‚ |
| **æ¿å‡³ (Bench)** | **0 min** | **0 ~ 10** | é‚Šç·£äººï¼Œæ¬Šé‡ç¯„åœå¤§ï¼Œå¯èƒ½ DNP ä¹Ÿå¯èƒ½çˆ†ç™¼ã€‚ |

### 6.3 åˆ†é…æ¼”ç®—æ³• (Algorithm)

#### æ­¥é©Ÿ 1ï¼šè¨ˆç®—ç¸½ä¿åº•èˆ‡å‰©é¤˜æ™‚é–“
*   `Total_Base` = æ‰€æœ‰çƒå“¡ä¿åº•æ™‚é–“ç¸½å’Œã€‚
*   `Remaining_Time` = 240 - `Total_Base`ã€‚

#### æ­¥é©Ÿ 2ï¼šç”Ÿæˆå–®å ´æ¬Šé‡
*   ç‚ºæ¯ä½çƒå“¡éš¨æ©Ÿç”Ÿæˆä¸€å€‹æ¬Šé‡å€¼ `W` (ä»‹æ–¼è©²è§’è‰²çš„ Min ~ Max ä¹‹é–“)ã€‚
*   `Total_Weight` = æ‰€æœ‰çƒå“¡æ¬Šé‡ç¸½å’Œã€‚

#### æ­¥é©Ÿ 3ï¼šè¨ˆç®—å–®ä½æ™‚é–“åƒ¹å€¼ (Unit Value)
*   `Unit` = `Remaining_Time` / `Total_Weight`ã€‚

#### æ­¥é©Ÿ 4ï¼šè¨ˆç®—å€‹äººæ™‚é–“
*   `Raw_Minutes` = `Base` + (`W` * `Unit`)ã€‚
*   **æ¨å»è¦å‰‡**ï¼šå–è‡³å°æ•¸é»å¾Œç¬¬ä¸€ä½ï¼Œç¬¬äºŒä½ä»¥å¾Œç„¡æ¢ä»¶æ¨å» (Floor)ã€‚
    *   å…¬å¼ï¼š`Final_Minutes = floor(Raw_Minutes * 10) / 10`ã€‚

#### æ­¥é©Ÿ 5ï¼šå°¾æ•¸ä¿®æ­£
*   ç”±æ–¼æ¨å»è¦å‰‡ï¼Œåˆ†é…å¾Œçš„ç¸½æ™‚é–“é€šå¸¸æœƒç•¥å°æ–¼ 240 åˆ†é˜ã€‚
*   **ä¿®æ­£æ–¹å¼**ï¼šå°‡å‰©é¤˜çš„å°¾æ•¸ (é€šå¸¸ < 1 åˆ†é˜) å…¨éƒ¨åŠ çµ¦åå–®ä¸­çš„ **æœ€å¾Œä¸€ä½çƒå“¡**ã€‚

### 6.4 ç¯„ä¾‹æ¨¡æ“¬
å‡è¨­å‰©é¤˜æ™‚é–“ 130 åˆ†é˜ï¼Œç¸½æ¬Šé‡ 65ï¼Œå‰‡ `Unit = 2`ã€‚
*   **Star (W=-1)**: 30 + (-1 * 2) = **28 min**ã€‚
*   **Starter (W=7)**: 20 + (7 * 2) = **34 min** (æ‰‹æ„Ÿç«ç‡™ï¼Œä¸Šå ´æ™‚é–“è¶…è¶Šæ˜æ˜Ÿ)ã€‚
*   **Bench (W=0)**: 0 + (0 * 2) = **0 min** (DNP)ã€‚
```

---

### ğŸ“„ File: `config.py`

```python
# config.py
import os
from dotenv import load_dotenv

# å–å¾—ç›®å‰æª”æ¡ˆçš„ç›®éŒ„
basedir = os.path.abspath(os.path.dirname(__file__))

# è¼‰å…¥ .env æª”æ¡ˆ
load_dotenv(os.path.join(basedir, '.env'))

class Config:
    # 1. å®‰å…¨å¯†é‘°
    # ç¾åœ¨æœƒå„ªå…ˆå¾ .env è®€å–ï¼Œè®€ä¸åˆ°æ‰æœƒç”¨å¾Œé¢çš„é è¨­å€¼
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-fallback-key'

    # 2. è³‡æ–™åº«é€£ç·šè¨­å®š
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'app.db') # é è¨­æ”¹ç‚º SQLite é¿å…å ±éŒ¯

    # 3. æ•ˆèƒ½è¨­å®š
    SQLALCHEMY_TRACK_MODIFICATIONS = False
```

---

### ğŸ“„ File: `DEV_LOG.md`

```markdown
# ASBL Manager - é–‹ç™¼æ—¥èªŒ (Development Log)

## å°ˆæ¡ˆè³‡è¨Š
- **å°ˆæ¡ˆåç¨±**: ASBL Basketball Manager
- **é–‹å§‹æ—¥æœŸ**: 2025-12-03
- **é–‹ç™¼ç’°å¢ƒ**: Python 3.13 + MySQL 9.0 + Flask
- **ç›®å‰éšæ®µ**: Phase 1 - æ ¸å¿ƒæ¶æ§‹ (Core Architecture)

---

## ğŸ“… 2025-12-03 08:00 (Day 1) - å°ˆæ¡ˆåˆå§‹åŒ–

### âœ… å·²å®Œæˆ (Completed)
- [x] **å°ˆæ¡ˆçµæ§‹å»ºç«‹**: 
    - é€£çµ GitHub å„²å­˜åº«ã€‚
    - ä¿®æ­£è³‡æ–™å¤¾å±¤ç´šå•é¡Œã€‚
    - è¨­å®š `.gitignore` æ’é™¤ä¸å¿…è¦æª”æ¡ˆã€‚
- [x] **æ–‡ä»¶æ’°å¯«**:
    - å®Œæˆ `README.md` (åŒ…å«éŠæˆ²è¦å‰‡ V2ã€æŠ€è¡“æ¶æ§‹ã€é–‹ç™¼æ™‚ç¨‹)ã€‚
    - å»ºç«‹ `DEV_LOG.md` (æœ¬æª”æ¡ˆ)ã€‚
- [x] **ç’°å¢ƒè¨­å®š**:
    - å»ºç«‹ `requirements.txt` (Flask, SQLAlchemy, PyMySQL...)ã€‚
    - å»ºç«‹ `config.py` (è³‡æ–™åº«é€£ç·šè¨­å®š)ã€‚
    - å»ºç«‹ Python è™›æ“¬ç’°å¢ƒ (`venv`) ä¸¦å®‰è£ä¾è³´å¥—ä»¶ã€‚

### ğŸš§ é€²è¡Œä¸­ (In Progress)
- [ ] **è³‡æ–™åº«æ¨¡å‹è¨­è¨ˆ**: æº–å‚™å»ºç«‹ `User`, `Team`, `Player` ç­‰ SQLAlchemy Modelsã€‚

### ğŸ“ ç­†è¨˜èˆ‡å•é¡Œ (Notes & Issues)
- **Git æ“ä½œ**: ä¿®æ­£äº†é‡è¤‡ Clone å°è‡´çš„å·¢ç‹€ç›®éŒ„å•é¡Œï¼Œç¾åœ¨çµæ§‹å·²æ‰å¹³åŒ–ã€‚
- **è¦å‰‡ç¢ºèª**: 
    - 65% è–ªè³‡å¸½é™åˆ¶ï¼šè¶…éå¾Œç„¡æ³•é ‚è–ªçºŒç´„ã€‚
    - ç¨€æœ‰åº¦åˆ†ç´šï¼šæ˜ç¢ºå®šç¾© G~SSR åˆ†æ•¸å€é–“ã€‚
    - æŠ•ç±ƒå±¬æ€§ï¼šç´°åˆ†ç‚ºæº–å¿ƒã€ç¯„åœã€æ‰‹æ„Ÿã€å°„é€Ÿã€‚

---

## ğŸ“… å¾…è¾¦äº‹é … (To-Do List)

### Phase 1: æ ¸å¿ƒæ¶æ§‹
- [ ] **è³‡æ–™åº«å»ºç½®**:
    - [ ] å®šç¾© `User` Model (å¸³è™Ÿã€é‚€è«‹ç¢¼)ã€‚
    - [ ] å®šç¾© `Team` Model (è³‡é‡‘ã€è²æœ›)ã€‚
    - [ ] å®šç¾© `Player` Model (åŸºæœ¬è³‡æ–™ã€ç¨€æœ‰åº¦)ã€‚
    - [ ] å®šç¾© `PlayerAttributes` Model (è©³ç´°æ•¸å€¼)ã€‚
    - [ ] å®šç¾© `Contract` Model (è–ªè³‡ã€è§’è‰²)ã€‚
- [ ] **åˆå§‹åŒ–è…³æœ¬**: æ’°å¯« `init_db.py` è®“ç¨‹å¼è‡ªå‹•å»ºè¡¨ã€‚
- [ ] **çƒå“¡ç”Ÿæˆå™¨**: å¯¦ä½œ `PlayerGenerator` class (100æŠ½é‚è¼¯)ã€‚

---

## 2025-12-03 10:00 ï¼šè³‡æ–™åº«æ¶æ§‹èˆ‡ç’°å¢ƒå»ºç½®

### ğŸš§ é€²åº¦æ‘˜è¦
å®Œæˆå°ˆæ¡ˆåŸºç¤å»ºè¨­ï¼Œå»ºç«‹ Flask æ‡‰ç”¨ç¨‹å¼å·¥å» æ¨¡å¼ï¼Œä¸¦æˆåŠŸé€£ç·š MySQL è³‡æ–™åº«ï¼Œå®Œæˆæ ¸å¿ƒè³‡æ–™è¡¨å»ºç½®ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€
1.  **ç’°å¢ƒé…ç½® (Configuration)**
    - å»ºç«‹ `config.py` èˆ‡ `.env` æ©Ÿåˆ¶ï¼Œå°‡æ•æ„Ÿè³‡è¨Šï¼ˆDatabase URL, Secret Keyï¼‰èˆ‡ç¨‹å¼ç¢¼åˆ†é›¢ã€‚
    - è¨­å®š `.gitignore` æ’é™¤ `.env` æª”æ¡ˆï¼Œç¢ºä¿è³‡å®‰ã€‚

2.  **è³‡æ–™åº«æ¨¡å‹ (Database Models)**
    - ä½¿ç”¨ SQLAlchemy å®šç¾© ORM æ¨¡å‹ã€‚
    - **User**: ä½¿ç”¨è€…å¸³è™Ÿç³»çµ±ã€‚
    - **Team**: çƒéšŠç¶“ç‡Ÿè³‡è¨Šï¼ˆè³‡é‡‘ã€è²æœ›ï¼‰ã€‚
    - **Player**: çƒå“¡æ ¸å¿ƒè³‡æ–™ï¼ˆåŒ…å« JSON æ ¼å¼çš„è©³ç´°æ•¸æ“š `detailed_stats`ï¼‰ã€‚
    - **Contract**: çƒå“¡åˆç´„ç³»çµ±ï¼ˆè–ªè³‡ã€å¹´é™ã€å®šä½ï¼‰ã€‚

3.  **è³‡æ–™åº«åˆå§‹åŒ– (Initialization)**
    - æ’°å¯« `scripts/init_db.py` è‡ªå‹•åŒ–å»ºè¡¨è…³æœ¬ã€‚
    - **å„ªåŒ–**: ç‚ºæ‰€æœ‰è³‡æ–™è¡¨ (Table) èˆ‡æ¬„ä½ (Column) åŠ ä¸Š `COMMENT` ä¸­æ–‡è¨»è§£ï¼Œæå‡è³‡æ–™åº«å¯è®€æ€§èˆ‡ç¶­è­·æ€§ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- æ’°å¯«çƒå“¡ç”Ÿæˆæ¼”ç®—æ³• (Gacha System)ã€‚
- å¯¦ä½œã€Œé¦–æŠ½ã€åŠŸèƒ½æ¸¬è©¦ã€‚

---

## 2025-12-03 22:30 ï¼šçƒå“¡ç”Ÿæˆæ ¸å¿ƒèˆ‡é–‹éšŠæ¨¡æ“¬ (Player Generation & Team Simulation)

### âœ… é€²åº¦æ‘˜è¦
å®Œæˆäº†åŸºæ–¼ **Spec v2.3** çš„çƒå“¡ç”Ÿæˆæœå‹™ (`PlayerGenerator`)ï¼Œä¸¦å¯¦ä½œäº†ã€Œé–‹éšŠé™£å®¹æª¢æ ¸ã€é‚è¼¯ï¼Œç¢ºä¿æ–°çƒéšŠèƒ½ç²å¾—ç¬¦åˆæˆ°è¡“éœ€æ±‚ï¼ˆå¦‚ C>=2, PG>=2ï¼‰çš„å®Œæ•´é™£å®¹ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€
1.  **çƒå“¡ç”Ÿæˆæœå‹™ (Player Generator)**
    - **å§“åç³»çµ±**: å¯¦ä½œ `NameLibrary` æ¨¡å‹ï¼Œä¸¦åŠ å…¥å§“æ°é•·åº¦æ©Ÿç‡æ§åˆ¶ (80% å–®å­— / 15% é›™å­— / 5% é•·å­—)ã€‚
    - **èº«é«˜åˆ†ä½ˆ**: æ¡ç”¨ Box-Muller Transform å¯¦ä½œå¸¸æ…‹åˆ†ä½ˆ (Mean 195, SD 10)ã€‚
    - **èƒ½åŠ›å€¼é‡éª° (Reroll)**: å¯¦ä½œã€Œåå‘ç¸½ä¸Šé™ã€èˆ‡ã€Œé‡éª°æ©Ÿåˆ¶ã€ï¼Œå…è¨±å–®é …èƒ½åŠ›å€¼æ¥µç«¯åŒ– (å¦‚ 99) åŒæ™‚ä¿æŒç¸½å¹³è¡¡ã€‚
    - **JSON å„²å­˜**: å°‡è©³ç´°å±¬æ€§çµæ§‹åŒ–å­˜å…¥ `detailed_stats` JSON æ¬„ä½ï¼Œæ”¯æ´ MySQL æŸ¥è©¢ã€‚

2.  **é–‹éšŠæ¨¡æ“¬è…³æœ¬ (Simulation Script)**
    - é–‹ç™¼ `scripts/simulate_team_creation.py`ã€‚
    - **Reroll & Filter**: å¯¦ä½œæ•´éšŠé‡éª°é‚è¼¯ï¼Œç›´åˆ°éš¨æ©Ÿç”Ÿæˆçš„ 15 äººåå–®æ»¿è¶³ä½ç½®èˆ‡ç­‰ç´šé™åˆ¶ã€‚
    - **é©—è­‰é€šé**: ç¶“æ¸¬è©¦ï¼Œç³»çµ±èƒ½æ­£ç¢ºç”¢å‡ºç¬¦åˆ C>=2, PG>=2, å¾Œè¡›>=4, å‰é‹’>=4 ä¸”ç­‰ç´šåˆ†ä½ˆæ­£ç¢ºçš„é™£å®¹ã€‚

3.  **è¦æ ¼æ›¸æ›´æ–°**
    - å»ºç«‹ `ASBL_Player_System_Specification.md` (v2.3)ï¼Œè©³ç´°å®šç¾©æ‰€æœ‰æ•¸å­¸æ¨¡å‹èˆ‡æ©Ÿç‡åƒæ•¸ã€‚

### ğŸ“ ç­†è¨˜
- **ä¿®æ­£**: ä¿®æ­£äº†è…³æœ¬ä¸­èƒ½åŠ›å€¼ä¸­æ–‡åç¨±çš„å°ç…§éŒ¯èª¤ (å¦‚ shot_accuracy æ‡‰ç‚ºã€ŒæŠ•ç±ƒæº–å¿ƒã€)ã€‚
- **æ¶æ§‹**: æ±ºå®šå°‡ã€Œé–‹éšŠæª¢æ ¸é‚è¼¯ã€æ”¾åœ¨æ‡‰ç”¨å±¤ (Script/API) è€Œéç”Ÿæˆå±¤ (Service)ï¼Œä¿æŒç”Ÿæˆå™¨çš„ç´”ç²¹éš¨æ©Ÿæ€§ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- é–‹ç™¼ `POST /api/teams` APIï¼Œå°‡æ¨¡æ“¬è…³æœ¬çš„é‚è¼¯æ­£å¼æ•´åˆé€²å¾Œç«¯ã€‚
- å®Œå–„å‰ç«¯è¨»å†Šæµç¨‹ï¼Œè®“ä½¿ç”¨è€…èƒ½å¯¦éš›å»ºç«‹çƒéšŠã€‚

---
## 2025-12-04 06:00 ï¼šå¹´é½¡ã€åˆç´„èˆ‡ä¸Šå ´æ™‚é–“åˆ†é…ç³»çµ± (Age, Contract & Minutes)

### âœ… é€²åº¦æ‘˜è¦
å¯¦ä½œäº† Spec v2.4 (å¹´é½¡èˆ‡åˆç´„) èˆ‡ v2.5 (ä¸Šå ´æ™‚é–“åˆ†é…) çš„æ ¸å¿ƒé‚è¼¯ã€‚ç¾åœ¨ç”Ÿæˆçš„çƒå“¡å…·å‚™äº†å®Œæ•´çš„è·æ¥­ç”Ÿæ¶¯å±¬æ€§ï¼Œä¸¦ä¸”èƒ½é€éæ¼”ç®—æ³•æ¨¡æ“¬å‡ºçœŸå¯¦çš„æ¯”è³½è¼ªæ›¿èª¿åº¦ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€
1.  **è³‡æ–™åº«æ¨¡å‹æ›´æ–°**
    - **Player**: æ–°å¢ `age` æ¬„ä½ã€‚
    - **Contract**: æ–°å¢ `role` (è§’è‰²å®šä½) æ¬„ä½ï¼Œç”¨æ–¼è¨ˆç®—ä¸Šå ´æ™‚é–“å„ªå…ˆæ¬Šã€‚

2.  **çƒå“¡ç”Ÿæˆå™¨å‡ç´š (v2.4)**
    - **å¹´é½¡ç”Ÿæˆ**: å¯¦ä½œ `_generate_age`ï¼ŒSSR å›ºå®š 18 æ­²ï¼ŒG ç´šæµ®å‹•è‡³ 24 æ­²ã€‚
    - **åˆå§‹åˆç´„**: å¯¦ä½œ `_get_contract_rules`ï¼Œç”Ÿæˆæ™‚è‡ªå‹•ç¶å®šåˆç´„å¹´é™ (SSR=4å¹´) èˆ‡è§’è‰² (SSR=Star)ã€‚

3.  **ä¸Šå ´æ™‚é–“åˆ†é…æ¼”ç®—æ³• (v2.5)**
    - å¯¦ä½œ **ã€Œä¿åº• + æ¬Šé‡ã€** åˆ†é…æ©Ÿåˆ¶ã€‚
    - **Star**: ä¿åº• 30 åˆ†é˜ (æ¬Šé‡ -1~5)ã€‚
    - **Starter**: ä¿åº• 20 åˆ†é˜ (æ¬Šé‡ -2~7)ã€‚
    - **Rotation**: ä¿åº• 10 åˆ†é˜ (æ¬Šé‡ 5~15)ã€‚
    - **æ¼”ç®—æ³•é‚è¼¯**: å…ˆæ‰£é™¤ç¸½ä¿åº•æ™‚é–“ï¼Œå‰©é¤˜æ™‚é–“ä¾æ¬Šé‡æ¯”ä¾‹åˆ†é…ï¼Œæœ€å¾Œé€²è¡Œå°¾æ•¸ä¿®æ­£ï¼Œç¢ºä¿ç¸½å’Œç‚º 240 åˆ†é˜ã€‚

4.  **æ¨¡æ“¬æ¸¬è©¦**
    - æ›´æ–° `scripts/simulate_team_creation.py`ï¼Œæ–°å¢ `simulate_games` å‡½æ•¸ã€‚
    - æˆåŠŸæ¨¡æ“¬ 10 å ´æ¯”è³½çš„è¼ªæ›¿ç‹€æ³ï¼Œé©—è­‰äº† Star çƒå“¡æ™‚é–“ç©©å®šï¼Œè€Œ Bench çƒå“¡æ™‚é–“æ³¢å‹•å¤§çš„é æœŸæ•ˆæœã€‚

### ğŸ“ ç­†è¨˜
- **æ™‚é–“åˆ†é…**: ç›®å‰æ¼”ç®—æ³•é‹ä½œè‰¯å¥½ï¼Œæœªå‡ºç¾è² æ•¸æ™‚é–“æˆ–ç¸½å’ŒéŒ¯èª¤çš„æƒ…æ³ã€‚
- **æ¬Šé‡èª¿æ•´**: æœªä¾†å¯è€ƒæ…®å°‡çƒå“¡çš„ `stamina` (é«”åŠ›) æˆ– `form` (è¿‘æ³) åŠ å…¥æ¬Šé‡è¨ˆç®—å…¬å¼ä¸­ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- é–‹å§‹è¨­è¨ˆæ¯”è³½å¼•æ“ (Match Engine)ï¼Œå°‡åˆ†é…å¥½çš„æ™‚é–“è½‰åŒ–ç‚ºæ¯”è³½æ•¸æ“š (å¾—åˆ†ã€ç±ƒæ¿ç­‰)ã€‚

## 2025-12-07 14:00 ï¼šæ¯”è³½å¼•æ“ v1.4 èˆ‡æ•¸æ“šæ­¸å±¬æ©Ÿåˆ¶ (Match Engine v1.4)

### âœ… é€²åº¦æ‘˜è¦
å®Œæˆäº†æ¯”è³½å¼•æ“çš„æ ¸å¿ƒå‡ç´šï¼Œå¯¦ä½œäº† **ASBL Spec v1.4**ã€‚æœ¬æ¬¡æ›´æ–°é‡é»åœ¨æ–¼è®“æ¨¡æ“¬æ•¸æ“šæ›´å…·çœŸå¯¦æ„Ÿï¼Œé€éæ¬Šé‡åˆ†é…æ©Ÿåˆ¶å–ä»£ç´”éš¨æ©Ÿåˆ¤å®šï¼Œä¸¦èª¿æ•´äº†é«”åŠ›æ¶ˆè€—æ¨¡å‹ä»¥å¼·åŒ–è¼ªæ›¿çš„é‡è¦æ€§ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€
1.  **æ¯”è³½å¼•æ“å‡ç´š (Match Engine v1.4)**
    - **æ•¸æ“šæ­¸å±¬åˆ¤å®š (Data Attribution)**:
        - **æŠ•ç±ƒ**: å¼•å…¥ã€Œæˆ°è¡“åœ°ä½ (Star/Starter)ã€èˆ‡ã€Œå°„ç¨‹å‚¾å‘ (3PT)ã€æ¬Šé‡ï¼Œæ˜æ˜Ÿçƒå“¡èˆ‡å°„æ‰‹å°‡ç²å¾—æ›´å¤šå‡ºæ‰‹æ¬Šã€‚
        - **åŠ©æ”»**: å¯¦ä½œå›ºå®šé †åºåˆ¤å®š (C->PF->SF->SG->PG)ï¼Œç¢ºä¿æ§çƒå¾Œè¡›åœ¨åŠ©æ”»åˆ†é…ä¸Šçš„å„ªå‹¢ã€‚
        - **ç±ƒæ¿**: å€åˆ†é€²æ”»/é˜²å®ˆç±ƒæ¿æ¬Šé‡ï¼Œèº«é«˜ã€å½ˆè·³èˆ‡å¡ä½èƒ½åŠ›æˆç‚ºé—œéµã€‚
        - **å¤±èª¤**: åˆ†é›¢ã€Œå€‹äººå¤±èª¤ã€(è¢«æŠ„æˆª) èˆ‡ã€Œåœ˜éšŠå¤±èª¤ã€(8ç§’/24ç§’é•ä¾‹)ï¼Œä½¿çƒå“¡æ•¸æ“šæ›´ç²¾ç¢ºã€‚
    - **é«”åŠ›ç³»çµ±èª¿æ•´**:
        - æ¶ˆè€—ä¿‚æ•¸ç”± 2.5 æå‡è‡³ **3.0**ï¼ŒåŠ é€Ÿé«”åŠ›æµå¤±ï¼Œè¿«ä½¿æ•™ç·´æ›´ä¾è³´æ¿å‡³æ·±åº¦ã€‚
        - ä¿®æ­£å±¬æ€§è¨ˆç®—ï¼Œç¢ºä¿æ‰€æœ‰åˆ¤å®šçš†ä½¿ç”¨é«”åŠ›è¡°é€€å¾Œçš„ç•¶å‰æ•¸å€¼ã€‚

2.  **ç¨‹å¼ç¢¼é‡æ§‹èˆ‡å„ªåŒ–**
    - **PlayerObj**: æ–°å¢ `game_stats` å­—å…¸ï¼Œç¨ç«‹è¨˜éŒ„å–®å ´æ¯”è³½çš„è©³ç´°æ•¸æ“š (PTS, REB, AST, STL, BLK, TOV)ã€‚
    - **Team Creation**: å„ªåŒ– `create_team_roster`ï¼Œç›´æ¥ç”Ÿæˆç¬¦åˆç­‰ç´šåˆ†ä½ˆçš„å±¬æ€§ï¼Œç§»é™¤å° Service å±¤çš„ä¸å¿…è¦ä¾è³´ã€‚
    - **Terminal Utils**: æ–°å¢ `scripts/terminal.py`ï¼Œæä¾›è·¨å¹³å° (Windows/Mac/Linux) çš„çµ‚ç«¯æ©Ÿç•«é¢æ¸…é™¤åŠŸèƒ½ã€‚

3.  **æ–‡ä»¶æ›´æ–°**
    - æ–°å¢ `ASBL_Spec_v1.4.md`ï¼Œå®Œæ•´è¨˜éŒ„æ¯”è³½å¼•æ“çš„åˆ¤å®šé‚è¼¯èˆ‡å…¬å¼ã€‚

### ğŸ“ ç­†è¨˜
- **æ¨¡æ“¬çµæœè§€å¯Ÿ**: åœ¨ v1.4 ç‰ˆæœ¬ä¸‹ï¼ŒStar çƒå“¡çš„å¾—åˆ†æ•¸æ“šé¡¯è‘—æå‡ï¼Œä¸” PG çš„åŠ©æ”»æ•¸æ›´ç¬¦åˆé æœŸã€‚é«”åŠ›æ¶ˆè€—åŠ å¿«å¾Œï¼Œæ¿å‡³çƒå“¡çš„ä¸Šå ´æ™‚é–“è®Šå¾—æ›´åŠ é—œéµã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- é–‹ç™¼å‰ç«¯æ¯”è³½ç›´æ’­ä»‹é¢ (Play-by-Play UI)ã€‚
- å¯¦ä½œçƒå“¡æˆé•·ç³»çµ± (Training & Aging)ã€‚

## 2025-12-12 10:00 ï¼šé…ç½®æª”é‡æ§‹èˆ‡ Spec v2.6 å±¬æ€§æ¨™æº–åŒ– (Refactoring & Spec v2.6)

### âœ… é€²åº¦æ‘˜è¦
ç‚ºäº†å› æ‡‰æœªä¾†å¤§è¦æ¨¡æ•¸æ“šé©—è­‰èˆ‡å¹³è¡¡æ€§èª¿æ•´çš„éœ€æ±‚ï¼Œæœ¬æ¬¡é€²è¡Œäº†ç³»çµ±é‡æ§‹ã€‚å°‡åŸæœ¬æ•£è½åœ¨ç¨‹å¼ç¢¼ä¸­çš„ã€Œé­”è¡“æ•¸å­— (Magic Numbers)ã€èˆ‡ã€Œç”Ÿæˆè¦å‰‡ã€å…¨æ•¸æŠ½é›¢è‡³ YAML è¨­å®šæª”ï¼Œä¸¦çµ±ä¸€äº†å±¬æ€§å‘½åè¦ç¯„ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€
1.  **é…ç½®æª”ä¸­å¿ƒåŒ– (Configuration Centralization)**
    - **æ–°å¢ `config/game_config.yaml`**: é›†ä¸­ç®¡ç†çƒå“¡ç”Ÿæˆæ©Ÿç‡ã€è–ªè³‡ä¿‚æ•¸ã€èƒ½åŠ›å€¼ä¸Šä¸‹é™ã€æ¯”è³½å¼•æ“åƒæ•¸ç­‰ã€‚
    - **æ–°å¢ `GameConfigLoader`**: å¯¦ä½œ Singleton æ¨¡å¼çš„è¨­å®šæª”è®€å–å™¨ï¼Œæ”¯æ´ç†±é‡è¼‰ (Reload) èˆ‡ç’°å¢ƒè®Šæ•¸è·¯å¾‘è¨­å®šã€‚

2.  **çƒå“¡ç”Ÿæˆå™¨é‡æ§‹ (PlayerGenerator Refactor)**
    - **Spec v2.6 å¯¦ä½œ**: æ›´æ–° `ATTR_MAPPING`ï¼Œå°‡ Config Key èˆ‡ DB Field é€²è¡Œæ¨™æº–åŒ–å°ç…§ (ä¾‹å¦‚ `shot_touch` å°æ‡‰ `offense.touch`)ã€‚
    - **ç§»é™¤ç¡¬ç·¨ç¢¼**: `_generate_stats_by_grade` èˆ‡ `generate_payload` æ”¹ç‚ºå¾ ConfigLoader è®€å–åƒæ•¸ã€‚
    - **å¤§æ•¸æ“šæ”¯æ´**: æ–°å¢ `to_flat_dict` æ–¹æ³•ï¼Œå¯å°‡å·¢ç‹€çš„ Player Payload æ”¤å¹³ç‚ºå–®å±¤ Dictionaryï¼Œæ–¹ä¾¿å¾ŒçºŒåŒ¯å‡º CSV é€²è¡Œ Pandas åˆ†æã€‚

3.  **è¦æ ¼æ›¸æ›´æ–°**
    - **ASBL_Player_System_Specification.md (v2.6)**: æ–°å¢è©³ç´°çš„å±¬æ€§å°ç…§è¡¨ (Config Key vs DB Field)ï¼Œç¢ºä¿é–‹ç™¼ä¸€è‡´æ€§ã€‚

### ğŸ“ ç­†è¨˜
- **å„ªåŒ–æ–¹å‘**: é€™æ¬¡é‡æ§‹é›–ç„¶æ²’æœ‰æ”¹è®Šå¤–éƒ¨åŠŸèƒ½ï¼Œä½†å¤§å¹…æå‡äº†ç³»çµ±çš„å¯ç¶­è­·æ€§ã€‚æ¥ä¸‹ä¾†é€²è¡Œå¤§æ•¸æ“šæ¸¬è©¦æ™‚ï¼Œè‹¥ç™¼ç¾æŸå€‹ç­‰ç´šå¤ªå¼·ï¼Œåªéœ€ä¿®æ”¹ YAML æª”å³å¯ï¼Œç„¡éœ€æ”¹å‹•ç¨‹å¼ç¢¼ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **å¤§æ•¸æ“šé©—è­‰ (Big Data Verification)**: é–‹ç™¼ Python è…³æœ¬ï¼Œç”Ÿæˆ 100è¬ç­†çƒå“¡è³‡æ–™ï¼Œé©—è­‰å¸¸æ…‹åˆ†ä½ˆã€ç­‰ç´šæ©Ÿç‡èˆ‡èƒ½åŠ›å€¼ç¸½å’Œæ˜¯å¦ç¬¦åˆ Spec v2.6 é æœŸã€‚

## 2025-12-13 08:00 ï¼šå¤§æ•¸æ“šé©—è­‰æ¶æ§‹èˆ‡ä¸€å„„ç­†çƒå“¡ç”Ÿæˆ (Big Data Verification & 100M Generation)

### âœ… é€²åº¦æ‘˜è¦
ç‚ºäº†é©—è­‰ **Spec v2.6** çƒå“¡ç”Ÿæˆå™¨çš„æ©Ÿç‡æ¨¡å‹æ˜¯å¦ç²¾ç¢ºï¼Œæˆ‘å€‘å»ºæ§‹äº†ä¸€å¥— **ETL (Extract, Transform, Load) å¤§æ•¸æ“šæ¸¬è©¦æ¶æ§‹**ã€‚åˆ©ç”¨ Python å¤šé€²ç¨‹ (Multiprocessing) æŠ€è¡“ï¼ŒæˆåŠŸåœ¨ 1 å°æ™‚å…§ç”Ÿæˆä¸¦å¯«å…¥ **100,000,000 (ä¸€å„„)** ç­†çƒå“¡è³‡æ–™ï¼Œä¸¦é€é Polars é€²è¡Œå…¨é‡ KPI æª¢æ ¸ï¼Œç¢ºèªæ‰€æœ‰æ•¸å€¼åˆ†ä½ˆçš†ç¬¦åˆé æœŸã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€
1.  **ETL è³‡æ–™ç®¡ç·š (`tests/big_data/verify_generator_integration.py`)**
    - **æ¶æ§‹**: æ¡ç”¨ `Producer-Consumer` æ¨¡å¼ï¼Œåˆ©ç”¨ `multiprocessing.Pool` é–‹å•Ÿ 24 å€‹ Worker ä¸¦è¡Œç”Ÿæˆã€‚
    - **å„²å­˜**: æ”¾æ£„ CSVï¼Œæ”¹ç”¨ **Apache Parquet (Snappyå£“ç¸®)** æ ¼å¼ï¼Œå°‡ 1 å„„ç­†è³‡æ–™å£“ç¸®è‡³ç´„ 5GBï¼Œå¤§å¹…é™ä½ I/O ç“¶é ¸ã€‚
    - **æµç¨‹**: å¯¦ä½œã€Œè©¦è·‘ (Dry Run) -> å®¹é‡é ä¼° -> ä¸²æµå¯«å…¥ (Streaming)ã€ä¸‰éšæ®µæµç¨‹ï¼Œç¢ºä¿è¨˜æ†¶é«”èˆ‡ç¡¬ç¢Ÿç©ºé–“å—æ§ã€‚

2.  **é«˜æ•ˆèƒ½åˆ†æ (`tests/big_data/verify_kpi_v2_6.py`)**
    - **æŠ€è¡“é¸å‹**: å¼•å…¥ **Polars** å–ä»£ Pandas é€²è¡Œæ•¸æ“šåˆ†æã€‚åœ¨è™•ç† 1 å„„ç­†è³‡æ–™çš„èšåˆèˆ‡ç¯©é¸æ™‚ï¼Œæ•ˆèƒ½æå‡ç´„ 10-20 å€ã€‚
    - **é›™å‘ Logger**: å¯¦ä½œ `ReportLogger`ï¼Œå°‡é©—è­‰çµæœåŒæ™‚è¼¸å‡ºè‡³çµ‚ç«¯æ©Ÿèˆ‡ Markdown å ±å‘Š (`docs/KPI_Validation_Report_v2_6.md`)ã€‚

3.  **KPI é©—è­‰çµæœ (å…¨æ•¸é€šé)**
    - **èº«é«˜åˆ†ä½ˆ**: 160-230cm å„å€é–“èª¤å·® < 0.02%ï¼Œæ¥µç«¯å€¼ (160cm, 230cm) å‡ºç¾é »ç‡ç¬¦åˆå¸¸æ…‹åˆ†ä½ˆç†è«–å€¼ã€‚
    - **ä½ç½®åˆ¤å®š**: åœ¨ä¸åŒèº«é«˜å€é–“ä¸‹ï¼ŒPG/SG/SF/PF/C çš„åˆ†é…æ¯”ä¾‹èª¤å·®æ§åˆ¶åœ¨ Â±0.02% å…§ã€‚
    - **èƒ½åŠ›å€¼é‚Šç•Œ**: 
        - **åå‘ç¸½ä¸Šé™**: é©—è­‰ G~SSR å„ç­‰ç´šçš„æŠ€è¡“ç¸½å’Œä¸Šé™ (Cap) ç„¡ä»»ä½•é•è¦ã€‚
        - **å¤©è³¦å€é–“**: é©—è­‰ SSR (951-990) è‡³ G (10-400) çš„ç¸½åˆ†å€é–“ç„¡ä»»ä½•é•è¦ã€‚
        - **æ¥µç«¯å€¼**: ç¢ºèªå­˜åœ¨å–®é …èƒ½åŠ› > 90 æˆ– < 10 çš„ã€Œåç§‘å‹ã€çƒå“¡ï¼Œè­‰æ˜é‡éª° (Reroll) æ©Ÿåˆ¶é‹ä½œæ­£å¸¸ã€‚
    - **å¹´é½¡åˆ†ä½ˆ**: SSR 100% ç‚º 18 æ­²ï¼Œå…¶é¤˜ç­‰ç´šå¹´é½¡åˆ†ä½ˆå‡å‹»ã€‚

### ğŸ“ ç­†è¨˜
- **æ•ˆèƒ½æ•¸æ“š**: åœ¨ i9-14900K ç’°å¢ƒä¸‹ï¼Œç”Ÿæˆé€Ÿåº¦é”åˆ° **1,153 ç­†/ç§’**ï¼ŒCPU ä½¿ç”¨ç‡æ»¿è¼‰ (100%)ï¼Œè¨˜æ†¶é«”å³°å€¼ç´„ 60GBã€‚
- **è³‡æ–™å®Œæ•´æ€§**: æ–°å¢ `check_crash_data.py` å·¥å…·ï¼Œç”¨æ–¼åœ¨ç¨‹å¼æ„å¤–ä¸­æ–·å¾Œé©—è­‰ Parquet æª”æ¡ˆçš„å®Œæ•´æ€§ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **æ¯”è³½å¼•æ“é‡æ§‹**: ä¿®æ”¹æ¯”è³½å¼•æ“æ¶æ§‹ï¼Œå°‡æ•¸æ“šè·Ÿå…¬å¼æŠ½é›¢ï¼Œä»¥åˆ©å¾ŒçºŒå¤§æ•¸æ“šæ¸¬è©¦èˆ‡åƒæ•¸èª¿æ•´ã€‚

--

## 2025-12-16 04:50 ï¼šæ¯”è³½å¼•æ“æ ¸å¿ƒæ¶æ§‹èˆ‡è¦å‰‡å¯¦ä½œ (Match Engine Core & Spec v1.6)

### âœ… é€²åº¦æ‘˜è¦
æ­£å¼å®Œæˆäº† **Level 4 æ¯”è³½å¼•æ“ (Match Engine)** çš„æ ¸å¿ƒæ¶æ§‹æ­å»ºã€‚å¯¦ä½œäº† `MatchEngine` ä¸»é¡åˆ¥ï¼ŒåŒ…å«æ¯”è³½æµç¨‹æ§åˆ¶ (Flow Control)ã€è³½å‰åˆå§‹åŒ– (Initialization) ä»¥åŠèˆ‡å„å­ç³»çµ± (é«”åŠ›ã€æ›äººã€æ•¸æ“šæ­¸å±¬) çš„æ•´åˆã€‚åŒæ™‚ï¼Œæ ¹æ“š **Spec v1.6** å¯¦ä½œäº†é–‹å ´è·³çƒã€ç¯€æ¬¡çƒæ¬Šè¼ªæ›¿ä»¥åŠçŠ¯æ»¿é›¢å ´å¾Œçš„ä¸Šå ´æ™‚é–“é‡åˆ†é…é‚è¼¯ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€
1.  **å¼•æ“æ¶æ§‹å»ºç«‹ (`app/services/match_engine/`)**
    - ç¢ºç«‹äº†åˆ†å±¤æ¶æ§‹ï¼š
        - **L4 Core**: `core.py` (ä¸»è¿´åœˆ, ç‹€æ…‹æ©Ÿ)ã€‚
        - **L3 Systems**: `stamina.py`, `substitution.py`, `attribution.py` (ç¨ç«‹é‚è¼¯å–®å…ƒ)ã€‚
        - **L2 Utils**: `calculator.py` (å…¬å¼è¨ˆç®—), `rng.py` (éš¨æ©Ÿæ•¸)ã€‚
        - **L1 Structures**: `structures.py` (è³‡æ–™çµæ§‹)ã€‚
    - ä¿®æ­£æ™‚é–“å–®ä½ï¼šçµ±ä¸€å°‡å…§éƒ¨è¨ˆç®—å–®ä½ç”±ã€Œåˆ†é˜ã€æ”¹ç‚ºã€Œç§’ (seconds)ã€ï¼Œé¿å…æµ®é»æ•¸èª¤å·®ã€‚

2.  **è¦å‰‡å¯¦ä½œ (Spec v1.6)**
    - **é–‹å ´è·³çƒ (Jump Ball)**: 
        - å¯¦ä½œæ–¼ `core.py` çš„ `_jump_ball` æ–¹æ³•ã€‚
        - é‚è¼¯æ”¹ç‚º **Config Driven**ï¼Œç”±è¨­å®šæª”å®šç¾©åƒèˆ‡å±¬æ€§ (èº«é«˜+å½ˆè·³+é€²æ”»IQ) èˆ‡æ¬Šé‡ã€‚
    - **çƒæ¬Šè¼ªæ›¿ (Possession)**:
        - Q1: è·³çƒå‹æ–¹ã€‚
        - Q2/Q3: è·³çƒè² æ–¹ã€‚
        - Q4: è·³çƒå‹æ–¹ã€‚
    - **é–‹å ´é¦–å›åˆä¾‹å¤–**: 
        - åœ¨ Config ä¸­æ–°å¢ `opening_seconds: 2.0`ï¼Œå¼·åˆ¶è¨­å®š Q1 é¦–å›åˆæ™‚é–“ã€‚
    - **çŠ¯æ»¿é›¢å ´ (Foul Out)**:
        - å¯¦ä½œ 6 çŠ¯é›¢å ´è¦å‰‡ã€‚
        - **æ™‚é–“é‡åˆ†é… (Redistribution)**: ç•¶çƒå“¡é›¢å ´æ™‚ï¼Œå°‡å…¶å‰©é¤˜æ™‚é–“å¹³å‡åˆ†é…çµ¦åŒä½ç½®è©•åˆ†å‰ 3 åçš„éšŠå‹ã€‚

3.  **è¨­å®šæª”æ›´æ–° (`config/game_config.yaml`)**
    - æ–°å¢ `jump_ball` å€å¡Šï¼šå®šç¾©è·³çƒå…¬å¼ã€‚
    - æ–°å¢ `backcourt.params.opening_seconds`ï¼šå®šç¾©é–‹å ´æ™‚é–“ã€‚
    - èª¿æ•´ `positional_scoring`ï¼šå„ªåŒ– SF ä½ç½®çš„è©•åˆ†æ¬Šé‡ã€‚
    - æ–°å¢ `substitution.redistribution`ï¼šå®šç¾©æ™‚é–“é‡åˆ†é…åƒæ•¸ã€‚

### ğŸ“ ç­†è¨˜
- **è³‡æ–™é©…å‹•ä¿®æ­£**: ä¿®æ­£äº†åŸå…ˆåœ¨ `core.py` ä¸­å¯«æ­»è·³çƒå…¬å¼çš„å•é¡Œï¼Œç¾åœ¨å®Œå…¨ä¾è³´ Configï¼Œæ–¹ä¾¿æœªä¾†èª¿æ•´å¹³è¡¡ã€‚
- **æ•ˆèƒ½å„ªåŒ–**: `RNG` é¡åˆ¥æ¡ç”¨éœæ…‹æ–¹æ³•ç¶å®šï¼Œæ¸›å°‘å¤§é‡éš¨æ©Ÿæ•¸ç”Ÿæˆæ™‚çš„ overheadã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **å¯¦ä½œå›åˆé‚è¼¯ (Step 3)**: å¡«å…… `_simulate_possession` æ–¹æ³•ï¼Œå¯¦ä½œå®Œæ•´çš„ å¾Œå ´ -> å‰å ´ -> æŠ•ç±ƒ/ç±ƒæ¿ æµç¨‹ã€‚
- **æ•´åˆ Play Logic**: å°‡ Spec v1.6 çš„è©³ç´°åˆ¤å®šé‚è¼¯ (å¦‚å¿«æ”»ã€å°è“‹ã€ç©ºé–“åˆ¤å®š) è½‰åŒ–ç‚ºç¨‹å¼ç¢¼ã€‚

--

## 2025-12-18 04:30 ï¼šæ¯”è³½å¼•æ“é‚è¼¯å®Œå‚™èˆ‡é—œéµ Bug ä¿®å¾© (Match Engine Logic & Bug Fix)

### âœ… é€²åº¦æ‘˜è¦
æœ¬æ¬¡æ›´æ–°è§£æ±ºäº†é˜»ç¤™æ¯”è³½æ¨¡æ“¬çš„é—œéµæŠ€è¡“å•é¡Œï¼Œä¸¦å®Œæˆäº† **Match Engine (v1.6)** çš„æ‰€æœ‰æ ¸å¿ƒå›åˆé‚è¼¯ã€‚ä¿®å¾©äº†è¨­å®šæª”è§£æéŒ¯èª¤å°è‡´çš„ã€Œå±¬æ€§ç‚ºé›¶ã€Bugï¼Œä½¿æŠ•ç±ƒå‘½ä¸­ç‡èˆ‡æ”»é˜²æ•¸æ“šå›æ­¸æ­£å¸¸ã€‚åŒæ™‚ï¼Œé‡æ§‹äº†æ•¸æ“šæ­¸å±¬ç³»çµ± (`AttributionSystem`) ä»¥å°é½Šæ ¸å¿ƒå¼•æ“çš„å‘¼å«ä»‹é¢ï¼Œä¸¦æ–°å¢äº†ç„¡è³‡æ–™åº«ä¾è³´çš„æ¨¡æ“¬è…³æœ¬ (`simulate_match_no_db.py`) ä»¥åŠ é€Ÿé–‹ç™¼æ¸¬è©¦ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **æ ¸å¿ƒä¿®å¾© (`app/services/match_engine/core.py`)**
    - **Config è§£æä¿®å¾© (`_resolve_formula`)**: 
        - å•é¡Œï¼šåŸå…ˆç¨‹å¼ç¢¼ç„¡æ³•è­˜åˆ¥ Config ä¸­ä»¥å­—ä¸²å½¢å¼ (å¦‚ `'off_13'`) åƒç…§çš„å±¬æ€§æ± ï¼Œå°è‡´ `Calculator` æ¥æ”¶åˆ°å­—ä¸²è€Œéå±¬æ€§åˆ—è¡¨ï¼Œè¨ˆç®—çµæœç‚º 0ã€‚
        - è§£æ±ºï¼šæ–°å¢ `_resolve_formula` æ–¹æ³•ï¼Œè‡ªå‹•åˆ¤æ–·ä¸¦å°‡å­—ä¸²å¼•ç”¨è½‰æ›ç‚ºå¯¦éš›çš„å±¬æ€§åˆ—è¡¨ã€‚
    - **å…¨æµç¨‹å¯¦ä½œ**: 
        - å®Œæˆ `_simulate_possession` å…§éƒ¨çš„å®Œæ•´ç‹€æ…‹æ©Ÿï¼š`Backcourt` (å¾Œå ´) -> `Frontcourt` (å‰å ´) -> `Shooting` (æŠ•ç±ƒ)ã€‚
        - å¯¦ä½œäº† **å¿«æ”» (Fastbreak)**ã€**é˜»æ”» (Block)**ã€**æŠ„æˆª (Steal)** èˆ‡ **çŠ¯è¦ (Foul)** çš„è©³ç´°åˆ¤å®šé‚è¼¯ã€‚
    - **å…¬å¼æ‡‰ç”¨**: å°‡ Spec v1.6 å®šç¾©çš„å‘½ä¸­ç‡å…¬å¼ã€ç©ºé–“åŠ æˆ (Spacing) èˆ‡å‡ºæ‰‹å“è³ª (Quality) å®Œæ•´è½‰åŒ–ç‚ºç¨‹å¼ç¢¼ã€‚

2.  **ç³»çµ±é‡æ§‹ (`app/services/match_engine/systems/attribution.py`)**
    - **ä»‹é¢çµ±ä¸€**: èª¿æ•´æ–¹æ³•ç°½ç«  (Signature) ä»¥é…åˆ `core.py` çš„å‘¼å«éœ€æ±‚ã€‚
    - **é‚è¼¯ä¿®æ­£**:
        - `record_block`: ç¾åœ¨æ¥æ”¶ `(blocker, shooter)`ï¼Œä¸¦æ­£ç¢ºè¨˜éŒ„å°„æ‰‹è¢«è“‹ç«é‹æ™‚çš„ `FGA` (å‡ºæ‰‹æ•¸)ã€‚
        - `record_assist`: æ–°å¢ç¨ç«‹çš„åŠ©æ”»è¨˜éŒ„æ–¹æ³•ã€‚
        - æ–¹æ³•æ›´åï¼š`record_shot_attempt` -> `record_attempt`ï¼Œ`determine_assister` -> `determine_assist_provider`ã€‚

3.  **æ¸¬è©¦å·¥å…· (`scripts/simulate_match_no_db.py`)**
    - æ–°å¢ç¨ç«‹æ¨¡æ“¬è…³æœ¬ï¼Œé€é Mock `PlayerGenerator` èˆ‡ Adapter æ¨¡å¼ï¼Œåœ¨ä¸é€£æ¥ MySQL çš„æƒ…æ³ä¸‹ç›´æ¥ç”Ÿæˆå…©æ”¯çƒéšŠé€²è¡Œå°æˆ°ã€‚
    - è¼¸å‡ºè©³ç´°çš„ **Play-by-Play (PBP)** æ—¥èªŒèˆ‡ **Box Score**ï¼Œç”¨æ–¼é©—è­‰æ•¸å€¼å¹³è¡¡ã€‚

### ğŸ“ ç­†è¨˜
- **æ¨¡æ“¬çµæœé©—è­‰**: ç¶“éä¿®å¾©å¾Œï¼Œæ¨¡æ“¬æ¯”è³½æ¯”åˆ† (å¦‚ 103:113) èˆ‡å‘½ä¸­ç‡ (30%~60%) çš†ç¬¦åˆç¾ä»£ç±ƒçƒå¸¸æ…‹ï¼ŒSSR çƒå“¡è¡¨ç¾é¡¯è‘—å„ªæ–¼æ™®é€šçƒå“¡ï¼Œè­‰å¯¦æ•¸å€¼æ¨¡å‹æœ‰æ•ˆã€‚
- **æ¶æ§‹å„ªåŒ–**: é€é Adapter éš”é›¢äº† DB Model èˆ‡ Engine Modelï¼Œæœªä¾†æ›´æ›è³‡æ–™åº«æˆ–èª¿æ•´å­˜å„²çµæ§‹æ™‚ï¼Œå¼•æ“æ ¸å¿ƒç„¡éœ€ä¿®æ”¹ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **å¤§æ•¸æ“šå¹³è¡¡æ¸¬è©¦**: ä½¿ç”¨ `simulate_league.py` é€²è¡Œ 20 éšŠ x 6 å¾ªç’°çš„è³½å­£æ¨¡æ“¬ï¼Œæª¢è¦–å‹ç‡åˆ†ä½ˆèˆ‡æ¥µç«¯å€¼ã€‚
- **å‰ç«¯ä¸²æ¥**: å°‡æ¯”è³½çµæœ (JSON) å‚³éçµ¦å‰ç«¯ä»‹é¢é€²è¡Œè¦–è¦ºåŒ–é¡¯ç¤ºã€‚

--

## 2025-12-20 14:00 ï¼šæŠ•ç±ƒæ©Ÿåˆ¶é‡æ§‹èˆ‡æ•¸æ“šå®šç¾©æ¨™æº–åŒ– (Match Engine v1.8 & Output Schema)

### âœ… é€²åº¦æ‘˜è¦
æœ¬æ¬¡æ›´æ–°å°‡æ¯”è³½å¼•æ“å‡ç´šè‡³ **v1.8**ã€‚æ ¸å¿ƒè®Šå‹•åœ¨æ–¼é‡æ§‹äº†æŠ•ç±ƒåˆ¤å®šæµç¨‹ï¼Œæ­£å¼å€åˆ†äº† **2åˆ†çƒ (40%)** èˆ‡ **3åˆ†çƒ (20%)** çš„åŸºç¤å‘½ä¸­ç‡ï¼Œè§£æ±ºäº†åŸæœ¬ä¸‰åˆ†çƒéæ–¼å®¹æ˜“å‘½ä¸­çš„å¹³è¡¡æ€§å•é¡Œã€‚åŒæ™‚ï¼Œä¿®å¾©äº†æ•¸æ“šæ­¸å±¬ç³»çµ±ä¸­ã€Œé€²çƒæœªè¨ˆå…¥å‡ºæ‰‹æ•¸ (FGA)ã€çš„åš´é‡ Bugï¼Œä¸¦çµ±ä¸€äº†æ›äººç³»çµ±çš„æ™‚é–“å–®ä½ã€‚æœ€å¾Œï¼Œåœ¨è¦æ ¼æ›¸ä¸­æ­£å¼å®šç¾©äº† API è¼¸å‡ºçš„æ•¸æ“šçµæ§‹ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **æŠ•ç±ƒé‚è¼¯é‡æ§‹ (`app/services/match_engine/core.py`)**
    - **æµç¨‹èª¿æ•´**: å°‡ã€ŒæŠ•ç±ƒé¡å‹åˆ¤å®š (2pt/3pt)ã€æå‰è‡³ã€Œå‘½ä¸­ç‡è¨ˆç®—ã€ä¹‹å‰åŸ·è¡Œã€‚
    - **å‹•æ…‹åŸºç¤å‘½ä¸­ç‡**: 
        - å¯¦ä½œ **Spec v1.7** è¦å‰‡ã€‚
        - è®€å– Config æ–°å¢çš„ `base_rate_2pt` (0.40) èˆ‡ `base_rate_3pt` (0.20)ã€‚
        - ä¾æ“šåˆ¤å®šçµæœå‹•æ…‹å¥—ç”¨åŸºç¤å‘½ä¸­ç‡ï¼Œä½¿ä¸‰åˆ†çƒæ›´ä¾è³´çƒå“¡å±¬æ€§è€ŒéåŸºç¤æ©Ÿç‡ã€‚

2.  **æ•¸æ“šçµ±è¨ˆä¿®å¾© (`app/services/match_engine/systems/attribution.py`)**
    - **Critical Fix**: ä¿®æ­£ `record_score` æ–¹æ³•ã€‚
    - **å•é¡Œ**: åŸæœ¬é‚è¼¯ä¸­ï¼Œé€²çƒ (Score) åªå¢åŠ  `FGM` (å‘½ä¸­æ•¸) èˆ‡ `PTS` (å¾—åˆ†)ï¼Œæœªå¢åŠ  `FGA` (å‡ºæ‰‹æ•¸)ï¼Œå°è‡´å‘½ä¸­ç‡è¨ˆç®—åˆ†æ¯éŒ¯èª¤ (è®Šæˆ FGM / Misses)ã€‚
    - **ä¿®æ­£**: é€²çƒæ™‚ç¾åœ¨æœƒåŒæ­¥åŸ·è¡Œ `scorer.stat_fga += 1` (è‹¥ç‚º3åˆ†å‰‡ `stat_3pa += 1`)ã€‚

3.  **å–®ä½çµ±ä¸€èˆ‡é…ç½®æ›´æ–°**
    - **SubstitutionSystem**: å°‡æ›äººåˆ¤æ–·é‚è¼¯ä¸­çš„ `minutes_played` ä¿®æ­£ç‚º `seconds_played`ï¼Œèˆ‡ Core çš„è¨ˆæ™‚å–®ä½ä¿æŒä¸€è‡´ï¼Œé¿å…æ›äººåŠŸèƒ½å¤±æ•ˆã€‚
    - **Config**: æ›´æ–° `game_config.yaml`ï¼Œç§»é™¤å–®ä¸€ `base_rate`ï¼Œæ‹†åˆ†ç‚º `base_rate_2pt` èˆ‡ `base_rate_3pt`ã€‚

4.  **è¦æ ¼æ›¸æ›´æ–° (Spec v1.8)**
    - æ–°å¢ **Section 7: è¼¸å‡ºæ•¸æ“šå®šç¾© (Output Data Definition)**ï¼Œè©³ç´°åˆ—å‡º `MatchResult` èˆ‡ `Box Score` çš„æ‰€æœ‰æ¬„ä½èˆ‡æ ¼å¼ï¼Œä½œç‚ºå‰å¾Œç«¯ä¸²æ¥çš„æ¨™æº–ã€‚

### ğŸ“ ç­†è¨˜
- **å¹³è¡¡æ€§é æœŸ**: é æœŸæ›´æ–°å¾Œï¼Œä¸‰åˆ†çƒçš„å‘½ä¸­ç‡æœƒé¡¯è‘—ä¸‹é™ï¼Œæ›´åŠ ç¬¦åˆçœŸå¯¦ç±ƒçƒæ•¸æ“šï¼ˆç´„ 30%-40%ï¼‰ï¼Œä¸”é«˜å°„ç¨‹å±¬æ€§çš„çƒå“¡åƒ¹å€¼æœƒæå‡ã€‚
- **æ•¸æ“šé©—è­‰**: ä¸‹ä¸€æ­¥éœ€é‡æ–°åŸ·è¡Œ `simulate_match_no_db.py`ï¼Œç¢ºèª Box Score ä¸­çš„ FGM/FGA æ¯”ä¾‹æ˜¯å¦æ­£å¸¸ (ä¾‹å¦‚ä¸å†å‡ºç¾ 5/0 çš„è©­ç•°æ•¸æ“š)ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **é€²éšæ•¸æ“šå¯¦ä½œ**: æ ¹æ“šæ–°çš„ Spec v1.8ï¼Œé–‹å§‹å¯¦ä½œæ­£è² å€¼ (+/-)ã€å¿«æ”»å¾—åˆ†ã€äºŒæ³¢å¾—åˆ†ç­‰é€²éšæ•¸æ“šæ¬„ä½ã€‚
- **å‰ç«¯ä¸²æ¥**: ä¾æ“š Section 7 çš„å®šç¾©ï¼Œæä¾› API çµ¦å‰ç«¯é¡¯ç¤ºæ¯”è³½çµæœã€‚

--

## 2025-12-22 06:00 ï¼šçƒå“¡ç³»çµ± v3.1 èˆ‡æ¯”è³½å¼•æ“ Phase 2 å„ªåŒ– (Player System v3.1 & Match Engine Optimization)

### âœ… é€²åº¦æ‘˜è¦
æœ¬æ¬¡æ›´æ–°åŒ…å«å…©å¤§é‡é»ï¼šä¸€æ˜¯å¯¦ä½œ **Player System Spec v3.1**ï¼Œå¼•å…¥äº†æ›´åš´è¬¹çš„çƒå“¡ç”Ÿæˆé™åˆ¶ï¼ˆä½ç½®æª¢æ ¸ã€èº«é«˜ä¿®æ­£ï¼‰ï¼›äºŒæ˜¯ **Match Engine é€²å…¥ Phase 2**ï¼Œæ–°å¢äº†é€²éšæ•¸æ“šï¼ˆPace, Fastbreak Efficiencyï¼‰è¿½è¹¤ï¼Œä¸¦å°æ ¸å¿ƒè³‡æ–™çµæ§‹é€²è¡Œäº†è¨˜æ†¶é«”å„ªåŒ–ï¼Œä»¥æ‡‰å°æœªä¾†çš„å¤§è¦æ¨¡æ¨¡æ“¬éœ€æ±‚ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **çƒå“¡ç”Ÿæˆç³»çµ±å‡ç´š (Spec v3.1)**
    - **é…ç½®æª”æ›´æ–° (`config/game_config.yaml`)**:
        - **ä½ç½®æª¢æ ¸ (Position Validation)**: åœ¨ YAML ä¸­å®šç¾©äº†å„ä½ç½®çš„å±¬æ€§ç¸½å’Œé™åˆ¶ï¼ˆä¾‹å¦‚ C çš„ç±ƒæ¿+å¡ä½+å¹²æ“¾å¿…é ˆå¤§æ–¼å…¶ä»–å±¬æ€§ï¼‰ï¼Œé˜²æ­¢ç”Ÿæˆå‡ºæ•¸å€¼åˆ†ä½ˆä¸åˆç†çš„çƒå“¡ã€‚
        - **èº«é«˜ä¿®æ­£ (Height Modifiers)**: å¯¦ä½œäº†èº«é«˜å€é–“çš„è£œå„Ÿèˆ‡æ‡²ç½°æ©Ÿåˆ¶ï¼ˆå¦‚çŸ®å€‹å­çƒå“¡ç²å¾—é¡å¤–å±¬æ€§é»æ•¸ï¼Œä¸”é‡å° PG é—œéµå±¬æ€§åŠ æ¬Šï¼‰ã€‚
        - **æµç¨‹é‡æ§‹**: ç¢ºç«‹äº† `å§“å -> ç­‰ç´š -> å¤©è³¦ -> èº«é«˜ -> ä½ç½® -> èƒ½åŠ› -> å¹´é½¡` çš„ç”Ÿæˆé †åºã€‚

2.  **æ¯”è³½å¼•æ“ Phase 2 (`app/services/match_engine/`)**
    - **é€²éšæ•¸æ“šè¿½è¹¤**:
        - **Pace (ç¯€å¥)**: åœ¨ `AttributionSystem` æ–°å¢ `record_possession`ï¼Œä¸¦åœ¨ `MatchEngine` ä¸­è¨ˆç®—æ¯ 48 åˆ†é˜å›åˆæ•¸ã€‚
        - **å¿«æ”»æ•ˆç‡**: æ–°å¢ `record_fastbreak_event`ï¼Œåˆ†åˆ¥è¨˜éŒ„å¿«æ”»çš„å˜—è©¦æ¬¡æ•¸èˆ‡æˆåŠŸæ¬¡æ•¸ï¼Œç”¨æ–¼åˆ†æçƒå“¡é€Ÿåº¦å±¬æ€§çš„å¯¦éš›æ•ˆç›Šã€‚
    - **çµæ§‹å„ªåŒ– (`structures.py`)**:
        - å…¨é¢å°å…¥ Python 3.10+ çš„ `@dataclass(slots=True)`ã€‚
        - **æ•ˆç›Š**: ç›¸æ¯”åŸæœ¬çš„ `__slots__` æ‰‹å‹•å®šç¾©æˆ–æ¨™æº–å­—å…¸å„²å­˜ï¼Œè¨˜æ†¶é«”ä½”ç”¨æ¸›å°‘ç´„ 40%ï¼Œå±¬æ€§å­˜å–é€Ÿåº¦æå‡ç´„ 20%ï¼Œå°åƒè¬ç´šåˆ¥çš„æ¨¡æ“¬è‡³é—œé‡è¦ã€‚

3.  **è¼¸å‡ºä»‹é¢æ“´å……**
    - **MatchResult**: æ“´å……äº†å›å‚³çµæ§‹ï¼Œç¾åœ¨åŒ…å« `pace`, `home_possessions`, `fb_made/attempt` ç­‰é«˜éšæ•¸æ“šï¼Œä¾›å‰ç«¯èˆ‡åˆ†æç³»çµ±ä½¿ç”¨ã€‚

### ğŸ“ ç­†è¨˜
- **é‚è¼¯ä¿®æ­£**: åœ¨å¯¦ä½œèº«é«˜ä¿®æ­£æ™‚ï¼Œç¢ºèªäº† 210cm+ çš„æ‡²ç½°é‚è¼¯èˆ‡ 160cm+ çš„çå‹µé‚è¼¯äº’æ–¥ï¼Œç¨‹å¼ç«¯å·²ä¾ç…§ YAML é…ç½®æ­£ç¢ºè™•ç†ã€‚
- **æ•ˆèƒ½ç›£æ§**: åˆæ­¥æ¸¬è©¦é¡¯ç¤ºï¼Œé›–ç„¶æ–°å¢äº†æ•¸æ“šè¿½è¹¤é‚è¼¯ï¼Œä½†å—æƒ æ–¼ `slots=True` çš„å„ªåŒ–ï¼Œæ•´é«”æ¨¡æ“¬é€Ÿåº¦ä¸¦æœªä¸‹é™ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **ç”Ÿæˆå™¨é©—è­‰**: åŸ·è¡Œæ–°ä¸€è¼ªçš„å¤§æ•¸æ“šæ¸¬è©¦ (Big Data Verification)ï¼Œç¢ºèª v3.1 çš„ä½ç½®æª¢æ ¸æ˜¯å¦æœƒå°è‡´æŸäº›ç­‰ç´šçš„çƒå“¡ç”Ÿæˆå¤±æ•—ç‡éé«˜ã€‚
- **å‰ç«¯æ•´åˆ**: å°‡æ–°çš„ Box Score èˆ‡é€²éšæ•¸æ“šä¸²æ¥è‡³å‰ç«¯é é¢ã€‚

--

## 2025-12-24 11:00 ï¼šé–‹éšŠç”Ÿæˆè¦å‰‡å„ªåŒ–èˆ‡ç”Ÿæˆå™¨æ•ˆèƒ½é‡æ§‹ (Initial Roster Optimization & Performance Refactor)

### âœ… é€²åº¦æ‘˜è¦
æœ¬æ¬¡æ›´æ–°ä¸»è¦å¯¦ä½œäº† **Player System Spec v3.2**ï¼Œé‡å°ã€Œé–‹éšŠé™£å®¹ã€åŠ å…¥äº†èƒ½åŠ›ä¸‹é™ä¿è­·æ©Ÿåˆ¶ï¼Œç¢ºä¿ç©å®¶åˆå§‹éšŠä¼çš„æˆ°åŠ›ä¸‹é™ã€‚åŒæ™‚ï¼Œç‚ºäº†æ‡‰å°æ¥ä¸‹ä¾†çš„ä¸Šå„„æ¬¡å¤§æ•¸æ“šæ¸¬è©¦ï¼Œå° `PlayerGenerator` é€²è¡Œäº†åº•å±¤æ¶æ§‹é‡æ§‹ï¼Œå¼•å…¥äº† **å¿«å–æ©Ÿåˆ¶ (Caching)** èˆ‡ **è¦å‰‡é ç·¨è­¯ (Rule Compilation)**ã€‚æœ€å¾Œï¼Œå°‡æ¨¡æ“¬æ¸¬è©¦è…³æœ¬çš„è¼¸å‡ºä»‹é¢å…¨é¢ **ç¹é«”ä¸­æ–‡åŒ–**ï¼Œæå‡é–‹ç™¼é«”é©—ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **é–‹éšŠé™£å®¹å„ªåŒ– (Team Creator - Spec v3.2)**
    - **èƒ½åŠ›ä¸‹é™æª¢æ ¸ (Lower Bound Validation)**:
        - åœ¨ `TeamCreator` ä¸­æ–°å¢ `_generate_qualified_player` æ–¹æ³•ã€‚
        - è®€å– Config ä¸­çš„ `initial_team_min_ratio` (é è¨­ 0.5)ã€‚
        - é‚è¼¯ï¼šè‹¥ç”Ÿæˆçƒå“¡çš„ `å¯è¨“ç·´èƒ½åŠ›ç¸½å’Œ` < `è©²ç­‰ç´šä¸Šé™ * 50%`ï¼Œå‰‡è¦–ç‚ºç„¡æ•ˆçƒå“¡ä¸¦è‡ªå‹•é‡éª° (Reroll)ã€‚
        - **ç›®çš„**ï¼šç¸®å°é–‹å±€éš¨æ©Ÿç¯„åœï¼Œé¿å… G/C ç´šçƒå“¡æ•¸å€¼éä½å°è‡´ç„¡æ³•ä¸Šå ´ã€‚
    - **è·è²¬åˆ†é›¢**: å …æŒå°‡æ­¤é‚è¼¯æ”¾åœ¨ `TeamCreator` è€Œé `PlayerGenerator`ï¼Œä¿æŒç”Ÿæˆå™¨çš„ç´”ç²¹éš¨æ©Ÿæ€§ï¼Œåƒ…åœ¨çµ„éšŠæ¥­å‹™é‚è¼¯ä¸­é€²è¡Œç¯©é¸ã€‚

2.  **ç”Ÿæˆå™¨æ•ˆèƒ½é‡æ§‹ (Player Generator Refactor)**
    - **éœæ…‹å¿«å– (Static Cache)**:
        - å¯¦ä½œ `initialize_class` æ–¹æ³•ã€‚
        - å•Ÿå‹•æ™‚ä¸€æ¬¡æ€§å°‡ DB ä¸­çš„ `NameLibrary` èˆ‡ YAML ä¸­çš„ `GameConfig` è¼‰å…¥è¨˜æ†¶é«” (`_config_cache`)ã€‚
        - **æ•ˆç›Š**: æ¶ˆé™¤æ¯æ¬¡ç”Ÿæˆçƒå“¡æ™‚é‡è¤‡è®€å– DB èˆ‡è§£æ YAML çš„ I/O é–‹éŠ·ï¼Œå¤§å¹…æå‡ç”Ÿæˆé€Ÿåº¦ã€‚
    - **å‹•æ…‹è¦å‰‡ç·¨è­¯**:
        - å°‡ YAML ä¸­çš„å­—ä¸²è¦å‰‡ (å¦‚ `"sum(def_rebound...) > ..."`) åœ¨åˆå§‹åŒ–éšæ®µè§£æç‚º Python Listã€‚
        - åŸ·è¡Œéšæ®µä¸å†ä½¿ç”¨ Regex è§£æï¼Œè€Œæ˜¯ç›´æ¥é€²è¡Œ List é‹ç®—ï¼Œå„ªåŒ–ä½ç½®æª¢æ ¸æ•ˆèƒ½ã€‚

3.  **æ¨¡æ“¬å·¥å…·ä¸­æ–‡åŒ– (Simulation Script Localization)**
    - æ›´æ–° `scripts/simulate_match_no_db.py`ã€‚
    - **æ–°å¢åŠŸèƒ½**: `print_team_details`ï¼Œåœ¨æ¨¡æ“¬å‰åˆ—å°é›™æ–¹çƒå“¡çš„ç­‰ç´šã€èº«é«˜ã€ç¸½è©•èˆ‡è©³ç´°å±¬æ€§ (æ¯ 5 é …æ›è¡Œ)ã€‚
    - **UI å„ªåŒ–**: æ‰€æœ‰è¼¸å‡ºè¨Šæ¯ã€è¡¨æ ¼æ¨™é ­ã€ç³»çµ±æ—¥èªŒçš†èª¿æ•´ç‚º **ç¹é«”ä¸­æ–‡**ï¼Œç¬¦åˆå°ˆæ¡ˆé–‹ç™¼è¦ç¯„ã€‚

### ğŸ“ ç­†è¨˜
- **æ•ˆèƒ½é ä¼°**: åœ¨ i9-14900K ç’°å¢ƒä¸‹ï¼Œé æœŸæ–°çš„ `PlayerGenerator` é…åˆå¿«å–æ©Ÿåˆ¶ï¼Œç”Ÿæˆé€Ÿåº¦å°‡æ¯” v2.6 ç‰ˆæœ¬æå‡é¡¯è‘—ï¼Œç‚ºæ¥ä¸‹ä¾†çš„æ¨¡æ“¬è¯è³½æ¸¬è©¦åšå¥½æº–å‚™ã€‚
- **é™¤éŒ¯é«”é©—**: ç¾åœ¨é€éæ¨¡æ“¬è…³æœ¬å¯ä»¥ç›´æ¥çœ‹åˆ°çƒå“¡çš„ç´°é …æ•¸å€¼ï¼Œå°æ–¼é©—è­‰ã€Œä½ç½®æª¢æ ¸ã€èˆ‡ã€Œèº«é«˜ä¿®æ­£ã€æ˜¯å¦ç”Ÿæ•ˆéå¸¸æœ‰å¹«åŠ©ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
1.  **å¤§æ•¸æ“šæ¸¬è©¦çƒå“¡ç”¢ç”Ÿå ±å‘Š**: åŸ·è¡Œæ–°ç‰ˆç”Ÿæˆå™¨ï¼Œç”¢å‡º 100 è¬ç­†æ•¸æ“šçš„ KPI å ±å‘Šï¼Œé©—è­‰ v3.2 ä¸‹é™è¦å‰‡èˆ‡ v3.1 èº«é«˜ä¿®æ­£çš„åˆ†å¸ƒæƒ…å½¢ã€‚
2.  **å¤§æ•¸æ“šæ¸¬è©¦æ¯”è³½å¼•æ“**: ä½¿ç”¨å¤§é‡éš¨æ©ŸéšŠä¼é€²è¡Œå°æˆ°ï¼Œåˆ†ææ¯”è³½æ•¸æ“š (Pace, FG%, Score) çš„å¸¸æ…‹åˆ†ä½ˆã€‚
3.  **è¨­è¨ˆæ¨¡æ“¬è¯è³½é‹ä½œæ–¹å¼**: è¦åŠƒæ¨¡æ“¬é¸ç§€ (Draft) é‚è¼¯åŠè‡ªç”±çƒå“¡ (Free Agency) ç”Ÿæˆæ©Ÿåˆ¶ã€‚

--

## 2025-12-27 05:30 ï¼šæ¯”è³½å¼•æ“ Phase 2 å®Œæˆèˆ‡å¤§æ•¸æ“šé©—è­‰æº–å‚™ (Match Engine Phase 2 Final & Big Data Prep)

### âœ… é€²åº¦æ‘˜è¦
æ­£å¼å®Œæˆäº† **Match Engine (Level 4 - Phase 2 Final)** çš„é–‹ç™¼èˆ‡æ•´åˆã€‚æœ¬æ¬¡æ›´æ–°é‡é»åœ¨æ–¼å®Œå–„æ¯”è³½ä¸­çš„é‚Šç·£æ¡ˆä¾‹è™•ç†ï¼ˆå¦‚çŠ¯æ»¿é›¢å ´å¾Œçš„ä¸Šå ´æ™‚é–“é‡åˆ†é…ï¼‰ï¼Œä¸¦å¼•å…¥äº†é€²éšæ•¸æ“šï¼ˆPace, Fastbreak Efficiencyï¼‰çš„è¨ˆç®—èˆ‡è¼¸å‡ºã€‚åŒæ™‚ï¼Œç‚ºäº†è¿æ¥å³å°‡åˆ°ä¾†çš„ã€Œä¸Šå„„æ¬¡ã€è¯è³½æ¨¡æ“¬æ¸¬è©¦ï¼Œå°æ ¸å¿ƒè³‡æ–™çµæ§‹é€²è¡Œäº†è¨˜æ†¶é«”å„ªåŒ– (`slots=True`)ï¼Œä¸¦ç¢ºèªäº†çƒå“¡ç”Ÿæˆå™¨ (v3.2) çš„å¤§æ•¸æ“šé©—è­‰çµæœç¬¦åˆå¸¸æ…‹åˆ†ä½ˆé æœŸã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **æ¯”è³½å¼•æ“æ ¸å¿ƒé‚è¼¯ (`app/services/match_engine/core.py`)**
    - **çŠ¯æ»¿é›¢å ´è™•ç† (Foul Out Logic)**:
        - å¯¦ä½œ `_check_and_handle_foul_out` æ–¹æ³•ã€‚
        - **æ©Ÿåˆ¶**: ç•¶çƒå“¡çŠ¯è¦é”ä¸Šé™ (Config å®šç¾©ï¼Œé è¨­ 6 æ¬¡) æ™‚ï¼Œå¼·åˆ¶ç§»å‡º `on_court`ã€‚
        - **æ™‚é–“é‡åˆ†é… (Redistribution)**: é—œéµæ¼”ç®—æ³•æ›´æ–°ã€‚çŠ¯æ»¿çƒå“¡å‰©é¤˜çš„ `target_seconds` ä¸æœƒæ†‘ç©ºæ¶ˆå¤±ï¼Œè€Œæ˜¯ä¾æ¬Šé‡å‹•æ…‹åˆ†é…çµ¦å ´ä¸ŠåŠæ¿å‡³ä¸ŠæœªçŠ¯æ»¿çš„éšŠå‹ï¼Œç¢ºä¿æ¯”è³½ç¸½æ™‚é–“ (240åˆ†é˜) å®ˆæ†ï¼Œé¿å…æ¨¡æ“¬å´©æ½°ã€‚
    - **é€²éšæ•¸æ“šè¨ˆç®—**:
        - **Pace (ç¯€å¥)**: æ•´åˆ `stat_possessions`ï¼Œæ–¼è³½å¾Œè¨ˆç®—æ¯ 48 åˆ†é˜å›åˆæ•¸ã€‚
        - **å¿«æ”» (Fastbreak)**: åœ¨ `_run_fastbreak` ä¸­åŠ å…¥ `record_fastbreak_event`ï¼Œè¿½è¹¤å¿«æ”»æˆåŠŸç‡èˆ‡æ¬¡æ•¸ã€‚

2.  **è³‡æ–™çµæ§‹æ•ˆèƒ½å„ªåŒ– (`app/services/match_engine/structures.py`)**
    - **è¨˜æ†¶é«”å„ªåŒ–**: å…¨é¢å¥—ç”¨ `@dataclass(slots=True)`ã€‚
    - **æ•ˆç›Š**: åœ¨å¤§è¦æ¨¡æ¨¡æ“¬ (100M+ å ´æ¬¡) ä¸‹ï¼Œé è¨ˆæ¸›å°‘ 40-50% çš„è¨˜æ†¶é«”ä½”ç”¨ï¼Œä¸¦æå‡ 20% çš„å±¬æ€§å­˜å–é€Ÿåº¦ã€‚
    - **æ¬„ä½æ“´å……**: `MatchResult` èˆ‡ `EnginePlayer` æ–°å¢ `pace`, `fb_made`, `fb_attempt`, `remaining_stamina` ç­‰æ¬„ä½ï¼Œæ”¯æ´ Phase 2 çš„æ•¸æ“šåˆ†æéœ€æ±‚ã€‚

3.  **é…ç½®æª”èˆ‡è¦å‰‡æ•´åˆ (`config/game_config.yaml`)**
    - **å­£å¾Œè³½è¦å‰‡**: æ–°å¢ `playoff` å€å¡Šï¼Œå®šç¾©å„è¼ªè³½åˆ¶ (3æˆ°2å‹ / 5æˆ°3å‹) åŠæ˜¯å¦å¼·åˆ¶æ‰“æ»¿ (Force Full Series) ä»¥åˆ©æ•¸æ“šæ”¶é›†ã€‚
    - **ç”Ÿæˆè¦å‰‡æ•´åˆ**: ç¢ºèª `height_modifiers` (èº«é«˜ä¿®æ­£) èˆ‡ `position_validation` (ä½ç½®æª¢æ ¸) åƒæ•¸å·²æ­£ç¢ºè¼‰å…¥ï¼Œä¸¦é€šé 12/24 çš„å¤§æ•¸æ“šé©—è­‰å ±å‘Šã€‚

### ğŸ“ ç­†è¨˜
- **é©—è­‰å ±å‘Š**: æ ¹æ“š `docs/player_generator_test_Report_20251224.md`ï¼Œçƒå“¡ç”Ÿæˆå™¨çš„èº«é«˜åˆ†ä½ˆ (Mean=195, SD=10) èˆ‡æ¥µç«¯å€¼è™•ç†å·²å®Œå…¨ç¬¦åˆæ•¸å­¸æ¨¡å‹ï¼Œä¸”ä½ç½®åˆ¤å®šçŸ©é™£æº–ç¢ºç‡æ¥µé«˜ï¼Œç‚ºæ¥ä¸‹ä¾†çš„è¯è³½æ¨¡æ“¬å¥ å®šè‰¯å¥½åŸºç¤ã€‚
- **ç³»çµ±ç©©å®šæ€§**: æ–°å¢çš„çŠ¯æ»¿æ™‚é–“é‡åˆ†é…é‚è¼¯ï¼Œè§£æ±ºäº†å…ˆå‰æ¨¡æ“¬ä¸­å› ä¸»åŠ›çŠ¯æ»¿å°è‡´æ¿å‡³æ™‚é–“ä¸è¶³è€Œ Crash çš„æ½›åœ¨é¢¨éšªã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **èº«é«˜å½±éŸ¿å¯¦è£**: å°‡èº«é«˜ (Height) åƒæ•¸æ›´æ·±å…¥åœ°æ•´åˆé€²æ¯”è³½å¼•æ“çš„åˆ¤å®šå…¬å¼ä¸­ (å¦‚ï¼šèº«é«˜å·®å°æŠ•ç±ƒå¹²æ“¾çš„å…·é«”å½±éŸ¿ä¿‚æ•¸)ã€‚
- **å¹´é½¡é«”åŠ›æ¨¡å‹**: å¯¦ä½œå¹´é½¡ (Age) å°æ–¼é«”åŠ›æ¶ˆè€— (Drain) èˆ‡æ¢å¾© (Recovery) çš„å½±éŸ¿æ›²ç·šï¼Œæ¨¡æ“¬è€å°‡èˆ‡æ–°ç§€åœ¨é«”èƒ½ä¸Šçš„çœŸå¯¦å·®ç•°ã€‚

--

## 2025-12-29 21:00 ï¼šæ¯”è³½å¼•æ“ç‰©ç†ä¿®æ­£èˆ‡é–‹éšŠé‚è¼¯å‡ç´š (Match Engine Physics & Team Gen v3.3)

### âœ… é€²åº¦æ‘˜è¦
æœ¬æ¬¡æ›´æ–°å®Œæˆäº† **Match Engine Spec v2.1** èˆ‡ **Player System Spec v3.3** çš„å¯¦ä½œã€‚é‡é»åœ¨æ–¼æå‡æ¯”è³½å¼•æ“çš„ç‰©ç†çœŸå¯¦åº¦ï¼ˆå¼•å…¥èº«é«˜ä¿®æ­£ã€å¹´é½¡é«”åŠ›è¡°é€€ï¼‰ï¼Œä¸¦å„ªåŒ–äº†é–‹éšŠç”Ÿæˆé‚è¼¯ï¼Œç¢ºä¿é«˜éšçƒå“¡ï¼ˆSSR/SS/Sï¼‰çš„ä½ç½®è¦†è“‹ç‡ã€‚åŒæ™‚ï¼Œç”¢å‡ºäº† 1200 è¬å ´æ¬¡çš„æ¨¡æ“¬æ¸¬è©¦å ±å‘Šï¼Œé©—è­‰äº†æ•¸å€¼æ¨¡å‹çš„ç©©å®šæ€§ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **æ¯”è³½å¼•æ“å„ªåŒ– (Match Engine v2.1)**
    - **èº«é«˜ä¿®æ­£ (Height Correction)**: 
        - å¯¦ä½œ `_apply_height_correction`ï¼Œåœ¨è³½å‰é‡å°èº«é«˜éé«˜æˆ–éçŸ®çš„çƒå“¡é€²è¡Œå±¬æ€§å¾®èª¿ï¼ˆå¦‚çŸ®å€‹å­é‹çƒåŠ æˆã€é«˜å€‹å­é‹çƒæ‡²ç½°ï¼‰ã€‚
        - æ›´æ–° `attr_pools`ï¼Œå°‡ `height` åŠ å…¥æŠ•ç±ƒã€ç±ƒæ¿ã€å°è“‹çš„åˆ¤å®šå…¬å¼ä¸­ã€‚
    - **é«”åŠ›ç³»çµ±å‡ç´š**:
        - å¼•å…¥ **å¹´é½¡è¡°é€€ (Age Decay)** æ©Ÿåˆ¶ï¼Œè¶…é 20 æ­²çš„çƒå“¡é«”åŠ›æ¶ˆè€—èˆ‡æ¢å¾©é€Ÿåº¦æœƒéš¨å¹´é½¡ç·šæ€§è¡°é€€ã€‚
        - ä¿®æ­£ `_check_and_handle_foul_out`ï¼Œæ¡ç”¨ **Positional Top-K** é‚è¼¯ï¼Œå°‡çŠ¯æ»¿é›¢å ´çƒå“¡çš„æ™‚é–“ç²¾æº–åˆ†é…çµ¦åŒä½ç½®æœ€å¼·çš„ 3 åéšŠå‹ï¼Œé¿å…æ¨¡æ“¬å´©æ½°ã€‚
    - **è¦å‰‡åƒæ•¸åŒ–**: å°‡é—œéµæ™‚åˆ»é–¾å€¼ (`clutch_time_threshold`) èˆ‡ä¸‰åˆ†çƒåŠ æˆå€ç‡ (`multiplier_3pt`) ç§»è‡³ Config ç®¡ç†ã€‚

2.  **é–‹éšŠç”Ÿæˆé‚è¼¯å‡ç´š (Team Creator v3.3)**
    - **é«˜éšè¦†è“‹æª¢æ ¸ (High-Tier Coverage)**:
        - åœ¨ `_validate_roster_positions` æ–°å¢é‚è¼¯ã€‚
        - å¼·åˆ¶è¦æ±‚éšŠä¼ä¸­çš„é«˜éšçƒå“¡ (SSR/SS/S) å¿…é ˆè¦†è“‹ C, PF, SF, SG, PG å…¨éƒ¨ 5 å€‹ä½ç½®ï¼Œé¿å…é–‹å±€ç¥å¡ä½ç½®é‡ç–Šã€‚
    - **æ•ˆèƒ½èª¿æ•´**: é…åˆæ›´åš´æ ¼çš„æª¢æ ¸æ¢ä»¶ï¼Œå¢åŠ äº†ç”Ÿæˆå˜—è©¦æ¬¡æ•¸ä¸Šé™ã€‚

3.  **æ¸¬è©¦èˆ‡é©—è­‰å·¥å…·**
    - **æ–°å¢ `scripts/debug_team_generation.py`**: 
        - ç”¨æ–¼ç”Ÿæˆæ¸¬è©¦ç”¨çš„çƒéšŠ Parquet æª”ï¼Œä¸¦è¨ˆç®—åŠ æ¬Šæˆ°åŠ›ï¼Œæ–¹ä¾¿è§€å¯Ÿæ•¸å€¼åˆ†ä½ˆã€‚
    - **æ¨¡æ“¬å ±å‘Š (`docs/team_creator_test_report_*.md`)**:
        - åŸ·è¡Œäº† 1200 è¬å ´æ¨¡æ“¬ã€‚
        - ç¢ºèªå‹ç‡åˆ†ä½ˆæ­£å¸¸ (å¼·éšŠ ~58%, å¼±éšŠ ~36%)ã€‚
        - ç¢ºèªé«”åŠ›ç³»çµ±é‹ä½œæ­£å¸¸ (ç–²å‹ç‹€æ…‹ä½”æ¯” ~11%)ã€‚
        - ç¢ºèªçŠ¯è¦åˆ†ä½ˆæ­£å¸¸ (å¹³å‡å–®å ´ 6.8 æ¬¡)ã€‚

4.  **è¦æ ¼æ›¸æ›´æ–°**
    - æ›´æ–° `ASBL_Match_Engine_Specification.md` è‡³ v2.1ã€‚
    - æ›´æ–° `ASBL_Player_System_Specification.md` è‡³ v3.3ã€‚
    - æ›´æ–° `config/game_config.yaml` å°æ‡‰ä¸Šè¿°è®Šæ›´ã€‚

### ğŸ“ ç­†è¨˜
- **å¹³è¡¡æ€§è§€å¯Ÿ**: æ ¹æ“šæ¸¬è©¦å ±å‘Šï¼ŒT001 (SSR SG) èˆ‡ T002 (SSR SF) çš„å‹ç‡é¡¯è‘—é«˜æ–¼ T003/T004ï¼Œé¡¯ç¤ºæ ¸å¿ƒçƒå“¡çš„å½±éŸ¿åŠ›ç¬¦åˆé æœŸã€‚
- **é«”åŠ›å½±éŸ¿**: æ•¸æ“šé¡¯ç¤ºã€Œé€æ”¯ç‹€æ…‹ (<20)ã€çš„å‘½ä¸­ç‡ä¸¦æœªé¡¯è‘—å´©ç›¤ï¼Œå¯èƒ½éœ€è¦å¾®èª¿ `stamina_nerf_threshold` æˆ–è¡°é€€å…¬å¼ï¼Œè®“ç–²å‹æ‡²ç½°æ›´å…·é«”æ„Ÿã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **é–‹éšŠæ•¸æ“šçµ±è¨ˆé©—è­‰**: é‡å°ç”Ÿæˆçš„ä¸€å„„ç­†æˆ–å¤§é‡é–‹éšŠæ•¸æ“šé€²è¡Œçµ±è¨ˆåˆ†æï¼Œç¢ºèª v3.3 è¦å‰‡ä¸‹çš„åˆ†ä½ˆã€‚
- **å®šç¾©è¯è³½èˆ‡é¸ç§€**: é–‹å§‹è¦åŠƒ `League` è³‡æ–™çµæ§‹èˆ‡ `Draft` é¸ç§€é‚è¼¯ã€‚

--

## 2026-01-10 06:00 ï¼šæ¯”è³½å¼•æ“è¨ˆç®—é‚è¼¯é‡æ§‹èˆ‡å‘½ä¸­ç‡ä¿®å¾© (Match Engine Logic Refactor & Shooting Rate Fix)

### âœ… é€²åº¦æ‘˜è¦
æœ¬æ¬¡æ›´æ–°ä¸»è¦é‡å° **Match Engine** çš„ä»£ç¢¼æ¶æ§‹é€²è¡Œäº†æ·±åº¦é‡æ§‹ï¼Œè§£æ±ºäº†æ ¸å¿ƒé‚è¼¯èˆ‡è¼”åŠ©å·¥å…· (`Calculator`) ä¸åŒæ­¥çš„å•é¡Œã€‚å¯¦ä½œäº† **Spec v2.2 (æŠ€å·§åŠ æˆ)** èˆ‡ **Spec v2.3 (æŠ„æˆªè½‰æ›)**ï¼Œä¸¦ä¿®å¾©äº†é‡æ§‹éç¨‹ä¸­å› ã€Œå°æŠ—ç¯„åœä¸å°ç­‰ã€å°è‡´å‘½ä¸­ç‡å´©è·Œè‡³ 10% çš„åš´é‡ Bugã€‚ç¾åœ¨ `Calculator` å·²æˆç‚ºæŠ•ç±ƒåˆ¤å®šé‚è¼¯çš„å”¯ä¸€çœŸç† (Single Source of Truth)ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **Calculator å·¥å…·å‡ç´š (`app/services/match_engine/utils/calculator.py`)**
    - **é‚è¼¯å°è£**: å°‡åŸæœ¬æ•£è½åœ¨ `core.py` ä¸­çš„æŠ•ç±ƒå…¬å¼ï¼ˆåŒ…å« 2åˆ†/3åˆ† åŸºç¤ç‡é¸æ“‡ã€å±¬æ€§åŠ æˆå€ç‡ï¼‰å®Œæ•´ç§»å…¥ `calculate_shooting_rate`ã€‚
    - **ä»‹é¢æ›´æ–°**: æ–¹æ³•ç°½ç« æ“´å……ï¼Œç¾åœ¨æ¥æ”¶ `off_players` (é€²æ”»å…¨éšŠ)ã€`def_players` (é˜²å®ˆå…¨éšŠ) èˆ‡ `shooter` (å‡ºæ‰‹è€…) ä¸‰ç¨®åƒæ•¸ã€‚
    - **Spec v2.2 å¯¦ä½œ**: åŠ å…¥ **æŠ€å·§åŠ æˆ (Skill Bonus)** è¨ˆç®—ï¼Œå…¬å¼ç‚º `1 + (accuracy+range+move)/800`ï¼Œé‡å°å‡ºæ‰‹è€…å€‹äººèƒ½åŠ›é€²è¡Œé¡å¤–ä¿®æ­£ã€‚

2.  **æ¯”è³½å¼•æ“ç˜¦èº« (`app/services/match_engine/core.py`)**
    - **è·è²¬åˆ†é›¢**: `_run_shooting` ä¸å†é€²è¡Œæ•¸å­¸é‹ç®—ï¼Œåƒ…è² è²¬æµç¨‹æ§åˆ¶ï¼ˆå¦‚æ±ºå®šæ˜¯å¦æŠ•ä¸‰åˆ†ã€æ˜¯å¦çŠ¯è¦ï¼‰ï¼Œè¨ˆç®—å·¥ä½œå…¨æ•¸å§”æ´¾çµ¦ `Calculator`ã€‚
    - **Spec v2.3 å¯¦ä½œ**: åœ¨å¾Œå ´éšæ®µ (`_run_backcourt`) åŠ å…¥äº† **æŠ„æˆªè½‰æ› (Steal Transition)** åˆ¤å®šã€‚ç•¶ç™¼ç”ŸæŠ„æˆªæ™‚ï¼Œä¾æ“šé›™æ–¹é€Ÿåº¦ç¸½å’Œåˆ¤å®šæ˜¯ç™¼å‹•å¿«æ”»é‚„æ˜¯é€²å…¥é™£åœ°æˆ°ã€‚

3.  **é—œéµ Bug ä¿®å¾© (Critical Fix)**
    - **å•é¡Œ**: åˆæ¬¡é‡æ§‹æ™‚ï¼Œèª¤å°‡ `off_player` (å–®äºº) å‚³å…¥å°æŠ—å…¬å¼èˆ‡ `def_players` (äº”äºº) é€²è¡Œæ•¸å€¼æ¯”è¼ƒã€‚
    - **ç¾è±¡**: é€²æ”»æ–¹æ•¸å€¼é ä½æ–¼é˜²å®ˆæ–¹ï¼Œå°è‡´ `stat_diff` ç‚ºè² å€¼ï¼Œå‘½ä¸­ç‡è¢«æˆªæ–·åœ¨ä¸‹é™ (1%~10%)ã€‚
    - **ä¿®æ­£**: ä¿®æ­£ `Calculator` ä»‹é¢ï¼Œæ˜ç¢ºå€åˆ† **ã€Œåœ˜éšŠå°æŠ— (Team Rating)ã€** èˆ‡ **ã€Œå€‹äººæŠ€å·§ (Skill Bonus)ã€** çš„è¨ˆç®—ä¾†æºï¼Œå‘½ä¸­ç‡å›æ­¸æ­£å¸¸å€é–“ (30%~50%)ã€‚

### ğŸ“ ç­†è¨˜
- **æ¶æ§‹æ•ˆç›Š**: é€™æ¬¡é‡æ§‹é›–ç„¶èŠ±è²»äº†æ™‚é–“è§£æ±º Bugï¼Œä½†å¤§å¹…æå‡äº†ä»£ç¢¼çš„å¯æ¸¬è©¦æ€§ã€‚æœªä¾†è‹¥è¦èª¿æ•´å‘½ä¸­ç‡å…¬å¼ï¼ˆä¾‹å¦‚ä¿®æ”¹ Spacing æ¬Šé‡ï¼‰ï¼Œåªéœ€ä¿®æ”¹ `Calculator` ä¸€è™•å³å¯ï¼Œä¸ç”¨æ“”å¿ƒ `Core` èˆ‡ UI é¡¯ç¤ºçš„æ•¸å€¼ä¸ä¸€è‡´ã€‚
- **æ•¸å€¼è§€å¯Ÿ**: åŠ å…¥ Skill Bonus å¾Œï¼Œé«˜æ•¸å€¼å°„æ‰‹ (SSR) çš„çµ±æ²»åŠ›é€²ä¸€æ­¥æå‡ï¼Œç¬¦åˆè¨­è¨ˆé æœŸã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **Pace æ©Ÿåˆ¶èª¿æ•´**: ä¿®æ”¹é€Ÿåº¦å±¬æ€§ (Speed) å°æ–¼æ¯”è³½å›åˆæ•¸ (Possessions/Pace) çš„å½±éŸ¿æ¬Šé‡ï¼Œè®“å¿«ç¯€å¥çƒéšŠèƒ½æ‰“å‡ºæ›´å¤šå›åˆã€‚
- **éšŠä¼å¹³è¡¡æ¸¬è©¦**: åŸ·è¡Œå¤§è¦æ¨¡æ¨¡æ“¬ï¼Œé©—è­‰ä¸åŒæˆ°è¡“é¢¨æ ¼ï¼ˆå¦‚å¿«æ”»éšŠ vs é™£åœ°æˆ°éšŠï¼‰çš„å‹ç‡å¹³è¡¡ã€‚

--

## 2026-01-16 15:30 ï¼šé€²éšæ•¸æ“šçµ±è¨ˆèˆ‡ç‰©ç†æ©Ÿåˆ¶è£œå®Œ (Advanced Stats & Physics Completion)

### âœ… é€²åº¦æ‘˜è¦
æœ¬æ¬¡æ›´æ–°å®Œæˆäº† **Match Engine** çš„åŠŸèƒ½è£œå®Œï¼Œé‡é»åœ¨æ–¼å¯¦ä½œ **Spec v2.1** çš„èº«é«˜ä¿®æ­£æ©Ÿåˆ¶èˆ‡ **Spec v2.3** çš„æŠ„æˆªè½‰æ›é‚è¼¯ã€‚åŒæ™‚ï¼Œç‚ºäº†æ”¯æ´æ›´æ·±åº¦çš„æˆ°è¡“åˆ†æï¼Œæ–°å¢äº† **æ­£è² å€¼ (+/-)** èˆ‡ **å›åˆæ™‚é–“ (Possession Time)** çš„çµ±è¨ˆè¿½è¹¤ã€‚åº•å±¤éƒ¨åˆ†ï¼Œé‡å° `RNG` æ¨¡çµ„é€²è¡Œäº†å¾®å¹…å„ªåŒ–ä»¥é¿å…æ½›åœ¨çš„ç¶å®šå•é¡Œã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **é€²éšæ•¸æ“šç³»çµ± (`app/services/match_engine/structures.py` & `attribution.py`)**
    - **æ­£è² å€¼ (+/-)**:
        - åœ¨ `EnginePlayer` æ–°å¢ `stat_plus_minus` æ¬„ä½ã€‚
        - å¯¦ä½œ `AttributionSystem.update_plus_minus`ï¼Œåœ¨å¾—åˆ†æˆ–ç½°çƒé€²çƒæ™‚ï¼Œå‹•æ…‹æ›´æ–°å ´ä¸Šé›™æ–¹çƒå“¡çš„æ­£è² å€¼ã€‚
    - **å›åˆæ™‚é–“ (Possession Time)**:
        - åœ¨ `EngineTeam` æ–°å¢ `stat_possession_seconds` (ç´¯ç©) èˆ‡ `stat_possession_history` (æ­·ç¨‹)ã€‚
        - åœ¨ `MatchEngine._simulate_quarter` ä¸­ï¼Œå°‡æ¯å€‹å›åˆçš„æ¶ˆè€—æ™‚é–“ (`elapsed`) æ­¸å±¬çµ¦é€²æ”»æ–¹ï¼Œç”¨æ–¼åˆ†æçƒéšŠçš„é€²æ”»ç¯€å¥ (Pace) èˆ‡æ‹–å»¶æˆ°è¡“ã€‚

2.  **ç‰©ç†æ©Ÿåˆ¶å¯¦è£ (`app/services/match_engine/core.py`)**
    - **èº«é«˜ä¿®æ­£ (Height Correction)**:
        - å¯¦ä½œ `_apply_height_correction` æ–¹æ³• (Spec v2.1)ã€‚
        - ä¾æ“š Config å®šç¾©çš„ `bonus_threshold` (190cm) èˆ‡ `nerf_threshold` (210cm)ï¼Œåœ¨è³½å‰æ°¸ä¹…æ€§ä¿®æ­£çƒå“¡çš„ `speed`, `dribble`, `handle`, `disrupt` ç­‰å±¬æ€§ã€‚
    - **æŠ„æˆªè½‰æ›é‚è¼¯ (Transition Logic)**:
        - åœ¨ `_run_backcourt` ä¸­å®Œå–„äº† Spec v2.3 çš„åˆ¤æ–·ã€‚
        - ç•¶ç™¼ç”Ÿå¾Œå ´æŠ„æˆªæ™‚ï¼Œè¨ˆç®—é›™æ–¹å ´ä¸Šäº”äººçš„é€Ÿåº¦ç¸½å’Œï¼Œä¾æ“šé€Ÿåº¦å·®åˆ¤å®šæ˜¯ç™¼å‹• **å¿«æ”» (Fastbreak)** é‚„æ˜¯é€²å…¥ **é™£åœ°æˆ° (Set Play)**ã€‚

3.  **åº•å±¤å„ªåŒ– (`app/services/match_engine/utils/rng.py`)**
    - **Module Level Binding**: å°‡ `random` çš„æ–¹æ³•ç¶å®šå¾é¡åˆ¥å±¤ç´šç§»è‡³æ¨¡çµ„å±¤ç´š (`_sys_random`, `_sys_uniform`)ã€‚
    - **ç›®çš„**: é¿å…åœ¨ Python æ–°ç‰ˆæœ¬ä¸­å°‡ç¶å®šæ–¹æ³•æŒ‡æ´¾çµ¦é¡åˆ¥å±¬æ€§æ™‚å¯èƒ½ç”¢ç”Ÿçš„åƒæ•¸å‚³ééŒ¯èª¤ï¼ŒåŒæ™‚ä¿æŒæ¥µè‡´çš„æ•ˆèƒ½ã€‚

4.  **è¼¸å‡ºä»‹é¢æ›´æ–°**
    - æ›´æ–° `MatchResult` dataclassï¼Œæ–°å¢ `home_possession_history`, `home_avg_seconds_per_poss` ç­‰æ¬„ä½ï¼Œè®“å‰ç«¯èƒ½ç¹ªè£½é€²æ”»æ™‚é–“åˆ†ä½ˆåœ–ã€‚

### ğŸ“ ç­†è¨˜
- **æ•¸æ“šè§€å¯Ÿ**: åŠ å…¥å›åˆæ™‚é–“çµ±è¨ˆå¾Œï¼Œå¯ä»¥æ˜é¡¯å€åˆ†å‡ºã€Œè·‘è½ŸçƒéšŠã€èˆ‡ã€Œé™£åœ°æˆ°çƒéšŠã€çš„å¹³å‡é€²æ”»æ™‚é–“å·®ç•°ï¼ˆä¾‹å¦‚ 8ç§’ vs 18ç§’ï¼‰ã€‚
- **æ­£è² å€¼é©—è­‰**: åˆæ­¥æ¸¬è©¦é¡¯ç¤ºï¼Œä¸»åŠ›çƒå“¡åœ¨å ´æ™‚çš„ +/- å€¼é€šå¸¸ç‚ºæ­£ï¼Œç¬¦åˆé æœŸï¼Œæ­¤æ•¸æ“šå°‡æˆç‚ºè©•ä¼°çƒå“¡ã€Œéš±å½¢è²¢ç»ã€çš„é‡è¦æŒ‡æ¨™ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **æ”¹å–„é€Ÿåº¦å°æ–¼çƒéšŠå›åˆæ•¸çš„å½±éŸ¿**

--

## 2026-01-25 10:00 ï¼šæ¯”è³½å¼•æ“ v2.4 é•ä¾‹æ©Ÿåˆ¶èˆ‡é€Ÿåº¦ç¯€å¥å„ªåŒ– (Match Engine v2.4 Violations & Speed/Pace)

### âœ… é€²åº¦æ‘˜è¦
æœ¬æ¬¡æ›´æ–°å°‡æ¯”è³½å¼•æ“æ¨é€²è‡³ **v2.4** ç‰ˆæœ¬ï¼Œæ ¸å¿ƒç›®æ¨™æ˜¯å¼·åŒ–ã€Œé€Ÿåº¦å±¬æ€§ã€å°æ¯”è³½ç¯€å¥çš„å¯¦è³ªå½±éŸ¿ï¼Œä¸¦è£œå®Œç±ƒçƒè¦å‰‡ä¸­çš„é•ä¾‹æ©Ÿåˆ¶ã€‚å¯¦ä½œäº† **é€Ÿåº¦æŠ˜æ‰£ (Speed Discount)** æ©Ÿåˆ¶ï¼Œè®“é€Ÿåº¦å¿«çš„çƒéšŠèƒ½ä»¥æ›´çŸ­æ™‚é–“å®Œæˆæ¨é€²èˆ‡é€²æ”»ï¼Œé€²è€Œæå‡å›åˆæ•¸ (Pace)ã€‚åŒæ™‚ï¼Œæ–°å¢äº† **8ç§’é•ä¾‹** èˆ‡ **24ç§’é•ä¾‹** çš„åˆ¤å®šé‚è¼¯ï¼Œå®Œå–„äº†å¤±èª¤ (Turnover) çš„é¡å‹ã€‚æœ€å¾Œï¼Œæ›´æ–°äº†å¤§æ•¸æ“šæ¸¬è©¦è…³æœ¬ï¼Œä»¥é©—è­‰æ–°æ©Ÿåˆ¶çš„æ•¸å€¼åˆ†ä½ˆã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **æ¯”è³½å¼•æ“æ ¸å¿ƒé‚è¼¯ (`app/services/match_engine/core.py`)**
    - **é€Ÿåº¦æŠ˜æ‰£ (Speed Discount)**:
        - åœ¨ `_run_backcourt` (å¾Œå ´) èˆ‡ `_run_frontcourt` (å‰å ´) éšæ®µå¼•å…¥æ–°å…¬å¼ã€‚
        - **æ©Ÿåˆ¶**: è¨ˆç®—é€²æ”»æ–¹å ´ä¸Šçƒå“¡çš„å¹³å‡é€Ÿåº¦ï¼Œä¾æ“š Config å®šç¾©çš„ä¿‚æ•¸ (`speed_discount_coeff`) éš¨æ©Ÿæ‰£é™¤æ¶ˆè€—æ™‚é–“ã€‚
        - **æ•ˆç›Š**: é€Ÿåº¦è¶Šå¿«çš„çƒéšŠï¼Œå–®ä¸€å›åˆæ¶ˆè€—æ™‚é–“è¶ŠçŸ­ï¼Œæ•´å ´æ¯”è³½çš„ç¸½å›åˆæ•¸ (Possessions) è‡ªç„¶æå‡ï¼Œè§£æ±ºäº†å…ˆå‰ Pace èˆ‡ Speed ç›¸é—œæ€§ä¸è¶³çš„å•é¡Œã€‚
    - **é•ä¾‹åˆ¤å®š (Violations)**:
        - **8ç§’é•ä¾‹**: è‹¥å¾Œå ´æ¨é€²æ™‚é–“ > 8.0 ç§’ï¼Œè§¸ç™¼ `record_8sec_violation` ä¸¦è½‰æ›çƒæ¬Šã€‚
        - **24ç§’é•ä¾‹**: è‹¥ (å¾Œå ´æ™‚é–“ + å‰å ´æ™‚é–“) > 24.0 ç§’ï¼Œè§¸ç™¼ `record_24sec_violation` ä¸¦è½‰æ›çƒæ¬Šã€‚

2.  **æ•¸æ“šçµæ§‹èˆ‡æ­¸å±¬ (`structures.py` & `attribution.py`)**
    - **çµæ§‹æ“´å……**: åœ¨ `EngineTeam` èˆ‡ `MatchResult` ä¸­æ–°å¢ `stat_violation_8s` èˆ‡ `stat_violation_24s` æ¬„ä½ã€‚
    - **æ­¸å±¬é‚è¼¯**: æ–°å¢å°ˆå±¬çš„è¨˜éŒ„æ–¹æ³•ï¼Œå°‡é•ä¾‹è¨ˆå…¥ã€Œåœ˜éšŠå¤±èª¤ (Team Turnover)ã€ï¼Œä¸å½±éŸ¿çƒå“¡å€‹äººå¤±èª¤æ•¸æ“šã€‚

3.  **é…ç½®æª”æ›´æ–° (`config/game_config.yaml`)**
    - **Backcourt**: æ–°å¢ `speed_discount_coeff` (é è¨­ 0.1) èˆ‡ `violation_threshold` (8.0)ã€‚
    - **Frontcourt**: æ–°å¢ `speed_discount_coeff` (é è¨­ 0.01) èˆ‡ `violation_threshold` (24.0)ã€‚
    - **ç‰©ç†é™åˆ¶**: è¨­å®šäº†æ™‚é–“è¨ˆç®—çš„ç‰©ç†ä¸‹é™ (`min_time_limit`)ï¼Œé˜²æ­¢å› æŠ˜æ‰£éå¤§å°è‡´æ™‚é–“ç‚ºè² ã€‚

4.  **å¤§æ•¸æ“šæ¸¬è©¦å·¥å…· (`tests/match_bigdata_test/run_core_bigdata_test.py`)**
    - **å ±å‘Šå‡ç´š**: 
        - æ–°å¢ã€Œé€Ÿåº¦å°çƒéšŠå›åˆæ•¸ (Pace) çš„å½±éŸ¿ã€åˆ†æç« ç¯€ï¼Œè¨ˆç®—åŠ æ¬Šé€Ÿåº¦èˆ‡ Pace çš„ç›¸é—œä¿‚æ•¸ã€‚
        - æ–°å¢ã€Œé•ä¾‹è©³ç´°åˆ†æã€ç« ç¯€ï¼Œçµ±è¨ˆ 8ç§’/24ç§’é•ä¾‹çš„ç™¼ç”Ÿé »ç‡èˆ‡ä½”æ¯”ã€‚
    - **ç©©å®šæ€§å„ªåŒ–**: å¼•å…¥ `faulthandler` èˆ‡ Flush éš”é›¢æ©Ÿåˆ¶ï¼Œé˜²æ­¢å–®ä¸€å ´æ¬¡æ¨¡æ“¬å¤±æ•—å°è‡´æ•´å€‹æ¸¬è©¦ä¸­æ–·ã€‚

### ğŸ“ ç­†è¨˜
- **å¹³è¡¡æ€§è§€å¯Ÿ**: åˆæ­¥æ¸¬è©¦é¡¯ç¤ºï¼Œå¼•å…¥é€Ÿåº¦æŠ˜æ‰£å¾Œï¼Œé«˜é€Ÿåº¦çƒéšŠçš„ Pace æ˜é¡¯æå‡ï¼Œä¸” 24 ç§’é•ä¾‹é€šå¸¸ç™¼ç”Ÿåœ¨é˜²å®ˆå£“è¿«æ¥µå¼·æˆ–é€²æ”»æ–¹é€Ÿåº¦æ¥µæ…¢çš„æ¥µç«¯å°å±€ä¸­ï¼Œç¬¦åˆé æœŸã€‚
- **æ•¸æ“šé©—è­‰**: éœ€æŒçºŒè§€å¯Ÿé•ä¾‹ç™¼ç”Ÿçš„æ©Ÿç‡æ˜¯å¦éé«˜ (ä¾‹å¦‚è¶…éç¸½å›åˆæ•¸çš„ 5%)ï¼Œè‹¥éé«˜å‰‡éœ€å¾®èª¿ `time_base` æˆ– `violation_threshold`ã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
- **ä¿®æ­£ç¨‹å¼ç¢¼å…§èˆ‡æŠ€è¡“æ–‡ä»¶ä¸ç¬¦åˆçš„å…§å®¹**: å…¨é¢ç›¤é» Codebase èˆ‡ Spec æ–‡ä»¶çš„å·®ç•°ä¸¦é€²è¡ŒåŒæ­¥ã€‚
- **çƒå“¡å‘½åè¦å‰‡**: å„ªåŒ–å§“åç”Ÿæˆåº«ï¼Œå¯èƒ½å¼•å…¥æ›´å¤šæ¨£åŒ–çš„å‘½åé‚è¼¯ã€‚
- **ç¨‹å¼æ›´æ–°ä¿®æ­£**: é‡å°æ¸¬è©¦ä¸­ç™¼ç¾çš„å¾®å° Bug é€²è¡Œä¿®å¾©ã€‚

--

## 2026-01-26 22:00 : å§“åç”Ÿæˆç³»çµ±é‡æ§‹èˆ‡æ¯”è³½å¼•æ“é•ä¾‹æ©Ÿåˆ¶ (Name Gen Refactor & Match Engine Violations)

### âœ… é€²åº¦æ‘˜è¦
æœ¬æ¬¡æ›´æ–°å®Œæˆäº† **Player System Spec v3.4** èˆ‡ **Match Engine Spec v2.4** çš„å¯¦ä½œã€‚æ ¸å¿ƒè®Šå‹•åŒ…æ‹¬é‡æ§‹äº†çƒå“¡å§“åç”Ÿæˆé‚è¼¯ï¼Œæ”¯æ´å¤šèªç³»ï¼ˆæ­ç¾ã€æ±äºã€åŸä½æ°‘ï¼‰çš„å‹•æ…‹ç”Ÿæˆç­–ç•¥ï¼Œä¸¦åœ¨è³‡æ–™åº«å±¤ç´šæ–°å¢äº†åœ‹ç±æ¬„ä½ã€‚åœ¨æ¯”è³½å¼•æ“æ–¹é¢ï¼Œæ­£å¼å¯¦è£äº† **8ç§’/24ç§’é•ä¾‹** åˆ¤å®šï¼Œä¸¦å¼•å…¥ **é€Ÿåº¦æŠ˜æ‰£ (Speed Discount)** æ©Ÿåˆ¶ï¼Œå¼·åŒ–äº†çƒéšŠé€Ÿåº¦å±¬æ€§å°æ¯”è³½ç¯€å¥ (Pace) çš„å¯¦è³ªå½±éŸ¿ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **çƒå“¡ç”Ÿæˆç³»çµ±é‡æ§‹ (Spec v3.4)**
    -   **å¤šèªç³»å§“åç­–ç•¥**:
        -   åœ¨ `PlayerGenerator` ä¸­å¯¦ä½œäº†ä¸‰ç¨®ç”Ÿæˆç­–ç•¥ï¼š
            -   **Strategy A (æ­ç¾)**: éš¨æ©ŸæŠ½å– 3 å­—çµ„åˆï¼Œä»¥é–“éš”è™Ÿåˆ†éš”ã€‚
            -   **Strategy B (æ±äº)**: å§“ + å (1~2å­—)ï¼Œç„¡åˆ†éš”ç¬¦ã€‚
            -   **Strategy C (åŸä½æ°‘)**: éš¨æ©ŸæŠ½å– 2 å€‹ä¸é‡è¤‡å­—çµ„åˆï¼Œä»¥é–“éš”è™Ÿåˆ†éš”ã€‚
        -   ç­–ç•¥å°æ‡‰é—œä¿‚ç”± `config/game_config.yaml` å‹•æ…‹é©…å‹•ã€‚
    -   **è³‡æ–™åº«æ¨¡å‹è®Šæ›´**:
        -   `NameLibrary`: æ–°å¢ `language`, `category`, `weight` æ¬„ä½ï¼Œæ”¯æ´æ¬Šé‡æŠ½å–ã€‚
        -   `Player`: æ–°å¢ `nationality` æ¬„ä½ï¼Œè¨˜éŒ„çƒå“¡èªç³»ä¾†æºã€‚

2.  **æ¯”è³½å¼•æ“åŠŸèƒ½æ“´å…… (Spec v2.4)**
    -   **é•ä¾‹æ©Ÿåˆ¶ (Violations)**:
        -   åœ¨ `MatchEngine` æ ¸å¿ƒè¿´åœˆä¸­åŠ å…¥ **8ç§’é•ä¾‹** (å¾Œå ´) èˆ‡ **24ç§’é•ä¾‹** (å…¨å ´) çš„æ™‚é–“åˆ¤å®šã€‚
        -   æ–°å¢ `stat_violation_8s` èˆ‡ `stat_violation_24s` çµ±è¨ˆæ¬„ä½ï¼Œä¸¦å°‡å…¶æ­¸å±¬ç‚ºåœ˜éšŠå¤±èª¤ (Team Turnover)ã€‚
    -   **é€Ÿåº¦æŠ˜æ‰£ (Speed Discount)**:
        -   å¯¦ä½œé€Ÿåº¦å°æ™‚é–“æ¶ˆè€—çš„å½±éŸ¿å…¬å¼ã€‚é€²æ”»æ–¹é€Ÿåº¦è¶Šå¿«ï¼Œæ¨é€²èˆ‡é€²æ”»æ¶ˆè€—çš„æ™‚é–“è¶ŠçŸ­ (Discount)ï¼Œé€²è€Œæå‡æ•´å ´æ¯”è³½çš„å›åˆæ•¸ (Pace)ã€‚
    -   **å¹´é½¡é«”åŠ›è¡°é€€**:
        -   åœ¨ `StaminaSystem` ä¸­å¯¦ä½œå¹´é½¡å› å­ï¼Œ20 æ­²ä»¥ä¸Šçƒå“¡çš„é«”åŠ›æ¶ˆè€—èˆ‡æ¢å¾©é€Ÿåº¦å°‡éš¨å¹´é½¡ç·šæ€§è¡°é€€ã€‚

3.  **å¤§æ•¸æ“šæ¸¬è©¦å·¥å…·å„ªåŒ–**
    -   **ç©©å®šæ€§å¢å¼·**: å¼•å…¥ `faulthandler` èˆ‡ Flush éš”é›¢æ©Ÿåˆ¶ï¼Œé˜²æ­¢å–®å ´æ¨¡æ“¬éŒ¯èª¤å°è‡´æ•´å€‹æ¸¬è©¦ä¸­æ–·ã€‚
    -   **å ±å‘Šå‡ç´š**: æ–°å¢é•ä¾‹åˆ†ä½ˆçµ±è¨ˆèˆ‡ã€Œé€Ÿåº¦ vs Paceã€çš„ç›¸é—œæ€§åˆ†æï¼Œé©—è­‰æ–°æ©Ÿåˆ¶çš„æ•¸å€¼å¹³è¡¡ã€‚

### ğŸ“ ç­†è¨˜
-   **æ•¸æ“šè§€å¯Ÿ**: åˆæ­¥æ¸¬è©¦é¡¯ç¤ºï¼Œå¼•å…¥é€Ÿåº¦æŠ˜æ‰£å¾Œï¼Œé«˜é€Ÿåº¦çƒéšŠçš„ Pace æœ‰é¡¯è‘—æå‡ï¼Œè§£æ±ºäº†å…ˆå‰é€Ÿåº¦å±¬æ€§æ•ˆç›Šä¸æ˜é¡¯çš„å•é¡Œã€‚
-   **è³‡æ–™åº«é·ç§»**: ç”±æ–¼ `Player` èˆ‡ `NameLibrary` æ¨¡å‹æœ‰æ¬„ä½è®Šæ›´ï¼Œéœ€æ³¨æ„è³‡æ–™åº«é·ç§» (Migration) æˆ–é‡å»ºã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
-   **å…¨é¢ä»£ç¢¼å¯©æŸ¥**: é‡æ–°æª¢æŸ¥æ‰€æœ‰ç¾æˆç¨‹å¼ç¢¼ï¼Œç¢ºä¿èˆ‡è¨ˆç•«æ›¸ (Spec) å®Œå…¨ä¸€è‡´ï¼Œä¸¦ä¿®å¾©æ½›åœ¨çš„ä¸é€£è²«è™•ã€‚
-   **æ—¥å¸¸ç³»çµ±æ¶æ§‹**: é–‹å§‹è¦åŠƒèˆ‡å¯¦ä½œæ—¥å¸¸ç‡Ÿé‹ç³»çµ± (Daily Operations)ã€‚
-   **å‰ç«¯é–‹ç™¼å•Ÿå‹•**: è‘—æ‰‹æ¶æ§‹å‰ç«¯å°ˆæ¡ˆï¼Œæº–å‚™ä¸²æ¥ APIã€‚

--

## 2026-02-16 12:00 : API è·¯ç”±å¯¦ä½œèˆ‡é–‹éšŠè¦å‰‡å„ªåŒ– (API Implementation & Team Gen v3.5)

### âœ… é€²åº¦æ‘˜è¦
æœ¬æ¬¡æ›´æ–°æ­£å¼å°‡å¾Œç«¯é‚è¼¯å°è£ç‚º RESTful APIï¼Œå»ºç«‹äº† `Auth`, `Team`, `Game` ä¸‰å¤§è·¯ç”±æ¨¡çµ„ï¼Œä½¿å‰ç«¯èƒ½èˆ‡æ¯”è³½å¼•æ“äº’å‹•ã€‚åŒæ™‚ï¼Œé‡å° **Player System Spec v3.5** é€²è¡Œäº†å¯¦ä½œï¼Œå¼•å…¥äº†ã€Œåˆ†å±¤ä½ç½®è¦†è“‹ (Tiered Position Coverage)ã€æ©Ÿåˆ¶ï¼Œç¢ºä¿ç©å®¶åœ¨é–‹å±€æ™‚ç²å¾—çš„é«˜éšçƒå“¡ (SSR-A) èˆ‡ä¸­éšçƒå“¡ (B-C) èƒ½å‡å‹»åˆ†ä½ˆæ–¼äº”å€‹ä½ç½®ï¼Œé¿å…é™£å®¹çµæ§‹å¤±è¡¡ã€‚æ­¤å¤–ï¼Œæ–°å¢äº†å°ˆæ¡ˆå¿«ç…§å·¥å…·ä»¥åˆ©å¾ŒçºŒç¶­è­·ã€‚

### ğŸ› ï¸ æŠ€è¡“ç´°ç¯€

1.  **API è·¯ç”±å±¤å¯¦ä½œ (`app/routes/`)**
    -   **Auth (`auth.py`)**: 
        -   æ•´åˆ `TeamCreator` èˆ‡ `PlayerGenerator`ã€‚
        -   è¨»å†ŠæˆåŠŸæ™‚ï¼Œç³»çµ±æœƒè‡ªå‹•å»ºç«‹çƒéšŠä¸¦ç”Ÿæˆç¬¦åˆ v3.5 è¦å‰‡çš„ 15 äººåˆå§‹åå–®ï¼Œå¯«å…¥è³‡æ–™åº«ã€‚
    -   **Team (`team.py`)**: 
        -   æä¾› `/api/team/<id>/roster` ç«¯é»ï¼Œå›å‚³åŒ…å«è©³ç´°å±¬æ€§ (Physical, Offense, Defense, Mental) çš„ JSON çµæ§‹ï¼Œä¾›å‰ç«¯é¡¯ç¤ºçƒå“¡å¡ç‰‡ã€‚
    -   **Game (`game.py`)**: 
        -   æä¾› `/api/game/simulate` ç«¯é»ã€‚
        -   å¯¦ä½œ `DBToEngineAdapter`ï¼Œå°‡è³‡æ–™åº«æ¨¡å‹è½‰æ›ç‚ºå¼•æ“æ¨¡å‹ï¼ŒåŸ·è¡Œå–®å ´æ¨¡æ“¬ä¸¦å›å‚³ Box Score èˆ‡ Play-by-Play ç´€éŒ„ã€‚

2.  **é–‹éšŠç”Ÿæˆé‚è¼¯å‡ç´š (Spec v3.5)**
    -   **åˆ†å±¤ä½ç½®è¦†è“‹**:
        -   æ›´æ–° `config/game_config.yaml` èˆ‡ `team_creator.py`ã€‚
        -   **High Tier (SSR/SS/S/A)**: å¼·åˆ¶è¦æ±‚é€™çµ„çƒå“¡å¿…é ˆè¦†è“‹ C, PF, SF, SG, PG å„è‡³å°‘ 1 äººã€‚
        -   **Mid Tier (B/C)**: åŒæ¨£å¼·åˆ¶è¦†è“‹ 5 å€‹ä½ç½®ã€‚
        -   **ç›®çš„**: ç¢ºä¿ç©å®¶é–‹å±€æ™‚ï¼Œç„¡è«–æ˜¯æ ¸å¿ƒä¸»åŠ›é‚„æ˜¯è¼ªæ›¿é™£å®¹ï¼Œéƒ½æœ‰å®Œæ•´çš„æˆ°è¡“åŸ·è¡Œèƒ½åŠ›ã€‚

3.  **è³‡æ–™æ¨¡å‹èˆ‡å·¥å…·æ“´å……**
    -   **Player Model**: æ–°å¢ `grade` æ¬„ä½ (SSR~G)ï¼Œå°‡è©•ç´šæŒä¹…åŒ–ï¼Œæ¸›å°‘åŸ·è¡Œæ™‚æœŸçš„é‡è¤‡è¨ˆç®—ã€‚
    -   **Project Exporter**: æ–°å¢ `scripts/utils/project_exporter.py`ï¼Œå¯ç”ŸæˆåŒ…å«å®Œæ•´æª”æ¡ˆå…§å®¹çš„å°ˆæ¡ˆå¿«ç…§ Markdownï¼Œåˆ©æ–¼ AI è¼”åŠ©é–‹ç™¼èˆ‡ä»£ç¢¼å¯©æŸ¥ã€‚
    -   **Documentation**: æ–°å¢ `ASBL_Database_Schema.md`ï¼Œå®Œæ•´å®šç¾©è³‡æ–™è¡¨çµæ§‹èˆ‡é—œè¯ã€‚

### ğŸ“ ç­†è¨˜
-   **æ¶æ§‹é©—è­‰**: é€é Postman æ¸¬è©¦ `/api/game/simulate`ï¼Œç¢ºèªå¾ DB è®€å–çƒéšŠ -> è½‰æ›æ¨¡å‹ -> å¼•æ“æ¨¡æ“¬ -> å›å‚³ JSON çš„æµç¨‹é †æš¢ç„¡èª¤ï¼Œå¹³å‡éŸ¿æ‡‰æ™‚é–“åœ¨ 200ms å…§ (è¦–æ¨¡æ“¬è¤‡é›œåº¦è€Œå®š)ã€‚
-   **è³‡æ–™åº«è®Šæ›´**: `Player` è¡¨æ–°å¢äº† `grade` æ¬„ä½ï¼Œéœ€åŸ·è¡Œ Migrationã€‚

### ğŸ”œ ä¸‹ä¸€æ­¥è¨ˆç•«
-   **å‰ç«¯æ¶æ§‹æ­å»º**: åˆå§‹åŒ– React + Vite + TypeScript å°ˆæ¡ˆã€‚
-   **UI é–‹ç™¼**: å¯¦ä½œç™»å…¥é é¢ã€çƒéšŠé™£å®¹ç®¡ç†é é¢ (Roster) èˆ‡æ¯”è³½ç›´æ’­é é¢ (Live Game)ã€‚

--


```

---

### ğŸ“„ File: `README.md`

```markdown
# ASBL Basketball Manager (ASBL)

ASBL æ˜¯ä¸€æ¬¾åŸºæ–¼ç¶²é çš„æ–‡å­—ç­–ç•¥ç¶“ç‡ŸéŠæˆ² (Web-based Text Strategy Game)ã€‚ç©å®¶æ‰®æ¼”çƒéšŠç¶“ç†ï¼Œåœ¨åš´æ ¼çš„è–ªè³‡é™åˆ¶ä¸‹ï¼Œé€éé¸ç§€ã€äº¤æ˜“ã€åŸ¹é¤Šèˆ‡æˆ°è¡“èª¿åº¦ï¼Œæ‰“é€ å±¬æ–¼è‡ªå·±çš„å† è»ç‹æœã€‚

æœ¬å°ˆæ¡ˆæ¡ç”¨ **Python 3.13 (Flask)** ä½œç‚ºå¾Œç«¯æ¡†æ¶ï¼Œæ­é… **MySQL 9.0** è³‡æ–™åº«é€²è¡Œé–‹ç™¼ï¼Œä¸¦å¼•å…¥ **Polars** èˆ‡ **Parquet** é€²è¡Œå¤§æ•¸æ“šç´šåˆ¥çš„æ•¸å€¼å¹³è¡¡é©—è­‰ã€‚

---

## ğŸ“š éŠæˆ²æ ¸å¿ƒè¦å‰‡ (Game Rules)

### 1. çƒå“¡ç³»çµ± (Player System) - Spec v3.3

> âš ï¸ **è©³ç´°æŠ€è¡“è¦æ ¼**ï¼šé—œæ–¼çƒå“¡ç”Ÿæˆæ¼”ç®—æ³•ã€å¸¸æ…‹åˆ†ä½ˆåƒæ•¸ã€é–‹éšŠé™£å®¹æª¢æ ¸é‚è¼¯ï¼Œè«‹åƒé–± [ASBL_Player_System_Specification.md](ASBL_Player_System_Specification.md)ã€‚

#### å±¬æ€§ (Attributes) - Spec v2.6
çƒå“¡èƒ½åŠ›å€¼ç¯„åœç‚º **1~99**ï¼Œåˆ†ç‚ºäº”å¤§é¡ï¼š
*   **é‹å‹• (Physical)**: é«”åŠ›ã€åŠ›é‡ã€é€Ÿåº¦ã€å½ˆè·³ã€å¥åº·(éš±è—)ã€‚
*   **æŠ•ç±ƒ (Offense - Shooting)**: æŠ•ç±ƒæº–å¿ƒã€å°„ç¨‹ã€æ‰‹æ„Ÿ(ä¸å¯è¨“)ã€å‡ºæ‰‹é€Ÿåº¦(ä¸å¯è¨“)ã€‚
*   **é€²æ”» (Offense - Skill)**: å‚³çƒã€é‹çƒã€æ§çƒã€è·‘ä½ã€‚
*   **é˜²å®ˆ (Defense)**: ç±ƒæ¿ã€å¡ä½ã€å¹²æ“¾ã€æŠ„æˆªã€‚
*   **å¤©è³¦ (Mental)**: é€²æ”»æ™ºå•†ã€é˜²å®ˆæ™ºå•†ã€é‹æ°£(éš±è—)ã€‚(æ°¸ä¸æ”¹è®Š)

#### å¹´é½¡ç”Ÿæˆ (Age Generation)
*   **SSR**: å›ºå®š 18 æ­² (æ¥µå…·åŸ¹é¤Šåƒ¹å€¼)ã€‚
*   **G~SS**: ç­‰ç´šè¶Šä½ï¼Œåˆå§‹å¹´é½¡æµ®å‹•ç¯„åœè¶Šå¤§ (Gç´šå¯èƒ½é«˜é” 24 æ­²)ã€‚

#### ç¨€æœ‰åº¦åˆ†ç´š (Rarity)
åŸºæ–¼ã€Œä¸å¯è¨“ç·´é …ç›®ã€çš„æ•¸å€¼ç¸½å’Œé€²è¡Œåˆ†ç´šï¼š
*   **SSR**: > 950
*   **SS**: 900 - 950
*   **S**: 800 - 899
*   **A**: 700 - 799
*   **B**: 600 - 699
*   **C**: 400 - 599
*   **G**: < 400

#### æˆé•·èˆ‡é€€åŒ– (Growth & Decline)
*   **æˆé•·æœŸ (18-25æ­²)**: æ¯ä¸Šå ´ 48 åˆ†é˜ç²å¾— 1 è¨“ç·´é»ã€‚
*   **å·”å³°æœŸ (26-29æ­²)**: æ¯ä¸Šå ´ 144 åˆ†é˜ç²å¾— 1 è¨“ç·´é»ã€‚
*   **é€€åŒ–æœŸ (30æ­²+)**: éš¨ä¸Šå ´æ™‚é–“èˆ‡å¹´é½¡å¢é•·ï¼Œæœ‰æ©Ÿç‡æ‰£é™¤èƒ½åŠ›é»æ•¸ã€‚

#### ç”Ÿæˆæ©Ÿåˆ¶ (Generation Logic)
*   **èº«é«˜ä¿®æ­£ (Height Correction)**: èº«é«˜æœƒå°å±¬æ€§ç”¢ç”Ÿç‰©ç†å½±éŸ¿ï¼ˆå¦‚ï¼šçŸ®å€‹å­é‹çƒ/é€Ÿåº¦åŠ æˆï¼Œé«˜å€‹å­é‹çƒæ‡²ç½°ï¼‰ã€‚
*   **å¹´é½¡ç”Ÿæˆ**: SSR å›ºå®š 18 æ­² (æ¥µå…·åŸ¹é¤Šåƒ¹å€¼)ï¼Œç­‰ç´šè¶Šä½åˆå§‹å¹´é½¡ç¯„åœè¶Šå¤§ã€‚
*   **é–‹éšŠæª¢æ ¸**: åˆå§‹é™£å®¹å¼·åˆ¶åŸ·è¡Œã€Œé«˜éšä½ç½®è¦†è“‹ã€æª¢æŸ¥ï¼Œç¢ºä¿ SSR/SS/S çƒå“¡æ¶µè“‹ 5 å€‹ä½ç½®ã€‚

---

### 2. è–ªè³‡èˆ‡åˆç´„ (Salary & Contract)

#### è–ªè³‡å¸½ (Salary Cap)
*   **ç¡¬ä¸Šé™**: åœ˜éšŠç¸½è–ªè³‡ä¸å¯è¶…é **100%** (åº•è–ªåˆç´„ä¾‹å¤–)ã€‚
*   **è±ªè¯ç¨…**: è¶…é 100% éœ€æ”¯ä»˜å€ç‡ç½°æ¬¾ã€‚
*   **ç°½ç´„é™åˆ¶**: è‹¥è–ªè³‡å·²é” 65%ï¼Œå¿…é ˆå…ˆå®Œæˆé ‚è–ªçºŒç´„ (35%)ï¼Œæ‰å¯ç°½ç½²åº•è–ªåˆç´„ã€‚**å¦å‰‡ä¸€æ—¦è¶…é 65% ç©ºé–“ï¼Œå³ç„¡æ³•å®Œæˆé ‚è–ªçºŒç´„ã€‚**

#### è§’è‰²å®šä½èˆ‡ä¸Šå ´æ™‚é–“ (Role & Minutes)
æ¯”è³½ç¸½æ™‚é–“ 240 åˆ†é˜ã€‚ç³»çµ±æ¡ç”¨ **ã€Œä¿åº•æ™‚é–“ + æ¬Šé‡æµ®å‹•ã€** æ¼”ç®—æ³•åˆ†é…æ™‚é–“ã€‚

| è§’è‰²å®šä½ | ä¿åº•æ™‚é–“ (Base) | æ¬Šé‡ç¯„åœ (Weight) | èªªæ˜ |
| :--- | :--- | :--- | :--- |
| **æ˜æ˜Ÿ (Star)** | **30 min** | **-1 ~ 5** | æ ¸å¿ƒä¸»åŠ›ï¼Œæ¥µå…¶ç©©å®šã€‚ |
| **å…ˆç™¼ (Starter)** | **20 min** | **-2 ~ 7** | ä¸»åŠ›ï¼Œæœ‰æ©Ÿæœƒçˆ†ç™¼ç²å¾—é«˜æ™‚æ•¸ã€‚ |
| **ç¶ è‘‰ (Rotation)** | **10 min** | **5 ~ 15** | è¼ªæ›¿æ ¸å¿ƒï¼Œç«¶çˆ­å‰©é¤˜æ™‚é–“ã€‚ |
| **åŠŸèƒ½ (Role)** | **0 min** | **5 ~ 12** | ç„¡ä¿åº•ï¼Œé ç‹€æ…‹çˆ­å–ä¸Šå ´ã€‚ |
| **æ¿å‡³ (Bench)** | **0 min** | **0 ~ 10** | é‚Šç·£äººï¼Œå¯èƒ½ DNPã€‚ |

---

### 3. æ¯”è³½å¼•æ“ (Match Engine) - v2.1

æœ¬ç³»çµ±æ¡ç”¨ç´”æ–‡å­—æ¨¡æ“¬å¼•æ“ï¼Œä¾æ“š **ASBL Spec v2.1** é€²è¡Œé–‹ç™¼ã€‚

#### æ ¸å¿ƒæ©Ÿåˆ¶
*   **é«”åŠ›ç³»çµ± (Stamina)**: 
    - **å¹´é½¡è¡°é€€**: å¹´é½¡è¶…é 20 æ­²å¾Œï¼Œé«”åŠ›æ¶ˆè€—èˆ‡æ¢å¾©æ•ˆç‡éš¨å¹´é½¡ç·šæ€§è¡°é€€ã€‚
    - **å‹•æ…‹æ‡²ç½°**: é«”åŠ›ä½æ–¼ 80 æ™‚èƒ½åŠ›å€¼é–‹å§‹ç·šæ€§ä¸‹æ»‘ã€‚
*   **æ•¸æ“šæ­¸å±¬ (Data Attribution)**:
    - **ééš¨æ©Ÿåˆ†é…**: å¾—åˆ†ã€ç±ƒæ¿ã€åŠ©æ”»ç­‰æ•¸æ“šä¾æ“šçƒå“¡èƒ½åŠ›å€¼ï¼ˆå¦‚èº«é«˜ã€æ™ºå•†ã€é‹çƒï¼‰é€²è¡Œæ¬Šé‡åˆ†é…ã€‚
    - **æˆ°è¡“åœ°ä½**: æ˜æ˜Ÿçƒå“¡ (Star) æ“æœ‰æ›´é«˜çš„å‡ºæ‰‹æ¬Šé‡ã€‚
*   **é€²éšæ•¸æ“š**: æ”¯æ´ Pace (ç¯€å¥)ã€å¿«æ”»æ•ˆç‡ (Fastbreak Efficiency) ç­‰é«˜éšæ•¸æ“šè¨ˆç®—ã€‚
*   **é—œéµæ™‚åˆ» (Clutch)**: ç¬¬å››ç¯€æœ€å¾Œ 2 åˆ†é˜èˆ‡å»¶é•·è³½å¼·åˆ¶æ›ä¸Šæœ€å¼·é™£å®¹ (Best 5)ã€‚
*   **çŠ¯è¦é›¢å ´**: 6 çŠ¯é›¢å ´ï¼Œä¸¦æ¡ç”¨ Positional Top-K é‚è¼¯å‹•æ…‹é‡åˆ†é…å‰©é¤˜æ™‚é–“ã€‚

---

## ğŸ§ª å¤§æ•¸æ“šé©—è­‰æ¶æ§‹ (Big Data Verification)

ç‚ºäº†ç¢ºä¿éŠæˆ²æ•¸å€¼å¹³è¡¡ï¼Œæˆ‘å€‘å»ºç«‹äº†åƒè¬ç´šåˆ¥çš„ ETL æ¸¬è©¦ç®¡ç·šã€‚

*   **æŠ€è¡“æ ¸å¿ƒ**: Python Multiprocessing + Apache Parquet + Polarsã€‚
*   **é©—è­‰è¦æ¨¡**: 100,000,000 (ä¸€å„„) ç­†çƒå“¡ç”Ÿæˆ / 12,000,000 (ä¸€åƒå…©ç™¾è¬) å ´æ¯”è³½æ¨¡æ“¬ã€‚
*   **KPI å ±å‘Š**: è‡ªå‹•åŒ–ç”Ÿæˆ Markdown å ±å‘Šï¼Œè©³è¦‹ `docs/` ç›®éŒ„ã€‚
*   **é©—è­‰é …ç›®**:
    *   å¸¸æ…‹åˆ†ä½ˆ (Normal Distribution) æª¢æ ¸ã€‚
    *   ç¨€æœ‰åº¦ (Rarity) å‡ºç¾æ©Ÿç‡æ”¶æ–‚æª¢æ ¸ã€‚
    *   æ¯”è³½å‹ç‡ã€åˆ†å·®èˆ‡æ•¸æ“šåˆ†ä½ˆ (Box Score) åˆç†æ€§æª¢æ ¸ã€‚

---

## ğŸ“… é–‹ç™¼æ™‚ç¨‹ (Development Roadmap)

### Phase 1: æ ¸å¿ƒæ¶æ§‹ (Foundation) - [å·²å®Œæˆ]
*   [x] **è³‡æ–™åº«å»ºç½®**: è¨­è¨ˆ User, Team, Player, Contract ç­‰æ ¸å¿ƒ Tableã€‚
*   [x] **çƒå“¡ç”Ÿæˆå¼•æ“ (v3.3)**: å¯¦ä½œ 100 æŠ½é‚è¼¯ã€èº«é«˜ä¿®æ­£ã€é«˜éšä½ç½®è¦†è“‹æª¢æ ¸ã€‚
*   [x] **åˆç´„ç³»çµ±**: å¯¦ä½œè§’è‰²å®šä½ã€è–ªè³‡è¨ˆç®—èˆ‡ç°½ç´„é‚è¼¯ã€‚
*   [x] **æ™‚é–“åˆ†é…æ¼”ç®—æ³•**: å¯¦ä½œ `calculate_minutes(roster)` å‡½æ•¸ã€‚
*   [x] **å¤§æ•¸æ“šé©—è­‰**: å®Œæˆ 1 å„„ç­†çƒå“¡ç”Ÿæˆæ¸¬è©¦èˆ‡ KPI é©—æ”¶å ±å‘Šã€‚

### Phase 2: æ¯”è³½èˆ‡æˆé•· (Game Loop) - [å·²å®Œæˆ]
*   [x] **æ¯”è³½å¼•æ“ (v2.1)**: å¯¦ä½œå®Œæ•´å›åˆåˆ¶åˆ¤å®šã€å¿«æ”»ã€çŠ¯è¦ã€ç½°çƒã€èº«é«˜ä¿®æ­£èˆ‡è©³ç´°æ•¸æ“šç´€éŒ„ã€‚
*   [x] **å–®å ´/æ‰¹é‡æ¨¡æ“¬**: å®Œæˆç„¡ DB ä¾è³´çš„å¿«é€Ÿæ¨¡æ“¬è…³æœ¬èˆ‡åƒè¬å ´æ¬¡å£“åŠ›æ¸¬è©¦ã€‚
*   [ ] **æˆé•·ç³»çµ±**: å¯¦ä½œå¹´é½¡æª¢æŸ¥ã€é»æ•¸è¨ˆç®— (æˆé•·/å·”å³°/é€€åŒ–å…¬å¼)ã€‚
*   [ ] **æ’ç¨‹ç³»çµ±**: æ¯æ—¥è‡ªå‹•çµç®—æ¯”è³½ã€æ›´æ–°çƒå“¡å¹´é½¡/åˆç´„å¤©æ•¸ã€‚

### Phase 3: ç¶“æ¿Ÿèˆ‡äº¤æ˜“ (Economy) - [é€²è¡Œä¸­]
*   [ ] **è¯è³½èˆ‡é¸ç§€**: å®šç¾© League çµæ§‹èˆ‡ Draft é‚è¼¯ã€‚
*   [ ] **äº¤æ˜“ç³»çµ±**: å¯¦ä½œæ›å–®ä»‹é¢èˆ‡æ¢ä»¶åŒ¹é…æ¼”ç®—æ³•ã€‚
*   [ ] **è‡ªç”±å¸‚å ´**: å¯¦ä½œç«¶æ¨™ç³»çµ±èˆ‡ RFA (å—é™è‡ªç”±çƒå“¡) æ©Ÿåˆ¶ã€‚
*   [ ] **ä»‹é¢å„ªåŒ–**: å®Œå–„å‰ç«¯é¡¯ç¤ºèˆ‡æ“ä½œé«”é©—ã€‚

---

## ğŸ›  æŠ€è¡“æ¶æ§‹ (Tech Stack)

*   **Backend**: Python 3.13 (Flask)
*   **Database**: MySQL 9.0
*   **Data Analysis**: Polars, Pandas, Apache Parquet
*   **Frontend**: HTML5, CSS3, Jinja2 Templates
*   **ORM**: SQLAlchemy

## ğŸ“‚ ç›®éŒ„çµæ§‹ (Directory Structure)

ASBL-Basketball-Manager/
â”œâ”€ app/                                   # æ ¸å¿ƒæ‡‰ç”¨ç¨‹å¼ç›®éŒ„
â”‚  â”œâ”€ models/                             # [è³‡æ–™åº«æ¨¡å‹å±¤] å®šç¾© SQL Table çµæ§‹
â”‚  â”‚  â”œâ”€ __init__.py                      # åŒ¯å‡º User, Team, Player, Contract, NameLibrary æ–¹ä¾¿å¼•ç”¨
â”‚  â”‚  â”œâ”€ contract.py                      # (ä¿ç•™) è‹¥åˆç´„é‚è¼¯éæ–¼è¤‡é›œå¯ç¨ç«‹ï¼Œç›®å‰å®šç¾©åœ¨ player.py å…§
â”‚  â”‚  â”œâ”€ match.py                         # å®šç¾©æ¯”è³½è³½ç¨‹ (Match) èˆ‡æ¯”è³½æ•¸æ“šç´€éŒ„ (MatchStats)
â”‚  â”‚  â”œâ”€ player.py                        # å®šç¾©çƒå“¡ (Player) åŸºæœ¬è³‡æ–™ã€JSON è©³ç´°æ•¸æ“šèˆ‡åˆç´„ (Contract)
â”‚  â”‚  â”œâ”€ system.py                        # å®šç¾©ç³»çµ±è¼”åŠ©è³‡æ–™è¡¨ï¼Œå¦‚å§“ååº« (NameLibrary)
â”‚  â”‚  â”œâ”€ team.py                          # (ä¿ç•™) è‹¥çƒéšŠé‚è¼¯è¤‡é›œå¯ç¨ç«‹ï¼Œç›®å‰å®šç¾©åœ¨ user.py å…§
â”‚  â”‚  â””â”€ user.py                          # å®šç¾©ä½¿ç”¨è€… (User) å¸³è™Ÿé©—è­‰èˆ‡çƒéšŠ (Team) è³‡é‡‘/è²æœ›
â”‚  â”‚
â”‚  â”œâ”€ routes/                             # [API è·¯ç”±å±¤] è™•ç† HTTP è«‹æ±‚
â”‚  â”‚  â”œâ”€ __init__.py
â”‚  â”‚  â””â”€ auth.py                          # èªè­‰ API: è™•ç†è¨»å†Š (/register) èˆ‡ç™»å…¥ (/login)ï¼Œä¸¦è‡ªå‹•å»ºç«‹çƒéšŠ
â”‚  â”‚
â”‚  â”œâ”€ services/                           # [æ¥­å‹™é‚è¼¯å±¤] è™•ç†è¤‡é›œé‹ç®—ï¼Œä¸ç›´æ¥ç¢°è§¸ HTTP
â”‚  â”‚  â”œâ”€ match_engine/                    # >> æ¯”è³½æ¨¡æ“¬å¼•æ“ (Level 4 Simulation) <<
â”‚  â”‚  â”‚  â”œâ”€ systems/                      # [å¼•æ“å­ç³»çµ±] è² è²¬ç‰¹å®šé ˜åŸŸçš„é‚è¼¯åˆ¤æ–· (Config Driven)
â”‚  â”‚  â”‚  â”‚  â”œâ”€ init.py
â”‚  â”‚  â”‚  â”‚  â”œâ”€ attribution.py             # [æ­¸å±¬åˆ¤å®šç³»çµ±] æ±ºå®šèª°æŠ•ç±ƒã€èª°æŠ“ç±ƒæ¿ã€èª°åŠ©æ”» (ä¾æ“šæ¬Šé‡èˆ‡å±¬æ€§)
â”‚  â”‚  â”‚  â”‚  â”œâ”€ play_logic.py              # (é ç•™) æˆ°è¡“é‚è¼¯
â”‚  â”‚  â”‚  â”‚  â”œâ”€ stamina.py                 # [é«”åŠ›ç³»çµ±] è¨ˆç®—é«”åŠ›æµå¤±/å›å¾©ï¼Œä¸¦å‹•æ…‹æ›´æ–°å±¬æ€§æ‡²ç½°ä¿‚æ•¸
â”‚  â”‚  â”‚  â”‚  â””â”€ substitution.py            # [æ›äººç³»çµ±] åŸ·è¡Œè‡ªå‹•æ›äººã€è™•ç†çŠ¯æ»¿é›¢å ´èˆ‡æ™‚é–“é‡åˆ†é…
â”‚  â”‚  â”‚  â”œâ”€ utils/                        # [å¼•æ“å·¥å…·]
â”‚  â”‚  â”‚  â”‚  â”œâ”€ init.py
â”‚  â”‚  â”‚  â”‚  â”œâ”€ calculator.py              # [æ•¸å€¼è¨ˆç®—å™¨] è™•ç†å±¬æ€§åŠ ç¸½ã€éè¿´è§£æ Configã€å‘½ä¸­ç‡å…¬å¼è¨ˆç®—
â”‚  â”‚  â”‚  â”‚  â””â”€ rng.py                     # [éš¨æ©Ÿäº‚æ•¸] æ¥µè‡´æ•ˆèƒ½å„ªåŒ–çš„ RNG é¡åˆ¥ (ç¶å®š random åº•å±¤å‡½å¼)
â”‚  â”‚  â”‚  â”œâ”€ init.py
â”‚  â”‚  â”‚  â”œâ”€ core.py                       # å¼•æ“æ ¸å¿ƒ: æ§åˆ¶æ¯”è³½æµç¨‹ (è·³çƒ -> ç¯€æ¬¡ -> å›åˆ -> çµç®—)
â”‚  â”‚  â”‚  â”œâ”€ service.py                    # æ©‹æ¥æœå‹™: è² è²¬ DB è³‡æ–™ <-> Engine ç‰©ä»¶è½‰æ›
â”‚  â”‚  â”‚  â””â”€ structures.py                 # [å¼•æ“å°ˆç”¨çµæ§‹] EnginePlayer/EngineTeam (ä½¿ç”¨ slots å„ªåŒ–æ•ˆèƒ½)
â”‚  â”‚  â”‚
â”‚  â”‚  â”œâ”€ init.py
â”‚  â”‚  â”œâ”€ player_generator.py              # çƒå“¡ç”Ÿæˆå™¨: ç”¢ç”Ÿç¬¦åˆå¸¸æ…‹åˆ†ä½ˆçš„èº«é«˜ã€ä½ç½®ã€SSR~G ç´šèƒ½åŠ›å€¼ (Spec v3.3)
â”‚  â”‚  â””â”€ team_creator.py                  # çƒéšŠçµ„å»ºå™¨: å‘¼å«ç”Ÿæˆå™¨æ¹Šæ»¿ 15 äººï¼Œä¸¦æª¢æ ¸é™£å®¹å®Œæ•´æ€§ (å¦‚è‡³å°‘2å€‹PG)
â”‚  â”œâ”€ templates/                          # (ç›®å‰ç„¡å…§å®¹)
â”‚  â”œâ”€ utils/
â”‚  â”‚  â””â”€ game_config_loader.py            # [è¨­å®šè¼‰å…¥å™¨] Singleton æ¨¡å¼è®€å– YAMLï¼Œæ”¯æ´ç’°å¢ƒè®Šæ•¸è·¯å¾‘
â”‚  â””â”€ __init__.py
â”‚
â”œâ”€ config/
â”‚  â””â”€ game_config.yaml                    # [éŠæˆ²å¹³è¡¡æª”] å®šç¾©æ‰€æœ‰æ©Ÿç‡ã€æ¬Šé‡ã€è–ªè³‡å…¬å¼ (Spec v2.5 & v1.6)
â”‚
â”œâ”€ docs/                                  # [å°ˆæ¡ˆæ–‡ä»¶]
â”‚  â”œâ”€ DEV_JOURNAL_BigData_Architecture.md # [æ¶æ§‹æ—¥èªŒ] è¨˜éŒ„å¾å–®æ©Ÿåˆ° ETL Pipeline çš„æ¼”é€²
â”‚  â”œâ”€ team_creator_test_report_*.md       # [é©—æ”¶å ±å‘Š] é–‹éšŠèˆ‡æ¯”è³½æ¨¡æ“¬æ¸¬è©¦å ±å‘Š
â”‚  â””â”€ KPI_Validation_Report_v2_6.md       # [é©—æ”¶å ±å‘Š] 1å„„ç­†è³‡æ–™ç”Ÿæˆçš„çµ±è¨ˆçµæœ (æ¥µç«¯å€¼ã€åˆ†ä½ˆæª¢æ ¸)
â”œâ”€ scripts/
â”‚  â”œâ”€ utils/
â”‚  â”‚  â””â”€ tree.py                          # å°ˆæ¡ˆæª”æ¡ˆæ¨¹ç”¢ç”Ÿå™¨
â”‚  â”œâ”€ __init__.py
â”‚  â”œâ”€ init_db.py                          # èˆŠæª”æ¡ˆ
â”‚  â”œâ”€ debug_team_generation.py            # [New] çƒéšŠç”Ÿæˆé™¤éŒ¯å·¥å…·
â”‚  â”œâ”€ simulate_match_no_db.py             # æ¸¬è©¦å»ºç«‹å…©æ”¯çƒéšŠä¸¦ä¸”åŸ·è¡Œæ¯”è³½
â”‚  â”œâ”€ terminal.py                         # æ¸…ç©ºçµ‚ç«¯é¡¯ç¤º
â”‚  â””â”€ test_auth.py                        # èˆŠæª”æ¡ˆ
â”œâ”€ tests/
â”‚  â”œâ”€ big_data/                           # >> å¤§æ•¸æ“šé©—è­‰æ¶æ§‹ (ETL Pipeline) <<
â”‚  â”‚  â”œâ”€ output/                          # [è³‡æ–™è¼¸å‡º] (è‡ªå‹•å»ºç«‹) å­˜æ”¾ç”Ÿæˆçš„ .parquet æª”æ¡ˆ
â”‚  â”‚  â”‚  â”œâ”€ dry_run/                      # è©¦è·‘ç”¢ç”Ÿçš„æš«å­˜æª”
â”‚  â”‚  â”‚  â””â”€ run_v2_6_dataset_*/           # æ­£å¼æ¸¬è©¦ç”¢ç”Ÿçš„åˆ†ç‰‡è³‡æ–™é›†
â”‚  â”‚  â”‚
â”‚  â”‚  â”œâ”€ logs/                            # [åŸ·è¡Œç´€éŒ„] (è‡ªå‹•å»ºç«‹) å­˜æ”¾ execution_history.log
â”‚  â”‚  â”‚
â”‚  â”‚  â”œâ”€ __init__.py
â”‚  â”‚  â”œâ”€ test_config.yaml                 # [æ¸¬è©¦é…ç½®] è¨­å®š Worker æ•¸é‡ã€Batch Sizeã€è¼¸å‡ºè·¯å¾‘
â”‚  â”‚  â”‚
â”‚  â”‚  â”œâ”€ verify_generator_integration.py  # [ç”Ÿç”¢è€… (Producer)] **ä¸»åŸ·è¡Œè…³æœ¬**
â”‚  â”‚  â”‚                                   # 1. è² è²¬å•Ÿå‹• Multiprocessing Pool
â”‚  â”‚  â”‚                                   # 2. å‘¼å« PlayerGenerator ç”Ÿæˆæ•¸æ“š
â”‚  â”‚  â”‚                                   # 3. å°‡æ•¸æ“šå¯«å…¥ Parquet æª”æ¡ˆ (ETL)
â”‚  â”‚  â”‚
â”‚  â”‚  â”œâ”€ verify_kpi_v2_6.py               # [é©—è­‰è€… (Validator)] **KPI é©—æ”¶è…³æœ¬**
â”‚  â”‚  â”‚                                   # 1. ä½¿ç”¨ Polars é«˜é€Ÿè®€å– Parquet
â”‚  â”‚  â”‚                                   # 2. åŸ·è¡Œçµ±è¨ˆåˆ†æ (èº«é«˜åˆ†ä½ˆã€ç­‰ç´šæ©Ÿç‡ã€æ¥µç«¯å€¼)
â”‚  â”‚  â”‚                                   # 3. è¼¸å‡º Markdown å ±å‘Šèˆ‡ Log
â”‚  â”‚  â”‚
â”‚  â”‚  â”œâ”€ analyze_data.py                  # [æª¢è¦–å™¨ (Viewer)]
â”‚  â”‚  â”‚                                   # ä½¿ç”¨ Pandas å¿«é€Ÿé è¦½ dry_run.parquet çš„å…§å®¹èˆ‡æ¬„ä½
â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€ check_crash_data.py              # [ç½é›£æ¢å¾© (Recovery)]
â”‚  â”‚                                      # è‹¥æ¸¬è©¦ä¸­æ–·ï¼Œæ­¤è…³æœ¬å¯æƒæ output ç›®éŒ„ï¼Œæª¢æŸ¥å“ªäº› Parquet æª”æ˜¯å®Œå¥½çš„
â”‚  â””â”€ __init__.py
â”œâ”€â”€ ASBL_Match_Engine_Specification.md # [Updated] æ¯”è³½å¼•æ“è¦æ ¼æ›¸ (v2.1)
â”œâ”€â”€ ASBL_Player_System_Specification.md # çƒå“¡ç³»çµ±è¦æ ¼æ›¸ (v3.3)
â”œâ”€â”€ config.py                # App Configuration (Flask è¨­å®š)
â””â”€â”€ run.py                   # Entry Point (ç¨‹å¼å…¥å£)
```

---

### ğŸ“„ File: `requirements.txt`

```text
Flask==3.0.0
Flask-SQLAlchemy==3.1.1
Flask-Migrate==4.0.5
Flask-Login==0.6.3
PyMySQL==1.1.0
cryptography
python-dotenv
```

---

### ğŸ“„ File: `run.py`

```python
# run.py
from app import create_app

app = create_app()

if __name__ == '__main__':
    # debug=True ä»£è¡¨é–‹ç™¼æ¨¡å¼ï¼Œç¨‹å¼ç¢¼ä¿®æ”¹å¾Œæœƒè‡ªå‹•é‡å•Ÿï¼Œä¸”å ±éŒ¯æœƒé¡¯ç¤ºè©³ç´°è³‡è¨Š
    print("ğŸš€ ASBL ä¼ºæœå™¨å•Ÿå‹•ä¸­... http://127.0.0.1:5000")
    app.run(debug=True)
```

---

